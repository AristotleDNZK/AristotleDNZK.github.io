<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" href="https://aristotlednzk.github.io.com/rss.xml"><link rel="alternate" type="application/atom+xml" href="https://aristotlednzk.github.io.com/atom.xml"><link rel="alternate" type="application/json" href="https://aristotlednzk.github.io.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="C++,Linux高性能服务器编程"><link rel="canonical" href="https://aristotlednzk.github.io.com/2022/11/15/cpp/%E9%A1%B9%E7%9B%AE/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/"><title>Linux多线程开发 - Linux高性能服务器编程 - C++ | Sean Barrett = = 远行者回忆录——人类往事</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Linux多线程开发</h1><div class="meta"><span class="item" title="创建时间：2022-11-15 11:28:58"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-11-15T11:28:58+08:00">2022-11-15</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>4.5k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>4 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Sean Barrett</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeu1usa7j20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipey84bjtj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://gss0.baidu.com/-vo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/6159252dd42a2834f1cb81bf57b5c9ea15cebf11.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclh0m9pdj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclgi503lj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicljitigmj20zk0m87fp.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/cpp/" itemprop="item" rel="index" title="分类于 C++"><span itemprop="name">C++</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/cpp/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/" itemprop="item" rel="index" title="分类于 Linux高性能服务器编程"><span itemprop="name">Linux高性能服务器编程</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://aristotlednzk.github.io.com/2022/11/15/cpp/%E9%A1%B9%E7%9B%AE/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sean Barrett"><meta itemprop="description" content="远行者回忆录——人类往事, 思及我域"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><h2 id="线程概念"><a class="anchor" href="#线程概念">#</a> 线程概念</h2><p>与进程 (process）类似，线程 (thread) 是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。(传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程)</p><p><strong>进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。</strong></p><p>线程是轻量级的进程（LWP: Light weight Process)，在 Linux 环境下线程的本质仍是进程。</p><p>查看指定进程的 LWP 号：ps -Lf pid</p><ul><li>进程之间的信息难以共享</li><li>fork（）创建进程的代价相对较高 —— 写时复制</li><li>创建线程是共用原来的虚拟地址空间，只是<strong>栈空间和代码段.text</strong> 细分给不同线程，而堆空间都是共享的</li></ul><p><img data-src="/2022/11/15/cpp/%E9%A1%B9%E7%9B%AE/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" title="多线程"></p><h2 id="线程创建"><a class="anchor" href="#线程创建">#</a> 线程创建</h2><p>main 函数所在线程称为主线程。 程序默认只有一个进程和线程</p><pre><code class="language-C++">pthread_t tid;
int ret=pthread_create(&amp;tid,NULL,callback,NULL);

int pthread_create(pthread_t *thread,const pthread_attr_t *attr,void *(start_routine) (void *),void *arg);
</code></pre><p>thread: 传出参数，线程创建成功后，子线程的线程 ID 被写到该变量中 attr：设置线程的属性，默认值 NULL start_routine：函数指针，<strong>这个函数是子线程需要处理的逻辑代码</strong> arg：第三个参数使用，传参</p><p>返回值：成功返回 0，失败返回错误号</p><h2 id="线程同步"><a class="anchor" href="#线程同步">#</a> 线程同步</h2><p>线程优势：能够通过全局变量来共享信息。但必须确保线程安全</p><p>临界区：访问共享资源的代码片段，并且这段代码的执行应该为原子操作 —— 同时访问同一个共享资源的线程不能执行该区域代码到一半中断。</p><p>线程同步：当有一个线程在对内存进行操作的时候，其他线程都不能对这个内存地址进行操作，知道该线程完成操作，其他线程都处于等待状态</p><p><strong>终止线程</strong>：在哪个线程中调用就终止哪个线程</p><pre><code class="language-C++">pthread_exit(void* retval);
</code></pre><p>retval：需要传递一个指针作为返回值，可以在 pthread_join () 中获取到</p><pre><code class="language-C++">pthread_t pthread_self(void);
pthread_self();
</code></pre><p>获取当前的线程的线程 ID</p><pre><code class="language-C++">pthread_exit(NULL);
</code></pre><p>由于 return 0 会让进程退出，那所有线程资源都会被释放，因此可以在主线程中调用，让其他线程继续执行，单独<strong>让主线程退出，当主线程退出时，不会影响其他正常运行的线程</strong></p><h2 id="互斥量"><a class="anchor" href="#互斥量">#</a> 互斥量</h2><p>确保同时仅有一个线程可以访问某共享资源，保证对共享资源的原子访问。</p><p>互斥量有两种状态：已锁定和未锁定。至多只有一个线程可以锁定该互斥量。只有所有者才能给互斥量解锁</p><p><strong>创建互斥量类型 pthread_mutex_t</strong>：一般在全局创建，在主函数 main 中初始化</p><p><strong>初始化互斥量</strong></p><pre><code class="language-C++">int pthread_mutex_init(pthread_mutex_init *restrict mutex, const pthread_mutexattr_t attr);
</code></pre><p>mutex：需要初始化的互斥量变量 attr：互斥量相关的属性，默认 NULL</p><p>restrict：C 语言修饰符，被修饰的指针不能由另外的一个指针进行操作</p><p><strong>释放互斥量的资源</strong></p><pre><code class="language-C++">int pthread_mutex_destroy(pthread_mutex_init * mutex);
</code></pre><p><strong>加锁：阻塞的</strong>：如果已经有一个线程加锁了，那么其他线程只能阻塞等待</p><pre><code class="language-C++">int pthread_mutex_lock(pthread_mutex_init * mutex);
</code></pre><p><strong>解锁</strong></p><pre><code class="language-C++">int pthread_mutex_unlock(pthread_mutex_init * mutex);
</code></pre><h2 id="条件变量互斥锁"><a class="anchor" href="#条件变量互斥锁">#</a> 条件变量 + 互斥锁</h2><p>条件变量其实就是一种通知机制：当线程发现资源被锁定时条件变量就会将其阻塞，让出 CPU 的控制权给其他线程，当资源被释放时，那些阻塞线程被唤醒，线程重新检查资源可用性，从而获得资源并上锁或是重新阻塞。因此条件变量是一种通知模型的同步方式。</p><p>条件变量一般是用于<strong>让生产者线程和消费者线程之间以及消费者线程之间互斥的访问临界资源</strong>（临界资源指的是<strong>同时只允许一个线程访问的共享资源</strong>）。条件变量的使用一般是需要结合互斥锁来进行（条件变量相关函数的输入参数就是互斥锁），从而使得各个线程能够互斥的访问该临界资源。</p><p>想办法：当资源上的锁被释放时就通知等待该资源的线程，当有线程正在使用资源时就将其他想访问该资源的线程阻塞呢</p><h3 id="二-条件变量的使用"><a class="anchor" href="#二-条件变量的使用">#</a> 二 条件变量的使用</h3><p>条件变量在 pthread.h 头文件中。</p><h4 id="21-条件变量的初始化"><a class="anchor" href="#21-条件变量的初始化">#</a> 2.1 条件变量的初始化</h4><pre><code class="language-C++">int pthread_cond_init(pthread_cond_t* *cond,const pthread_condattr_t* *cond_attr);
</code></pre><p>函数功能：用于初始化一个条件变量。</p><p>函数参数：</p><p>1.cond：用于指向目标条件变量。</p><p>2.cond_attr：用于设置条件变量属性，置 NULL 表示条件变量属性为默认值。</p><h4 id="22-条件变量的销毁"><a class="anchor" href="#22-条件变量的销毁">#</a> 2.2 条件变量的销毁</h4><pre><code class="language-C++">int pthread_cond_destroy(pthread_cond_t*cond);
</code></pre><p>函数功能：用于销毁条件变量。</p><h4 id="23-条件变量的通知机制"><a class="anchor" href="#23-条件变量的通知机制">#</a> 2.3 条件变量的通知机制</h4><pre><code class="language-C++">int pthread_cond_signal(pthread_cond_t**cond);
int pthread_cond_broadcast(pthread_cond_t**cond);
</code></pre><p><strong>函数功能：</strong></p><p>条件变量的通知方法有两种：</p><p>1. 根据线程的优先级和调度策略唤醒一个等待条件变量的线程的 pthread_cond_signal () 函数</p><p>2. 唤醒所有等待条件变量的线程的 pthread_cond_broadcast () 函数。</p><h4 id="24-条件变量的等待"><a class="anchor" href="#24-条件变量的等待">#</a> 2.4 条件变量的等待</h4><pre><code class="language-C++">int pthread_cond_wait(pthread_cond_t**cond，pthread_mutex_t* *mutex);
int pthread_cond_timedwait(pthread_cond_t*cond，pthread_mutex_t *mutex,const struct timespec *abstime);
</code></pre><p><strong>pthread_cond_wait</strong> 函数功能：调用该函数的线程会阻塞等待</p><p>当没有容器内数据了，用于<strong>阻塞等待生产者生产数据，直到符合某个条件变量</strong>即被其他线程调用 pthread_cond_signal 唤醒才继续执行。函数的内部实现机制是：</p><ul><li>1. 当调用该函数前，一般会判断某个临界资源是否满足要求，如果不满足，则调用该函数，函数内部实现：<strong>将该线程挂起放在条件变量的请求队列，然后解除互斥锁</strong>（以便生产者拿到锁去生产数据）；</li><li>2. 当该<strong>线程被唤醒不阻塞时，会再次对互斥锁加锁</strong>，然后返回，从而继续判断临界资源是否满足条件。</li></ul><p>pthread_cond_timedwait 函数功能：等待多长时间，调用了这个函数，线程会阻塞，直到指定时间结束</p><h4 id="25-条件变量为什么要和互斥锁结合使用"><a class="anchor" href="#25-条件变量为什么要和互斥锁结合使用">#</a> 2.5 条件变量为什么要和互斥锁结合使用</h4><p>我个人的理解是，<strong>条件变量主要是使用一种通知机制来让各个线程来处理临界资源，但是为了保证线程安全，需要使得各个线程来互斥的访问临界资源</strong>：</p><p>如果没有互斥锁，则：</p><p>1. 调用条件变量通知函数唤醒所有的等待线程的话，很有可能导致临界资源被多个线程重复处理，甚至导致错误的发生，因此为了方便，每个线程被唤醒返回 pthread_cond_wait () 函数时，一般会对互斥锁加锁，这样其他被唤醒的线程只能阻塞等待此线程释放该互斥锁，从而实现互斥的对于临界资源的访问。</p><p>2. 当此<strong>线程处理完临界资源后</strong>会在此调用 pthread_cond_wait () 函数，<strong>将该线程挂起至等待条件变量队列</strong>，然后释放互斥锁，让其他线程被唤醒继续处理该临界资源。</p><h3 id="问题集"><a class="anchor" href="#问题集">#</a> 问题集：</h3><p><strong><code>pthread_cond_wait内部为什么要解锁？</code></strong></p><p>如果 while 或者 if 判断的时候，满足执行条件，线程便会调用 pthread_cond_wait 阻塞自己，此时它还在持有锁，如果他不解锁，那么其他线程将会无法访问公有资源。</p><p>具体到 pthread_cond_wait 的内部实现，当 pthread_cond_wait 被调用线程阻塞的时候，pthread_cond_wait 会自动释放互斥锁。</p><p><strong><code>为什么要把调用线程放入条件变量的请求队列后再解锁？</code></strong></p><p>线程是并发执行的，如果在把调用线程 A 放在等待队列之前，就释放了互斥锁，这就意味着其他线程比如线程 B 可以获得互斥锁去访问公有资源，这时候线程 A 所等待的条件改变了，但是它<strong>没有被放在等待队列上，导致 A 忽略了等待条件被满足的信号。</strong></p><p>倘若在线程 A 调用 pthread_cond_wait 开始，到把 A 放在等待队列的过程中，都持有互斥锁，其他线程无法得到互斥锁，就不能改变公有资源。</p><p><strong><code>为什么最后还要加锁？</code></strong></p><p>将线程放在条件变量的请求队列后，将其解锁，此时等待被唤醒，若成功竞争到互斥锁，再次加锁。</p><p><strong><code>为什么判断线程执行的条件用while而不是if？</code></strong></p><p>一般来说，在多线程资源竞争的时候，在一个使用资源的线程里面（消费者）判断资源是否可用，不可用，便调用 pthread_cond_wait，在另一个线程里面（生产者）如果判断资源可用的话，则调用 pthread_cond_signal 发送一个资源可用信号。</p><p>在 wait 成功之后，资源就一定可以被使用么？答案是否定的，如果同时有两个或者两个以上的线程正在等待此资源，wait 返回后，资源可能已经被使用了。</p><p>再具体点，<strong>有可能多个线程都在等待这个资源可用的信号，信号发出后只有一个资源可用</strong>，但是有 A，B 两个线程都在等待，B 比较速度快，获得互斥锁，然后加锁，消耗资源，然后解锁，<strong>之后 A 获得互斥锁，但 A 回去发现资源已经被使用了</strong>，它便有两个选择，一个是去访问不存在的资源，另一个就是继续等待，那么<strong>继续等待下去的条件就是使用 while</strong>，要不然使用 if 的话 pthread_cond_wait 返回后，就会顺序执行下去。</p><p>所以，在这种情况下，应该使用 while 而不是 if:</p><pre><code class="language-C++">while(resource == FALSE)  
pthread_cond_wait(&amp;cond, &amp;mutex);
</code></pre><p>如果只有一个消费者，那么使用 if 是可以的。</p><h2 id="信号量"><a class="anchor" href="#信号量">#</a> 信号量</h2><p>本身不能保证线程安全，需要和互斥锁一起使用</p><p><strong>信号量初始化</strong></p><pre><code class="language-C++">int sem_init(sem_t *sem,int pshared,unsigned int value);
</code></pre><p>value：设置信号量中的值，表示可用的资源个数。类比灯泡用一个灭一个 sem：信号量变量的地址 pshared：代表这个变量是用在线程之间（0）还是进程之间（非 0）</p><p>** 加锁一个信号量：**<strong> 阻塞函数 - 对信号量值减一</strong>：当调用的信号量 sem 中的值 value 为 0 时才阻塞，<strong> 调用一次 wait，value 值 - 1</strong></p><pre><code class="language-C++">int sem_wait(sem_t *sem);
</code></pre><p><strong>解锁一个信号量</strong>：<strong>增加信号量的值</strong>：<strong>调用一次 value+1</strong></p><pre><code class="language-C++">int sem_post(sem_t *sem);
</code></pre><p><strong>释放资源</strong></p><pre><code class="language-C++">int sem_destroy(sem_t *sem);
</code></pre><div class="tags"><a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C++</a> <a href="/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/" rel="tag"><i class="ic i-tag"></i> Linux高性能服务器编程</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-11-29 13:37:44" itemprop="dateModified" datetime="2022-11-29T13:37:44+08:00">2022-11-29</time> </span><span id="2022/11/15/cpp/项目/Linux多线程开发/" class="item leancloud_visitors" data-flag-title="Linux多线程开发" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/alipay.jpg" alt="Sean Barrett 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Sean Barrett <i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong> <a href="https://aristotlednzk.github.io.com/2022/11/15/cpp/%E9%A1%B9%E7%9B%AE/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" title="Linux多线程开发">https://aristotlednzk.github.io.com/2022/11/15/cpp/项目/Linux多线程开发/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/11/15/cpp/%E9%A1%B9%E7%9B%AE/%E5%8D%8A%E5%90%8C%E6%AD%A5-%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E7%BA%BF%E7%A8%8B%E6%B1%A0/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicljgocqbj20zk0m8e81.jpg" title="半同步&#x2F;半反应堆线程池"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 项目</span><h3>半同步/半反应堆线程池</h3></a></div><div class="item right"><a href="/2022/11/29/cpp/%E9%A1%B9%E7%9B%AE/%E5%AE%9A%E6%97%B6%E5%99%A8/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclize41wj20zk0m87gk.jpg" title="定时器"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 项目</span><h3>定时器</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">线程概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">2.</span> <span class="toc-text">线程创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">3.</span> <span class="toc-text">线程同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-number">4.</span> <span class="toc-text">互斥量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">条件变量 + 互斥锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text">二 条件变量的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.1.1.</span> <span class="toc-text">2.1 条件变量的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-number">5.1.2.</span> <span class="toc-text">2.2 条件变量的销毁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">5.1.3.</span> <span class="toc-text">2.3 条件变量的通知机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E7%AD%89%E5%BE%85"><span class="toc-number">5.1.4.</span> <span class="toc-text">2.4 条件变量的等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">5.1.5.</span> <span class="toc-text">2.5 条件变量为什么要和互斥锁结合使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E9%9B%86"><span class="toc-number">5.2.</span> <span class="toc-text">问题集：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">6.</span> <span class="toc-text">信号量</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/10/15/cpp/%E9%A1%B9%E7%9B%AE/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9Asocket%E3%80%81IO%E5%A4%8D%E7%94%A8%E3%80%81epoll/" rel="bookmark" title="Linux网络编程：socket、IO复用、epoll">Linux网络编程：socket、IO复用、epoll</a></li><li class="active"><a href="/2022/11/15/cpp/%E9%A1%B9%E7%9B%AE/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" rel="bookmark" title="Linux多线程开发">Linux多线程开发</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sean Barrett" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sean Barrett</p><div class="description" itemprop="description">思及我域</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">21</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">16</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">16</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FyaXN0b3RsZUROWks=" title="https:&#x2F;&#x2F;github.com&#x2F;AristotleDNZK"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTk0NTI2OTQy" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;94526942"><i class="ic i-cloud-music"></i></span> <a href="/jiang1302833@163.com" title="jiang1302833@163.com" class="item email"><i class="ic i-envelope"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-clipboard"></i>书架</a><ul class="submenu"><li class="item"><a href="/books/deeplearning-books/" rel="section"><i class="ic i-fedora"></i>人工智能</a></li><li class="item"><a href="/books/philosophy-books/" rel="section"><i class="ic i-fedora"></i>哲学</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>链环</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/11/15/cpp/%E9%A1%B9%E7%9B%AE/%E5%8D%8A%E5%90%8C%E6%AD%A5-%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/11/29/cpp/%E9%A1%B9%E7%9B%AE/%E5%AE%9A%E6%97%B6%E5%99%A8/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/cpp/" title="分类于 C++">C++</a> <i class="ic i-angle-right"></i> <a href="/categories/cpp/%E9%A1%B9%E7%9B%AE/" title="分类于 项目">项目</a></div><span><a href="/2022/11/29/cpp/%E9%A1%B9%E7%9B%AE/%E5%AE%9A%E6%97%B6%E5%99%A8/" title="定时器">定时器</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 转码之路">转码之路</a></div><span><a href="/2022/10/11/computer-science/%E8%BD%AC%E7%A0%81%E4%B9%8B%E8%B7%AF/" title="转码之路">转码之路</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/cpp/" title="分类于 C++">C++</a> <i class="ic i-angle-right"></i> <a href="/categories/cpp/%E9%A1%B9%E7%9B%AE/" title="分类于 项目">项目</a></div><span><a href="/2022/11/10/cpp/%E9%A1%B9%E7%9B%AE/Tinywebserver%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/" title="Tinywebserver项目记录">Tinywebserver项目记录</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/10/09/hello-world/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/philosophy/" title="分类于 哲学社科">哲学社科</a> <i class="ic i-angle-right"></i> <a href="/categories/philosophy/%E8%A5%BF%E5%93%B2/" title="分类于 西哲">西哲</a></div><span><a href="/2022/10/12/philosophy/%E7%8E%B0%E8%B1%A1%E5%AD%A6-%E8%83%A1%E5%A1%9E%E5%B0%94/%E7%8E%B0%E8%B1%A1%E5%AD%A6-%E8%83%A1%E5%A1%9E%E5%B0%94/" title="现象学&#x2F;胡塞尔">现象学/胡塞尔</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%A8%80/" title="分类于 言">言</a></div><span><a href="/2022/10/12/%E8%BF%9C%E8%A1%8C%E8%80%85%E5%BC%80%E7%AF%87/%E8%BF%9C%E8%A1%8C%E8%80%85%E5%BC%80%E7%AF%87/" title="远行者开篇">远行者开篇</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/GAN%E8%AF%BE%E9%A2%98/" title="分类于 GAN课题">GAN课题</a></div><span><a href="/2022/10/14/GAN%E8%AF%BE%E9%A2%98/%E7%9B%B8%E6%9C%BA%E6%89%8B%E7%9C%BC%E6%A0%87%E5%AE%9A/%E7%9B%B8%E6%9C%BA%E6%89%8B%E7%9C%BC%E6%A0%87%E5%AE%9A/" title="相机手眼标定">相机手眼标定</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/cpp/" title="分类于 C++">C++</a> <i class="ic i-angle-right"></i> <a href="/categories/cpp/%E9%A1%B9%E7%9B%AE/" title="分类于 项目">项目</a> <i class="ic i-angle-right"></i> <a href="/categories/cpp/%E9%A1%B9%E7%9B%AE/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/" title="分类于 Linux高性能服务器编程">Linux高性能服务器编程</a></div><span><a href="/2022/11/15/cpp/%E9%A1%B9%E7%9B%AE/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" title="IO多路复用">IO多路复用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/bug/" title="分类于 bug">bug</a></div><span><a href="/2022/10/15/bug/" title="bug">bug</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/philosophy/" title="分类于 哲学社科">哲学社科</a> <i class="ic i-angle-right"></i> <a href="/categories/philosophy/%E4%B8%AD%E5%93%B2/" title="分类于 中哲">中哲</a></div><span><a href="/2022/10/11/philosophy/%E7%8E%8B%E9%98%B3%E6%98%8E%E5%BF%83%E5%AD%A6/" title="王阳明心学">王阳明心学</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sean Barrett @ Sean Barrett</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">49k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">44 分钟</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/11/15/cpp/项目/Linux多线程开发/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>