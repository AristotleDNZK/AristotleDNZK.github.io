<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" href="https://aristotlednzk.github.io.com/rss.xml"><link rel="alternate" type="application/atom+xml" href="https://aristotlednzk.github.io.com/atom.xml"><link rel="alternate" type="application/json" href="https://aristotlednzk.github.io.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="C++,webserver,socket篇,项目"><link rel="canonical" href="https://aristotlednzk.github.io.com/2022/10/15/cpp/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-socket%E7%AF%87/"><title>Linux高性能服务器编程/socket篇 - socket篇 - webserver - 项目 - C++ | Sean Barrett = = 远行者回忆录——人类往事</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Linux高性能服务器编程/socket篇</h1><div class="meta"><span class="item" title="创建时间：2022-10-15 17:10:54"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-10-15T17:10:54+08:00">2022-10-15</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>17k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>15 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Sean Barrett</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipet4bz0yj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipew28b65j20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giph4fomxoj20zk0m8axp.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giciuv0socj20zk0m8qes.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipey84bjtj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicitf0kl1j20zk0m87fe.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/cpp/" itemprop="item" rel="index" title="分类于 C++"><span itemprop="name">C++</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/cpp/%E9%A1%B9%E7%9B%AE/" itemprop="item" rel="index" title="分类于 项目"><span itemprop="name">项目</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/cpp/%E9%A1%B9%E7%9B%AE/webserver/" itemprop="item" rel="index" title="分类于 webserver"><span itemprop="name">webserver</span></a><meta itemprop="position" content="3"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/cpp/%E9%A1%B9%E7%9B%AE/webserver/socket%E7%AF%87/" itemprop="item" rel="index" title="分类于 socket篇"><span itemprop="name">socket篇</span></a><meta itemprop="position" content="4"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://aristotlednzk.github.io.com/2022/10/15/cpp/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-socket%E7%AF%87/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sean Barrett"><meta itemprop="description" content="远行者回忆录——人类往事, 思及我域"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><h2 id="socket地址api"><a class="anchor" href="#socket地址api">#</a> socket 地址 API</h2><p>字节序问题：CPU 累加器一次装载 4 个字节，那么 4 个字节在内存中排列的顺序将影响它被累加器装载成的整数的值</p><blockquote><p>主机字节序 &amp; 网络字节序：</p></blockquote><ul><li>大端字节序：一个整数的高位字节存储在内存的低位地址，低位字节（0-7bit）存储在内存高位地址， 称为<strong>网络字节序</strong></li><li>小端字节序相反→现代多采用：称为<strong>主机字节序</strong></li></ul><h3 id="通用socket地址"><a class="anchor" href="#通用socket地址">#</a> 通用 socket 地址：</h3><p>AF_前缀表示地址族， PF_前缀表示协议族。</p><p>unsigned short int→两个字节</p><p>旧版：</p><p>sa_family_t sa_family;//sa_family_t 地址族类型 char sa_data [14];// 只有 14 个字节</p><p><img data-src="/2022/10/15/cpp/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-socket%E7%AF%87/image.png" title="image"></p><h3 id="专用socket地址"><a class="anchor" href="#专用socket地址">#</a> 专用 socket 地址</h3><p>在设置和获取 IP 地址和端口号的上海更方便</p><blockquote><p>TCP 协议族 sockaddr_in 和 sockaddr_in6 两个专用 socket 地址结构体，分别用 IP v4 和 IP v6 所有 socket 编程接口使用的地址参数类型都是<strong> sockaddr</strong>→专用 socket 地址类型的遍历实际使用需要转换为通用 socket 地址类型 sockaddr</p></blockquote><p><img data-src="/2022/10/15/cpp/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-socket%E7%AF%87/2.png" width="2"></p><p>sockaddr_in 每段都划分好了相应成员，最终转换为 sockaddr 指针即可</p><p>.png)</p><p></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP/IP 协议族有 sockaddr_in 和 sockaddr_in6 两个专用的 socket 地址结构体，它们分别用于 IPv4 和 IPv6：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>&#123;</span><br><span class="line"><span class="type">sa_family_t</span> sin_family; <span class="comment">/* _*SOCKADDR_COMMON(sin*) */</span></span><br><span class="line"><span class="type">in_port_t</span> sin_port; <span class="comment">/* Port number. */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr; <span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="built_in">sizeof</span> (<span class="keyword">struct</span> sockaddr) - __SOCKADDR_COMMON_SIZE - <span class="built_in">sizeof</span> (<span class="type">in_port_t</span>) - <span class="built_in">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span>&#123;</span><br><span class="line"><span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span>&#123;</span><br><span class="line"><span class="type">sa_family_t</span> sin6_family;</span><br><span class="line"><span class="type">in_port_t</span> sin6_port; <span class="comment">/* Transport layer port # */</span></span><br><span class="line"><span class="type">uint32_t</span> sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr; <span class="comment">/* IPv6 address */</span></span><br><span class="line"><span class="type">uint32_t</span> sin6_scope_id; <span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span></span><br></pre></td></tr></table></figure><p></p><h2 id="ip地址转换"><a class="anchor" href="#ip地址转换">#</a> IP 地址转换</h2><blockquote><p>字符串 ip - 整数和主机 - 网络字节序的转换</p></blockquote><p>通常，人们习惯用可读性好的<strong>字符串来表示 IP 地址</strong>，比如用点分十进制字符串表示 IPv4 地址，以及用十六进制字符串表示 IPv6 地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用<strong>点分十进制字符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址</strong>之间的转换：</p><p>只适用于 IP v4：</p><p></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span></span>;<span class="comment">//该函数返回值类型为in_addr_t=uint32_t=unsigned int类型，参数为字符常量 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp, <span class="keyword">struct</span> in_addr *inp)</span></span>;<span class="comment">//将点分十进制地址转换为网络字节序地址</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>inet_aton () 函数将将点分十进制地址转换为二进制的网络字节序地址，结 ** 果地址保存在结构体类型为 in_addr 的 inp 中，** 该结构体第一个成员为 uint32_t 类型（unsigned int 类型）的 in_addr_t。</p><ul><li>返回值：1 表示转换成功，0 表示失败有错误号 errno</li></ul><p><strong>同时适用于 IP v4 和 IP v6：</strong></p><p></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// **p:点分十进制的IP字符串**，n:表示network，网络字节序的整数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span></span>;</span><br><span class="line">af:地址族： AF_INET AF_INET6</span><br><span class="line">src:需要转换的点分十进制的IP字符串</span><br><span class="line">dst:转换后的结果保存在这个里面  </span><br><span class="line"><span class="comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span></span>;</span><br><span class="line">af:地址族： AF_INET AF_INET6</span><br><span class="line">src: 要转换的ip的整数的地址</span><br><span class="line">dst: 转换成IP地址字符串保存的地方</span><br><span class="line">size：第三个参数的大小（数组的大小）</span><br><span class="line">**返回值：返回转换后的数据的地址（字符串），和 dst 是一样的**</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数</span></span><br><span class="line"><span class="comment">int inet_pton(int af, const char *src, void *dst);</span></span><br><span class="line"><span class="comment">af:地址族： AF_INET  AF_INET6</span></span><br><span class="line"><span class="comment">src:需要转换的点分十进制的IP字符串</span></span><br><span class="line"><span class="comment">dst:转换后的结果保存在这个里面</span></span><br><span class="line"><span class="comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span></span><br><span class="line"><span class="comment">const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</span></span><br><span class="line"><span class="comment">af:地址族： AF_INET  AF_INET6</span></span><br><span class="line"><span class="comment">src: 要转换的ip的整数的地址</span></span><br><span class="line"><span class="comment">dst: 转换成IP地址字符串保存的地方</span></span><br><span class="line"><span class="comment">size：第三个参数的大小（数组的大小）</span></span><br><span class="line"><span class="comment">返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个ip字符串,点分十进制的IP地址字符串</span></span><br><span class="line"><span class="type">char</span> buf[] = <span class="string">&quot;192.168.1.4&quot;</span>;**<span class="comment">//第二个参数类型为字符数组**</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">0</span>;**<span class="comment">//第三个参数的类型为无符号整型的地址---注意传入地址加&amp;**</span></span><br><span class="line"><span class="comment">// 将点分十进制的IP字符串转换成网络字节序的整数</span></span><br><span class="line"><span class="built_in">inet_pton</span>(AF_INET, buf, &amp;num);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> * p = (<span class="type">unsigned</span> <span class="type">char</span> *)&amp;num;</span><br><span class="line"><span class="comment">//把四个字节分别打印出来：每次+1=字节+1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p, *(p+<span class="number">1</span>), *(p+<span class="number">2</span>), *(p+<span class="number">3</span>));</span><br><span class="line"><span class="comment">// 将网络字节序的IP整数转换成点分十进制的IP字符串</span></span><br><span class="line"><span class="type">char</span> ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * str =  <span class="built_in">inet_ntop</span>(AF_INET, &amp;num, ip, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str : %s\n&quot;</span>, str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ip : %s\n&quot;</span>, ip);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ip == str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>解析 unsigned char * p = (unsigned char *)#</p></blockquote><blockquote><p>二.(unsigned char *)&amp;a 运算顺序 1. 先取 a 的地址 2. 将 &amp; a 强制类型转化为 unsigned char * 类型，也就是指向 a 的地址 3. 取出 unsigned char * 指针的值</p></blockquote><hr><h2 id="客户端"><a class="anchor" href="#客户端">#</a> 客户端</h2><h3 id="创建socket"><a class="anchor" href="#创建socket">#</a> 创建 socket</h3><h3 id="连接函数connect"><a class="anchor" href="#连接函数connect">#</a> 连接函数 connect</h3><p>TCP 客户通过 connect 函数来建立与 TCP 服务器的连接：</p><p>int connect (int sockfd, const struct sockaddr *servaddr,socklen_t addrlen); 返回：成功则为 0，若出错则为 - 1</p><blockquote><p>解释： sockfd 是由 socket 数返回的套接字描述符 第 2 个、第 3 个参数分别是一个指向套接字地址结构的指针和该结构的大小</p></blockquote><p>客户在调用函数 onnect 前不必非得调用 bind 函数， 因为如果需要的话，内核会确定源 IP 地址，并选择 个临时端口作为源端口。TCP 套接字调用 connect 函数会激发 TCP 三次握手，仅在连接成功或出错时返回。</p><ul><li>connect 函数建立导致客户端套接字从 CLOSED 状态转为→SYN_SENT 状态</li><li>若 connect 失败则该套接字不再可用，必须关闭，不能对该套接字再次调用 connect 函数</li></ul><h2 id="服务端"><a class="anchor" href="#服务端">#</a> 服务端</h2><h3 id="创建socket可读写控制关闭的文件描述符"><a class="anchor" href="#创建socket可读写控制关闭的文件描述符">#</a> 创建 socket：可读写控制关闭的文件描述符</h3><blockquote><p>int socket( int domain,int type,int protocol)</p></blockquote><ul><li>domain 参数告诉系统使用哪个底层协议簇，TCP/IP 使用 PF_INET（IPV4）</li><li>type 指定服务类型：主要包括 SOCK_STREAM（流服务）和 SOCK_UGRAM（数据报服务）。对 TCP/IP 协议族而言，<strong>SOCK_STREAM*<em>*<em> 表示传输层使用 TCP 协议，*</em>**SOCK_DGRAM**</em>* 表示传输层使用 UDP 协议</strong></li><li>protocol 参数是在前两个参数构成的协议集合下，再选择一个具体的协议，不过这个值通常是唯一的（由前两个参数完全决定），<strong>几乎在所有情况下都设置为 0，表示使用默认协议</strong></li></ul><p>调用成功返回一个<strong> socket 文件描述符（小的非负整数值）=sockfd</strong>，失败返回 - 1 并设置 errno</p><h3 id="命名socket"><a class="anchor" href="#命名socket">#</a> 命名 socket</h3><blockquote><p>创建 socket 时，我们给它指定了地址族，但并未指定具体用哪个地址 给 socket 命名：将一个 socket 与 socket 地址绑定</p></blockquote><p>客户端采用匿名方式 —— 使用操作系统自动分配的 socket 地址：把 一个本地协议地址赋给 一个套接字 系统调用函数：</p><blockquote><p>int bind(int sockfd,const struct sockaddr* my_addr,socklen_t addrlen);</p></blockquote><ul><li>bind 将 my_addr 所指向的 socket 地址分配给未命名的 sockfd 文件描述符，addrlen 参数指出该 socket 地址的长度。</li><li>bind 成功则返回 0，失败返回 - 1 并设置 errno 包括以下两种</li></ul><blockquote><p>EACCES: 被绑定的地址是受保护的地址 EADDRINUSE: 被绑定的地址正在使用中</p></blockquote><hr><p>上述两个函数都需要: include &lt;sys/types.h&gt; include&lt;sys/socket.h&gt;</p><h3 id="监听socket"><a class="anchor" href="#监听socket">#</a> 监听 socket</h3><p>socket 被命名后需要使用系统调用创建一个监听队列来存放待处理的客户连接：</p><blockquote><p>int listen( int sockfd,int backlog);</p></blockquote><blockquote><p>listen 函数仅由 TCP 服务器调用，并做如下两件事：</p></blockquote><ol><li><p>listen 函数创建一个套接字时，他被假设为一个主动套接字。listen 函数把 1 个未连接的套接字转换成 1 个被动套接字，指示内核接受指向套接字的连接请求。</p></li><li><p>第二个参数规定了内核应该为相应套接字排队的最大连接个数。 内核为每个给定的监听套接字维护两个队列：</p><p>（1）未完成连接队列：每个 SYN 分节对应队列中的一项，套接字正处于 SYN_RCVD 状态</p><p>（2）已完成连接队列：每个已完成三次握手的客户对应队列中的一项，套接字处于 ESTABLISHED 状态</p></li></ol><blockquote><p>1. 每当来自客户的 SYN 到达，<strong>TCP 在未完成连接队列中创建一个新项</strong>，然后服务器响应 SYN 第二个分节，并捎带对客户的 SYN 的 ACK。该项一直保留在未完成连接队列中，直到三次握手第三个分节到达或该项超时为止。如果三次握手正常，该项则<strong>从未完成连接队列转移到已完成连接队列的队尾</strong>。 2. 当进程调用 accept 函数时，已完成连接队列中的队头项将返回给进程，如果该队列为空那么进程将被投入睡眠，直到 TCP 在该队列中放入一项才唤醒它</p></blockquote><ul><li>sockfd 参数指定被监听的 socket。</li><li>backlog 参数提示内核<strong>监听队列的最大长度</strong>→监听队列长度如果超过 backlog，服务器将不手里新的客户连接，客户端将收到 ECONNREFUSED 错误信息，以前表示已连接队列 + 半连接队列之和</li><li>listen 成功返回 0，失败返回 - 1 并设置 errno</li></ul><h3 id="接受连接"><a class="anchor" href="#接受连接">#</a> 接受连接</h3><p>accept 函数由 TCP 服务器调用，用于<strong>从已完成连接队列队头返回下一个已完成连接</strong>。<strong>从 listen 监听队列中接受一个连接</strong></p><blockquote><p>int accept(int sockfd,struct sockaddr *addr,socklen_t *addrlen);</p></blockquote><ul><li>sockfd 参数是执行过 listen 系统调用的监听 socket 套接字描述符</li><li>addr 参数获取被接受连接的远端 socket 地址</li><li>远端 socket 地址结构长度由 * addrlen 参数所引用的整数值设置，返回时，该整数值为该套接字地址结构内的确切字节数</li><li>accept 成功时，<strong>那么其返回值是由 内核自动 生成的 1 个套接字全新描述符</strong> = 称为<strong>已连接套接字描述符</strong>，该 socket 唯一地表示了被接受的这个连接。失败则返回 - 1 并设置 errno。如果<strong>已完成连接队列为空，那么进程被投入睡眠</strong></li></ul><p>服务器可以通过该 socket 来与被接受连接对应的客户端通信</p><p>已连接套接字每次在循环中关闭，但监听套接字在服务器的整个有效期内都保持开放</p><p>而现在由于考虑到 syn 攻击，backlog 参数的含义改为了已连接队列之和，去除了半连接队列之和了。</p><p>举一个例子，在 socket 编程当中，如果我们在服务端不用 accept 函数，listen 函数的第二个参数设置为 5，那么这个时候，可以成功连接的客户端就是最多可以成功连入 5 个，每连入一个，队列的项数就会加一 (减一的话就是用 accept 函数去取出来)，所以当项数达到 5 时，客户端自然就会连不上了。</p><blockquote><p>注意本函数最多返回三个值：分别对应函数三个参数</p></blockquote><ul><li>新套接字描述符 / 出错指示整数</li><li>客户进程的协议地址→addr</li><li>客户进程的协议地址大小→addrlen</li></ul><hr><h4 id="socket状态"><a class="anchor" href="#socket状态">#</a> socket 状态</h4><ol><li>调用 socket 函数创建了一个套接字以后，改套接字就对应的和相应的输出缓冲区和输入缓冲区建立了联系，此时改套接字的状态正处于 CLOSED (观察 TCP 状态转换图即可)</li><li>当我们调用 listen 函数以后，改套接字的状态就变成了 LISTEN 监听状态，此时，处于等待客户端连入的状态。</li><li>对于一个调用 listen 进行监听的套接字’操作系统会为其维护 2 个队列：未完成连接队列和已完成连接队列。 （1）未完成连接队列中的连接 当客户端发送 TCP 连接三次握手的第 1 次（即 SYN 包）时，服务器端会在未完成连接队列中创建一个与该 SYN 包对应的项，可以把该项看成一个半连接（因为连接尚未建立）该半连接的状态会从 LISTEN 变成 SYNRCVD 同时向客户端返回第 2 次握手的包。 （SYN’ACK）而此时服务器正在等待完成第 3 次握手 （2）已完成连接队列中的连接 3 次握手完成后该连接就变成 ESTABLISHED 状态，每个已经完成 3 次握手的客户端连接（完整说法应该是 “服务器端的与客户端对应的 socket 连接”）都放在这个队列中作为一项。</li></ol><p>.png)</p><p>从上图可以看到客户端发送的三次握手从第 1 个 SYN 包到 ** <code>在三次握手完成之前</code> <strong>连接都会在未完成连接队列中；直到</strong> <code>在三次握手完成后</code> ** 该连接就从未完成连接队列转移到已完成连接队列</p><p>而 listen 函数” 曾经 “的含义为这两个队列的和不超过 backlog，实际上由于操作系统的原因可能会比这个值稍微多一些。</p><p>.png)</p><hr><h3 id="web服务器端通过socket监听来自用户的请求"><a class="anchor" href="#web服务器端通过socket监听来自用户的请求">#</a> Web 服务器端通过 <code>socket</code> 监听来自用户的请求。</h3><p>源代码如下：</p><p></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;netinet/in.h&gt;  </span><br><span class="line">/* 创建监听socket文件描述符 */  </span><br><span class="line">int listenfd = socket(PF_INET, SOCK_STREAM, 0);  /* 创建监听socket的TCP/IP的IPV4 socket地址 struct sockaddr_in address;  </span><br><span class="line">bzero(&amp;address, sizeof(address));  </span><br><span class="line">address.sin_family = AF_INET;  </span><br><span class="line">address.sin_addr.s_addr = htonl(INADDR_ANY);  /* INADDR_ANY：将套接字绑定到所有可用的接口   </span><br><span class="line">address.sin_port = htons(port);  </span><br><span class="line">int flag = 1;  </span><br><span class="line">/* SO_REUSEADDR 允许端口被重复使用 */  </span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, sizeof(flag));  </span><br><span class="line">/* 绑定socket和它的地址 */  </span><br><span class="line">ret = bind(listenfd, (struct sockaddr*)&amp;address, sizeof(address));   </span><br><span class="line">/* 创建监听队列以存放待处理的客户连接，在这些客户连接被accept()之前 */  </span><br><span class="line">ret = listen(listenfd, 5);</span><br></pre></td></tr></table></figure><p></p><blockquote><h2 id="socket地址api-2"><a class="anchor" href="#socket地址api-2">#</a> socket 地址 API</h2><p>字节序问题：CPU 累加器一次装载 4 个字节，那么 4 个字节在内存中排列的顺序将影响它被累加器装载成的整数的值</p><blockquote><p>主机字节序 &amp; 网络字节序：</p></blockquote><ul><li>大端字节序：一个整数的高位字节存储在内存的低位地址，低位字节（0-7bit）存储在内存高位地址， 称为<strong>网络字节序</strong></li><li>小端字节序相反→现代多采用：称为<strong>主机字节序</strong></li></ul><h3 id="通用socket地址-2"><a class="anchor" href="#通用socket地址-2">#</a> 通用 socket 地址：</h3><p>AF_前缀表示地址族， PF_前缀表示协议族。</p><p>unsigned short int→两个字节</p><p>旧版：</p><p>sa_family_t sa_family;//sa_family_t 地址族类型 char sa_data [14];// 只有 14 个字节</p><p><img data-src="https://secure2.wostatic.cn/static/dfP7RxWzf4y8aiBahHyH12/image.png?auth_key=1666010881-5NyLdPgeb9rE9kwMY2Z14s-0-891086026d7c8c06143c74068d657cf8" alt="img"></p><h3 id="专用socket地址-2"><a class="anchor" href="#专用socket地址-2">#</a> 专用 socket 地址</h3><p>在设置和获取 IP 地址和端口号的上海更方便</p><blockquote><p>TCP 协议族 sockaddr_in 和 sockaddr_in6 两个专用 socket 地址结构体，分别用 IP v4 和 IP v6 所有 socket 编程接口使用的地址参数类型都是<strong> sockaddr</strong>→专用 socket 地址类型的遍历实际使用需要转换为通用 socket 地址类型 sockaddr</p></blockquote><p><img data-src="https://secure2.wostatic.cn/static/djAWWc7hgyd3z2mnr1eDKR/image.png?auth_key=1666010881-pTjjt6Mh9CnSSy3qRy4KtL-0-e1f69507121dc930038b3763e106cf87" alt="img"></p><p>sockaddr_in 每段都划分好了相应成员，最终转换为 sockaddr 指针即可</p><p><img data-src="https://secure2.wostatic.cn/static/44FGUzSnKCjwezuYfJSs81/image.png?auth_key=1666010295-xySFijxdtPd8hVsX8eYmhP-0-dbc78ed3e6fe6b117e175bdabe37da65" alt="img"></p><p></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP/IP 协议族有 sockaddr_in 和 sockaddr_in6 两个专用的 socket 地址结构体，它们分别用于 IPv4 和 IPv6：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>&#123;</span><br><span class="line"><span class="type">sa_family_t</span> sin_family; <span class="comment">/* _*SOCKADDR_COMMON(sin*) */</span></span><br><span class="line"><span class="type">in_port_t</span> sin_port; <span class="comment">/* Port number. */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr; <span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="built_in">sizeof</span> (<span class="keyword">struct</span> sockaddr) - __SOCKADDR_COMMON_SIZE - <span class="built_in">sizeof</span> (<span class="type">in_port_t</span>) - <span class="built_in">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span>&#123;</span><br><span class="line"><span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span>&#123;</span><br><span class="line"><span class="type">sa_family_t</span> sin6_family;</span><br><span class="line"><span class="type">in_port_t</span> sin6_port; <span class="comment">/* Transport layer port # */</span></span><br><span class="line"><span class="type">uint32_t</span> sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr; <span class="comment">/* IPv6 address */</span></span><br><span class="line"><span class="type">uint32_t</span> sin6_scope_id; <span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span></span><br></pre></td></tr></table></figure><p></p><h2 id="ip地址转换-2"><a class="anchor" href="#ip地址转换-2">#</a> IP 地址转换</h2><blockquote><p>字符串 ip - 整数和主机 - 网络字节序的转换</p></blockquote><p>通常，人们习惯用可读性好的<strong>字符串来表示 IP 地址</strong>，比如用点分十进制字符串表示 IPv4 地址，以及用十六进制字符串表示 IPv6 地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用<strong>点分十进制字符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址</strong>之间的转换：</p><p>只适用于 IP v4：</p><p></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span></span>;<span class="comment">//该函数返回值类型为in_addr_t=uint32_t=unsigned int类型，参数为字符常量 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp, <span class="keyword">struct</span> in_addr *inp)</span></span>;<span class="comment">//将点分十进制地址转换为网络字节序地址</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>inet_aton () 函数将将点分十进制地址转换为二进制的网络字节序地址，结 ** 果地址保存在结构体类型为 in_addr 的 inp 中，** 该结构体第一个成员为 uint32_t 类型（unsigned int 类型）的 in_addr_t。</p><ul><li>返回值：1 表示转换成功，0 表示失败有错误号 errno</li></ul><p><strong>同时适用于 IP v4 和 IP v6：</strong></p><p></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// **p:点分十进制的IP字符串**，n:表示network，网络字节序的整数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span></span>;</span><br><span class="line">af:地址族： AF_INET AF_INET6</span><br><span class="line">src:需要转换的点分十进制的IP字符串</span><br><span class="line">dst:转换后的结果保存在这个里面  </span><br><span class="line"><span class="comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span></span>;</span><br><span class="line">af:地址族： AF_INET AF_INET6</span><br><span class="line">src: 要转换的ip的整数的地址</span><br><span class="line">dst: 转换成IP地址字符串保存的地方</span><br><span class="line">size：第三个参数的大小（数组的大小）</span><br><span class="line">**返回值：返回转换后的数据的地址（字符串），和 dst 是一样的**</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数</span></span><br><span class="line"><span class="comment">int inet_pton(int af, const char *src, void *dst);</span></span><br><span class="line"><span class="comment">af:地址族： AF_INET  AF_INET6</span></span><br><span class="line"><span class="comment">src:需要转换的点分十进制的IP字符串</span></span><br><span class="line"><span class="comment">dst:转换后的结果保存在这个里面</span></span><br><span class="line"><span class="comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span></span><br><span class="line"><span class="comment">const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</span></span><br><span class="line"><span class="comment">af:地址族： AF_INET  AF_INET6</span></span><br><span class="line"><span class="comment">src: 要转换的ip的整数的地址</span></span><br><span class="line"><span class="comment">dst: 转换成IP地址字符串保存的地方</span></span><br><span class="line"><span class="comment">size：第三个参数的大小（数组的大小）</span></span><br><span class="line"><span class="comment">返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个ip字符串,点分十进制的IP地址字符串</span></span><br><span class="line"><span class="type">char</span> buf[] = <span class="string">&quot;192.168.1.4&quot;</span>;**<span class="comment">//第二个参数类型为字符数组**</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">0</span>;**<span class="comment">//第三个参数的类型为无符号整型的地址---注意传入地址加&amp;**</span></span><br><span class="line"><span class="comment">// 将点分十进制的IP字符串转换成网络字节序的整数</span></span><br><span class="line"><span class="built_in">inet_pton</span>(AF_INET, buf, &amp;num);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> * p = (<span class="type">unsigned</span> <span class="type">char</span> *)&amp;num;</span><br><span class="line"><span class="comment">//把四个字节分别打印出来：每次+1=字节+1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p, *(p+<span class="number">1</span>), *(p+<span class="number">2</span>), *(p+<span class="number">3</span>));</span><br><span class="line"><span class="comment">// 将网络字节序的IP整数转换成点分十进制的IP字符串</span></span><br><span class="line"><span class="type">char</span> ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * str =  <span class="built_in">inet_ntop</span>(AF_INET, &amp;num, ip, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str : %s\n&quot;</span>, str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ip : %s\n&quot;</span>, ip);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ip == str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>解析 unsigned char * p = (unsigned char *)#</p></blockquote><blockquote><p>二.(unsigned char *)&amp;a 运算顺序 1. 先取 a 的地址 2. 将 &amp; a 强制类型转化为 unsigned char * 类型，也就是指向 a 的地址 3. 取出 unsigned char * 指针的值</p></blockquote><hr><h2 id="客户端-2"><a class="anchor" href="#客户端-2">#</a> 客户端</h2><h3 id="创建socket-2"><a class="anchor" href="#创建socket-2">#</a> 创建 socket</h3><h3 id="连接函数connect-2"><a class="anchor" href="#连接函数connect-2">#</a> 连接函数 connect</h3><p>TCP 客户通过 connect 函数来建立与 TCP 服务器的连接：</p><p>int connect (int sockfd, const struct sockaddr *servaddr,socklen_t addrlen); 返回：成功则为 0，若出错则为 - 1</p><blockquote><p>解释： sockfd 是由 socket 数返回的套接字描述符 第 2 个、第 3 个参数分别是一个指向套接字地址结构的指针和该结构的大小</p></blockquote><p>客户在调用函数 onnect 前不必非得调用 bind 函数， 因为如果需要的话，内核会确定源 IP 地址，并选择 个临时端口作为源端口。TCP 套接字调用 connect 函数会激发 TCP 三次握手，仅在连接成功或出错时返回。</p><ul><li>connect 函数建立导致客户端套接字从 CLOSED 状态转为→SYN_SENT 状态</li><li>若 connect 失败则该套接字不再可用，必须关闭，不能对该套接字再次调用 connect 函数</li></ul><h2 id="服务端-2"><a class="anchor" href="#服务端-2">#</a> 服务端</h2><h3 id="创建socket可读写控制关闭的文件描述符-2"><a class="anchor" href="#创建socket可读写控制关闭的文件描述符-2">#</a> 创建 socket：可读写控制关闭的文件描述符</h3><blockquote><p>int socket( int domain,int type,int protocol)</p></blockquote><ul><li>domain 参数告诉系统使用哪个底层协议簇，TCP/IP 使用 PF_INET（IPV4）</li><li>type 指定服务类型：主要包括 SOCK_STREAM（流服务）和 SOCK_UGRAM（数据报服务）。对 TCP/IP 协议族而言，<strong>SOCK_STREAM*<em>*<em> 表示传输层使用 TCP 协议，*</em>**SOCK_DGRAM**</em>* 表示传输层使用 UDP 协议</strong></li><li>protocol 参数是在前两个参数构成的协议集合下，再选择一个具体的协议，不过这个值通常是唯一的（由前两个参数完全决定），<strong>几乎在所有情况下都设置为 0，表示使用默认协议</strong></li></ul><p>调用成功返回一个<strong> socket 文件描述符（小的非负整数值）=sockfd</strong>，失败返回 - 1 并设置 errno</p><h3 id="命名socket-2"><a class="anchor" href="#命名socket-2">#</a> 命名 socket</h3><blockquote><p>创建 socket 时，我们给它指定了地址族，但并未指定具体用哪个地址 给 socket 命名：将一个 socket 与 socket 地址绑定</p></blockquote><p>客户端采用匿名方式 —— 使用操作系统自动分配的 socket 地址：把 一个本地协议地址赋给 一个套接字 系统调用函数：</p><blockquote><p>int bind(int sockfd,const struct sockaddr* my_addr,socklen_t addrlen);</p></blockquote><ul><li>bind 将 my_addr 所指向的 socket 地址分配给未命名的 sockfd 文件描述符，addrlen 参数指出该 socket 地址的长度。</li><li>bind 成功则返回 0，失败返回 - 1 并设置 errno 包括以下两种</li></ul><blockquote><p>EACCES: 被绑定的地址是受保护的地址 EADDRINUSE: 被绑定的地址正在使用中</p></blockquote><hr><p>上述两个函数都需要: include &lt;sys/types.h&gt; include&lt;sys/socket.h&gt;</p><h3 id="监听socket-2"><a class="anchor" href="#监听socket-2">#</a> 监听 socket</h3><p>socket 被命名后需要使用系统调用创建一个监听队列来存放待处理的客户连接：</p><blockquote><p>int listen( int sockfd,int backlog);</p></blockquote><blockquote><p>listen 函数仅由 TCP 服务器调用，并做如下两件事：</p></blockquote><ol><li><p>listen 函数创建一个套接字时，他被假设为一个主动套接字。listen 函数把 1 个未连接的套接字转换成 1 个被动套接字，指示内核接受指向套接字的连接请求。</p></li><li><p>第二个参数规定了内核应该为相应套接字排队的最大连接个数。 内核为每个给定的监听套接字维护两个队列：</p><p>（1）未完成连接队列：每个 SYN 分节对应队列中的一项，套接字正处于 SYN_RCVD 状态</p><p>（2）已完成连接队列：每个已完成三次握手的客户对应队列中的一项，套接字处于 ESTABLISHED 状态</p></li></ol><blockquote><p>1. 每当来自客户的 SYN 到达，<strong>TCP 在未完成连接队列中创建一个新项</strong>，然后服务器响应 SYN 第二个分节，并捎带对客户的 SYN 的 ACK。该项一直保留在未完成连接队列中，直到三次握手第三个分节到达或该项超时为止。如果三次握手正常，该项则<strong>从未完成连接队列转移到已完成连接队列的队尾</strong>。 2. 当进程调用 accept 函数时，已完成连接队列中的队头项将返回给进程，如果该队列为空那么进程将被投入睡眠，直到 TCP 在该队列中放入一项才唤醒它</p></blockquote><ul><li>sockfd 参数指定被监听的 socket。</li><li>backlog 参数提示内核<strong>监听队列的最大长度</strong>→监听队列长度如果超过 backlog，服务器将不手里新的客户连接，客户端将收到 ECONNREFUSED 错误信息，以前表示已连接队列 + 半连接队列之和</li><li>listen 成功返回 0，失败返回 - 1 并设置 errno</li></ul><h3 id="接受连接-2"><a class="anchor" href="#接受连接-2">#</a> 接受连接</h3><p>accept 函数由 TCP 服务器调用，用于<strong>从已完成连接队列队头返回下一个已完成连接</strong>。<strong>从 listen 监听队列中接受一个连接</strong></p><blockquote><p>int accept(int sockfd,struct sockaddr *addr,socklen_t *addrlen);</p></blockquote><ul><li>sockfd 参数是执行过 listen 系统调用的监听 socket 套接字描述符</li><li>addr 参数获取被接受连接的远端 socket 地址</li><li>远端 socket 地址结构长度由 * addrlen 参数所引用的整数值设置，返回时，该整数值为该套接字地址结构内的确切字节数</li><li>accept 成功时，<strong>那么其返回值是由 内核自动 生成的 1 个套接字全新描述符</strong> = 称为<strong>已连接套接字描述符</strong>，该 socket 唯一地表示了被接受的这个连接。失败则返回 - 1 并设置 errno。如果<strong>已完成连接队列为空，那么进程被投入睡眠</strong></li></ul><p>服务器可以通过该 socket 来与被接受连接对应的客户端通信</p><p>已连接套接字每次在循环中关闭，但监听套接字在服务器的整个有效期内都保持开放</p><p>而现在由于考虑到 syn 攻击，backlog 参数的含义改为了已连接队列之和，去除了半连接队列之和了。</p><p>举一个例子，在 socket 编程当中，如果我们在服务端不用 accept 函数，listen 函数的第二个参数设置为 5，那么这个时候，可以成功连接的客户端就是最多可以成功连入 5 个，每连入一个，队列的项数就会加一 (减一的话就是用 accept 函数去取出来)，所以当项数达到 5 时，客户端自然就会连不上了。</p><blockquote><p>注意本函数最多返回三个值：分别对应函数三个参数</p></blockquote><ul><li>新套接字描述符 / 出错指示整数</li><li>客户进程的协议地址→addr</li><li>客户进程的协议地址大小→addrlen</li></ul><hr><h4 id="socket状态-2"><a class="anchor" href="#socket状态-2">#</a> socket 状态</h4><ol><li>调用 socket 函数创建了一个套接字以后，改套接字就对应的和相应的输出缓冲区和输入缓冲区建立了联系，此时改套接字的状态正处于 CLOSED (观察 TCP 状态转换图即可)</li><li>当我们调用 listen 函数以后，改套接字的状态就变成了 LISTEN 监听状态，此时，处于等待客户端连入的状态。</li><li>对于一个调用 listen 进行监听的套接字’操作系统会为其维护 2 个队列：未完成连接队列和已完成连接队列。 （1）未完成连接队列中的连接 当客户端发送 TCP 连接三次握手的第 1 次（即 SYN 包）时，服务器端会在未完成连接队列中创建一个与该 SYN 包对应的项，可以把该项看成一个半连接（因为连接尚未建立）该半连接的状态会从 LISTEN 变成 SYNRCVD 同时向客户端返回第 2 次握手的包。 （SYN’ACK）而此时服务器正在等待完成第 3 次握手 （2）已完成连接队列中的连接 3 次握手完成后该连接就变成 ESTABLISHED 状态，每个已经完成 3 次握手的客户端连接（完整说法应该是 “服务器端的与客户端对应的 socket 连接”）都放在这个队列中作为一项。</li></ol><p><img data-src="https://secure2.wostatic.cn/static/vANfFTAXHhHvVDuagV2asC/image.png?auth_key=1666010295-j9CJUp62MYQtLR66bvB2sX-0-0b4a0c62fa3e70425cc25f1bef39075f" alt="img"></p><p>从上图可以看到客户端发送的三次握手从第 1 个 SYN 包到 ** <code>在三次握手完成之前</code> <strong>连接都会在未完成连接队列中；直到</strong> <code>在三次握手完成后</code> ** 该连接就从未完成连接队列转移到已完成连接队列</p><p>而 listen 函数” 曾经 “的含义为这两个队列的和不超过 backlog，实际上由于操作系统的原因可能会比这个值稍微多一些。</p><p><img data-src="https://secure2.wostatic.cn/static/iWdAkGDbYNKunBwu4tCBtK/image.png?auth_key=1666010295-7vaEh1tqwyg6EqczVCfUwN-0-33d62467e9259f4777479767653b2518" alt="img"></p><hr><h3 id="web服务器端通过socket监听来自用户的请求-2"><a class="anchor" href="#web服务器端通过socket监听来自用户的请求-2">#</a> Web 服务器端通过 <code>socket</code> 监听来自用户的请求。</h3><p>源代码如下：</p><p></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;netinet/in.h&gt;  </span><br><span class="line">/* 创建监听socket文件描述符 */  </span><br><span class="line">int listenfd = socket(PF_INET, SOCK_STREAM, 0);  /* 创建监听socket的TCP/IP的IPV4 socket地址 struct sockaddr_in address;  </span><br><span class="line">bzero(&amp;address, sizeof(address));  </span><br><span class="line">address.sin_family = AF_INET;  </span><br><span class="line">address.sin_addr.s_addr = htonl(INADDR_ANY);  /* INADDR_ANY：将套接字绑定到所有可用的接口   </span><br><span class="line">address.sin_port = htons(port);  </span><br><span class="line">int flag = 1;  </span><br><span class="line">/* SO_REUSEADDR 允许端口被重复使用 */  </span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, sizeof(flag));  </span><br><span class="line">/* 绑定socket和它的地址 */  </span><br><span class="line">ret = bind(listenfd, (struct sockaddr*)&amp;address, sizeof(address));   </span><br><span class="line">/* 创建监听队列以存放待处理的客户连接，在这些客户连接被accept()之前 */  </span><br><span class="line">ret = listen(listenfd, 5);</span><br></pre></td></tr></table></figure><p></p><h4 id="代码分析"><a class="anchor" href="#代码分析">#</a> 代码分析：</h4><blockquote><p>创建监听 socket 的 TCP/IP 的 IPV4 socket 地址</p></blockquote><ul><li>struct sockaddr_in address;</li></ul><blockquote><p>bzero 函数是 c++ string.h 中的函数 *。* 功能描述：置字节字符串前 n 个字节为零且包括‘\0’。 原型:extern void bzero (void *s, int n); 参数说明:s 要置零的数据的起始地址；n 要置零的数据字节个数。 用法:#include &lt;string.h&gt; 功能:<strong> 置字节字符串 s 的前 n 个字节为零且包括‘\0’</strong>。 说明:bzero 无返回值</p></blockquote><ul><li>bzero(&amp;address, sizeof(address));</li></ul><blockquote><p>创建套接字时，用该字段指定地址家族，对于 TCP/IP 协议的，必须设置为 AF_INET。变量 address 是一个结构体，其中成员变量 sin_family 是<strong>地址族类型变量</strong></p></blockquote><ul><li>address.sin_family = AF_INET;</li></ul><ol><li>sin_addr 是套接字中的 IP 地址，sin_addr 的类型是联合，因此可以通过三种不同的方式访问它：作为 s_un_b（四个 1 字节整数）、s_un_w（两个 2 字节整数）或作为 s_addr（一个 4 字节整数）。INADDR_ANY：将套接字绑定到所有可用的接口</li><li><strong>网络编程_常用的基本函数介绍</strong> ——htonl、ntohl、htons、ntohs htonl 函数：将主机的 unsigned long 值转换成网络字节顺序（32 位）（一般主机跟网络上传输的字节顺序是不通的，分大小端），函数返回一个网络字节顺序的数字。 ntohl 函数：将网络字节顺序（32 位）转为主机字节</li></ol><ul><li>address.sin_addr.s_addr = htonl(INADDR_ANY);</li></ul><blockquote><p>htons 是将整型变量从主机字节顺序转变成网络字节顺序， 就是整数在地址空间存储方式变为高位字节存放在内存的低地址处。</p></blockquote><ul><li>address.sin_port = htons(port);</li></ul><blockquote><p>SO_REUSEADDR 允许端口被重复使用</p></blockquote><ul><li>setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, sizeof(flag));</li></ul><p>setsockopt 函数解析：</p><p>SO_REUSEADDR 参数，打开或关闭地址复用功能。当 option_value 不等于 0 时，打开，否则，关闭。它实际所做的工作是置 sock-&gt;sk-&gt;sk_reuse 为 1 或 0。</p><p></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int setsockopt(int sockfd, int level, int optname,</span><br><span class="line">const void *optval, socklen_t optlen);</span><br><span class="line">参数说明：</span><br><span class="line">(1) int sockfd: 很简单，套接字描述符</span><br><span class="line">(2) int level: 选项定义的层次；目前仅支持SOL_SOCKET和IPPROTO_TCP层次，若要在套接字级别上设置选项，就必须把level设置为 SOL_SOCKET</span><br><span class="line">(3) int optname: 指定准备设置的选项，option_name可以有哪些取值，这取决于level</span><br><span class="line">(4) const void *optval: 指针，指向存放选项值的缓冲区</span><br><span class="line">(5) socklen_t optlen: optval缓冲区的长度</span><br></pre></td></tr></table></figure><p></p><blockquote><p>绑定 socket 和它的地址</p></blockquote><ul><li>ret = bind(listenfd, (struct sockaddr*)&amp;address, sizeof(address));</li></ul><blockquote><p>创建监听队列以存放待处理的客户连接，在这些客户连接被 accept () 之前</p></blockquote><ul><li>ret = listen(listenfd, 5);</li></ul><hr><blockquote><p>assert (ret≠-1) 函数的作用是现计算表达式 expression ，如果其值为假（即为 0），那么它先向 stderr 打印一条出错信息，然后通过调用 abort 来终止程序运行。</p></blockquote><p>书本 95 页服务器程序：</p><blockquote><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char* ip=argv[1]; int port =atoi(argv[2]); int backlog =atoi(argv[3]); int inet_pton(int AF_INET, ip ,&amp;address.sin_addr);</span><br></pre></td></tr></table></figure><p></p></blockquote><p>需要以下包： include &lt;sys/types.h&gt;<br>include &lt;sys/socket.h&gt;<br>include &lt;arpa/inet.h&gt;</p><p>解释：接收 IP 地址、端口还、backlog 值。调用 <code>inet_pton</code> 函数：可以在将 IP 地址在 “点分十进制” 和 “整数” 之间转换</p><blockquote><p>int inet_pton(int af, const char *src, void <em>dst);<br>这个函数转换字符串到网络地址，第一个参数 af 是地址族，转换后存在 dst 中<br>inet_pton 是 inet_addr 的扩展，支持的多地址族有下列：<br>af = AF_INET<br>src 为指向字符型的地址，即 ASCII 的地址的首地址（ddd.ddd.ddd.ddd 格式的），函数将该地址<br>转换为<strong> in_addr</strong> 的结构体，并复制在</em> dst 中</p></blockquote><blockquote><p>af =AF_INET6<br>src 为指向 IPV6 的地址，函数将该地址转换为<strong> in6_addr</strong> 的结构体，并复制在 * dst 中如果函数出错将返回一个负值，并将 errno 设置为 EAFNOSUPPORT，如果参数 af 指定的地址族和 src 格式不对，函数将返回 0。</p></blockquote></blockquote><div class="tags"><a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C++</a> <a href="/tags/webserver/" rel="tag"><i class="ic i-tag"></i> webserver</a> <a href="/tags/socket%E7%AF%87/" rel="tag"><i class="ic i-tag"></i> socket篇</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" rel="tag"><i class="ic i-tag"></i> 项目</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-10-18 10:51:05" itemprop="dateModified" datetime="2022-10-18T10:51:05+08:00">2022-10-18</time> </span><span id="2022/10/15/cpp/Linux高性能服务器编程-socket篇/" class="item leancloud_visitors" data-flag-title="Linux高性能服务器编程/socket篇" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/alipay.jpg" alt="Sean Barrett 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Sean Barrett <i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong> <a href="https://aristotlednzk.github.io.com/2022/10/15/cpp/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-socket%E7%AF%87/" title="Linux高性能服务器编程&#x2F;socket篇">https://aristotlednzk.github.io.com/2022/10/15/cpp/Linux高性能服务器编程-socket篇/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/10/15/bug/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;gss0.baidu.com&#x2F;70cFfyinKgQFm2e88IuM_a&#x2F;baike&#x2F;pic&#x2F;item&#x2F;71cf3bc79f3df8dca48ff64dcc11728b461028bf.jpg" title="bug"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> bug</span><h3>bug</h3></a></div><div class="item right"><a href="/2022/10/18/%E8%A8%80/%E5%8F%B0%E9%A3%8E%E4%B8%8E%E7%A7%8B/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclj9410cj20zk0m8h12.jpg" title="台风与秋"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 言</span><h3>台风与秋</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#socket%E5%9C%B0%E5%9D%80api"><span class="toc-number">1.</span> <span class="toc-text">socket 地址 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8socket%E5%9C%B0%E5%9D%80"><span class="toc-number">1.1.</span> <span class="toc-text">通用 socket 地址：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%93%E7%94%A8socket%E5%9C%B0%E5%9D%80"><span class="toc-number">1.2.</span> <span class="toc-text">专用 socket 地址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ip%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.</span> <span class="toc-text">IP 地址转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">3.</span> <span class="toc-text">客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAsocket"><span class="toc-number">3.1.</span> <span class="toc-text">创建 socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%87%BD%E6%95%B0connect"><span class="toc-number">3.2.</span> <span class="toc-text">连接函数 connect</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">4.</span> <span class="toc-text">服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAsocket%E5%8F%AF%E8%AF%BB%E5%86%99%E6%8E%A7%E5%88%B6%E5%85%B3%E9%97%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">4.1.</span> <span class="toc-text">创建 socket：可读写控制关闭的文件描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8Dsocket"><span class="toc-number">4.2.</span> <span class="toc-text">命名 socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%ACsocket"><span class="toc-number">4.3.</span> <span class="toc-text">监听 socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%97%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.4.</span> <span class="toc-text">接受连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#socket%E7%8A%B6%E6%80%81"><span class="toc-number">4.4.1.</span> <span class="toc-text">socket 状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E9%80%9A%E8%BF%87socket%E7%9B%91%E5%90%AC%E6%9D%A5%E8%87%AA%E7%94%A8%E6%88%B7%E7%9A%84%E8%AF%B7%E6%B1%82"><span class="toc-number">4.5.</span> <span class="toc-text">Web 服务器端通过 socket 监听来自用户的请求。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socket%E5%9C%B0%E5%9D%80api-2"><span class="toc-number">5.</span> <span class="toc-text">socket 地址 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8socket%E5%9C%B0%E5%9D%80-2"><span class="toc-number">5.1.</span> <span class="toc-text">通用 socket 地址：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%93%E7%94%A8socket%E5%9C%B0%E5%9D%80-2"><span class="toc-number">5.2.</span> <span class="toc-text">专用 socket 地址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ip%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-2"><span class="toc-number">6.</span> <span class="toc-text">IP 地址转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-2"><span class="toc-number">7.</span> <span class="toc-text">客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAsocket-2"><span class="toc-number">7.1.</span> <span class="toc-text">创建 socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%87%BD%E6%95%B0connect-2"><span class="toc-number">7.2.</span> <span class="toc-text">连接函数 connect</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF-2"><span class="toc-number">8.</span> <span class="toc-text">服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAsocket%E5%8F%AF%E8%AF%BB%E5%86%99%E6%8E%A7%E5%88%B6%E5%85%B3%E9%97%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-2"><span class="toc-number">8.1.</span> <span class="toc-text">创建 socket：可读写控制关闭的文件描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8Dsocket-2"><span class="toc-number">8.2.</span> <span class="toc-text">命名 socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%ACsocket-2"><span class="toc-number">8.3.</span> <span class="toc-text">监听 socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%97%E8%BF%9E%E6%8E%A5-2"><span class="toc-number">8.4.</span> <span class="toc-text">接受连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#socket%E7%8A%B6%E6%80%81-2"><span class="toc-number">8.4.1.</span> <span class="toc-text">socket 状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E9%80%9A%E8%BF%87socket%E7%9B%91%E5%90%AC%E6%9D%A5%E8%87%AA%E7%94%A8%E6%88%B7%E7%9A%84%E8%AF%B7%E6%B1%82-2"><span class="toc-number">8.5.</span> <span class="toc-text">Web 服务器端通过 socket 监听来自用户的请求。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">8.5.1.</span> <span class="toc-text">代码分析：</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2022/10/15/cpp/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-socket%E7%AF%87/" rel="bookmark" title="Linux高性能服务器编程/socket篇">Linux高性能服务器编程/socket篇</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sean Barrett" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sean Barrett</p><div class="description" itemprop="description">思及我域</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">12</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">12</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FyaXN0b3RsZUROWks=" title="https:&#x2F;&#x2F;github.com&#x2F;AristotleDNZK"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTk0NTI2OTQy" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;94526942"><i class="ic i-cloud-music"></i></span> <a href="/jiang1302833@163.com" title="jiang1302833@163.com" class="item email"><i class="ic i-envelope"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-clipboard"></i>书架</a><ul class="submenu"><li class="item"><a href="/books/deeplearning-books/" rel="section"><i class="ic i-fedora"></i>人工智能</a></li><li class="item"><a href="/books/philosophy-books/" rel="section"><i class="ic i-fedora"></i>哲学</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>链环</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/10/15/bug/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/10/18/%E8%A8%80/%E5%8F%B0%E9%A3%8E%E4%B8%8E%E7%A7%8B/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 转码之路">转码之路</a></div><span><a href="/2022/10/11/computer-science/%E8%BD%AC%E7%A0%81%E4%B9%8B%E8%B7%AF/" title="转码之路">转码之路</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/philosophy/" title="分类于 哲学社科">哲学社科</a> <i class="ic i-angle-right"></i> <a href="/categories/philosophy/%E4%B8%AD%E5%93%B2/" title="分类于 中哲">中哲</a></div><span><a href="/2022/10/11/philosophy/%E7%8E%8B%E9%98%B3%E6%98%8E%E5%BF%83%E5%AD%A6/" title="王阳明心学">王阳明心学</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%A8%80/" title="分类于 言">言</a></div><span><a href="/2022/10/12/%E8%BF%9C%E8%A1%8C%E8%80%85%E5%BC%80%E7%AF%87/%E8%BF%9C%E8%A1%8C%E8%80%85%E5%BC%80%E7%AF%87/" title="远行者开篇">远行者开篇</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/bug/" title="分类于 bug">bug</a></div><span><a href="/2022/10/15/bug/" title="bug">bug</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/GAN%E8%AF%BE%E9%A2%98/" title="分类于 GAN课题">GAN课题</a> <i class="ic i-angle-right"></i> <a href="/categories/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/" title="分类于 生成对抗网络">生成对抗网络</a></div><span><a href="/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/" title="生成对抗网络">生成对抗网络</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/philosophy/" title="分类于 哲学社科">哲学社科</a> <i class="ic i-angle-right"></i> <a href="/categories/philosophy/%E8%A5%BF%E5%93%B2/" title="分类于 西哲">西哲</a></div><span><a href="/2022/10/12/philosophy/%E7%8E%B0%E8%B1%A1%E5%AD%A6-%E8%83%A1%E5%A1%9E%E5%B0%94/%E7%8E%B0%E8%B1%A1%E5%AD%A6-%E8%83%A1%E5%A1%9E%E5%B0%94/" title="现象学&#x2F;胡塞尔">现象学/胡塞尔</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/cpp/" title="分类于 C++">C++</a> <i class="ic i-angle-right"></i> <a href="/categories/cpp/%E9%A1%B9%E7%9B%AE/" title="分类于 项目">项目</a> <i class="ic i-angle-right"></i> <a href="/categories/cpp/%E9%A1%B9%E7%9B%AE/webserver/" title="分类于 webserver">webserver</a> <i class="ic i-angle-right"></i> <a href="/categories/cpp/%E9%A1%B9%E7%9B%AE/webserver/socket%E7%AF%87/" title="分类于 socket篇">socket篇</a></div><span><a href="/2022/10/15/cpp/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-socket%E7%AF%87/" title="Linux高性能服务器编程&#x2F;socket篇">Linux高性能服务器编程/socket篇</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%A8%80/" title="分类于 言">言</a></div><span><a href="/2022/10/18/%E8%A8%80/%E5%8F%B0%E9%A3%8E%E4%B8%8E%E7%A7%8B/" title="台风与秋">台风与秋</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/philosophy/" title="分类于 哲学社科">哲学社科</a> <i class="ic i-angle-right"></i> <a href="/categories/philosophy/%E8%A5%BF%E5%93%B2/" title="分类于 西哲">西哲</a></div><span><a href="/2022/10/19/philosophy/%E4%BA%BA%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%9A%84%E9%BB%98%E4%BC%9A%E7%BB%B4%E5%BA%A6/" title="人类知识的默会维度">人类知识的默会维度</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E9%97%BB%E8%AF%B4/" title="分类于 阅读笔记">阅读笔记</a></div><span><a href="/2022/10/11/%E9%97%BB%E8%AF%B4/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/" title="亲密关系">亲密关系</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sean Barrett @ Sean Barrett</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">24k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">22 分钟</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/10/15/cpp/Linux高性能服务器编程-socket篇/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>