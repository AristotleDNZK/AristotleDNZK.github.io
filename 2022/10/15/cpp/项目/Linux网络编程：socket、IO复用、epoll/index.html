<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" href="https://aristotlednzk.github.io.com/rss.xml"><link rel="alternate" type="application/atom+xml" href="https://aristotlednzk.github.io.com/atom.xml"><link rel="alternate" type="application/json" href="https://aristotlednzk.github.io.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="C++,webserver,Linux网络编程：socket、IO复用、epoll"><link rel="canonical" href="https://aristotlednzk.github.io.com/2022/10/15/cpp/%E9%A1%B9%E7%9B%AE/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9Asocket%E3%80%81IO%E5%A4%8D%E7%94%A8%E3%80%81epoll/"><title>Linux网络编程：socket、IO复用、epoll - Linux高性能服务器编程 - C++ | Sean Barrett = = 远行者回忆录——人类往事</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Linux网络编程：socket、IO复用、epoll</h1><div class="meta"><span class="item" title="创建时间：2022-10-15 17:10:54"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-10-15T17:10:54+08:00">2022-10-15</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>20k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>18 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Sean Barrett</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclfb3vzhj20zk0m8wny.jpg"></li><li class="item" data-background-image="https://i03piccdn.sogoucdn.com/c1531034cfbb4ab0"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipew8gmvyj20zk0m87wh.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giciuja1j1j20zk0m8kjl.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicliwyw55j20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclx29mstj20zk0m8hdt.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/cpp/" itemprop="item" rel="index" title="分类于 C++"><span itemprop="name">C++</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/cpp/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/" itemprop="item" rel="index" title="分类于 Linux高性能服务器编程"><span itemprop="name">Linux高性能服务器编程</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://aristotlednzk.github.io.com/2022/10/15/cpp/%E9%A1%B9%E7%9B%AE/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9Asocket%E3%80%81IO%E5%A4%8D%E7%94%A8%E3%80%81epoll/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sean Barrett"><meta itemprop="description" content="远行者回忆录——人类往事, 思及我域"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><h3 id="前置知识"><a class="anchor" href="#前置知识">#</a> 前置知识：</h3><p>Linux 系统 API 特点：如果调用失败一般返回 - 1</p><p><strong>errno</strong>：属于 Linux 系统函数库，库里面的一个全局变量，记录的是最近的错误号</p><blockquote><p>perror (const char *s): 用于打印 errno 对应的错误描述 所需头文件 stdio.h</p></blockquote><blockquote><p>close (): 关闭一个文件描述符，文件描述符可以重用 所需头文件 unistd.h</p></blockquote><ul><li>int open(const char *pathname,int flags);</li></ul><blockquote><p>功能：用于打开一个已经存在的文件 第一个参数：要打开的文件路径 第二个参数：权限 (三者互斥)：O_RDONLY 只读 O_WRONLY 只写 O_RDWR 可读可写 返回值：成功则返回新的文件描述符，如果产生错误则返回 - 1，设置 errno 包含三个头文件：sys/types.h sys/stat.h fcntl.h</p></blockquote><ul><li>int open(const char *pathname,int flags，mode);</li></ul><h2 id="socket地址api"><a class="anchor" href="#socket地址api">#</a> socket 地址 API</h2><p>字节序问题：CPU 累加器一次装载 4 个字节，那么 4 个字节在内存中排列的顺序将影响它被累加器装载成的整数的值</p><blockquote><p>主机字节序 &amp; 网络字节序：</p></blockquote><ul><li>大端字节序：<strong>一个整数的高位字节存储在内存的低位地址</strong>，低位字节（0-7bit）存储在内存高位地址， 称为<strong>网络字节序</strong></li><li>小端字节序相反→现代多采用：称为<strong>主机字节序</strong></li></ul><h3 id="通用socket地址"><a class="anchor" href="#通用socket地址">#</a> 通用 socket 地址：</h3><p>AF_前缀表示地址族， PF_前缀表示协议族。</p><p>unsigned short int→两个字节</p><p>旧版：</p><p>sa_family_t sa_family;//sa_family_t 地址族类型 char sa_data [14];// 只有 14 个字节</p><p><img data-src="/2022/10/15/cpp/%E9%A1%B9%E7%9B%AE/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9Asocket%E3%80%81IO%E5%A4%8D%E7%94%A8%E3%80%81epoll/image.png" title="image"></p><h3 id="专用socket地址"><a class="anchor" href="#专用socket地址">#</a> 专用 socket 地址</h3><p>在设置和获取 IP 地址和端口号的上海更方便</p><blockquote><p>TCP 协议族 sockaddr_in 和 sockaddr_in6 两个专用 socket 地址结构体，分别用 IP v4 和 IP v6 所有 socket 编程接口使用的地址参数类型都是<strong> sockaddr</strong>→专用 socket 地址类型的遍历实际使用需要转换为通用 socket 地址类型 sockaddr</p></blockquote><p><img data-src="/2022/10/15/cpp/%E9%A1%B9%E7%9B%AE/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9Asocket%E3%80%81IO%E5%A4%8D%E7%94%A8%E3%80%81epoll/2.png" width="2"></p><p>sockaddr_in 每段都划分好了相应成员，最终转换为 sockaddr 指针即可</p><p>.png)</p><pre><code class="language-C++">// TCP/IP 协议族有 sockaddr_in 和 sockaddr_in6 两个专用的 socket 地址结构体，它们分别用于 IPv4 和 IPv6：
#include &lt;netinet/in.h&gt;
struct sockaddr_in&#123;
sa_family_t sin_family; /* _*SOCKADDR_COMMON(sin*) */
in_port_t sin_port; /* Port number. */
struct in_addr sin_addr; /* Internet address. */
/* Pad to size of `struct sockaddr'. */
unsigned char sin_zero[sizeof (struct sockaddr) - __SOCKADDR_COMMON_SIZE - sizeof (in_port_t) - sizeof (struct in_addr)];
&#125;;
struct in_addr&#123;
in_addr_t s_addr;
&#125;;
struct sockaddr_in6&#123;
sa_family_t sin6_family;
in_port_t sin6_port; /* Transport layer port # */
uint32_t sin6_flowinfo; /* IPv6 flow information */
struct in6_addr sin6_addr; /* IPv6 address */
uint32_t sin6_scope_id; /* IPv6 scope-id */
&#125;;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef uint16_t in_port_t;
typedef uint32_t in_addr_t;
#define __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))
</code></pre><h2 id="ip地址转换"><a class="anchor" href="#ip地址转换">#</a> IP 地址转换</h2><blockquote><p>字符串 ip - 整数和主机 - 网络字节序的转换</p></blockquote><p>通常，人们习惯用可读性好的<strong>字符串来表示 IP 地址</strong>，比如用点分十进制字符串表示 IPv4 地址，以及用十六进制字符串表示 IPv6 地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用<strong>点分十进制字符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址</strong>之间的转换：</p><p>只适用于 IP v4：</p><pre><code class="language-C++">#include &lt;arpa/inet.h&gt;
in_addr_t inet_addr(const char *cp);//该函数返回值类型为in_addr_t=uint32_t=unsigned int类型，参数为字符常量 
int inet_aton(const char *cp, struct in_addr *inp);//将点分十进制地址转换为网络字节序地址
char *inet_ntoa(struct in_addr in);
</code></pre><blockquote><p>inet_addr（）将一个<strong>点分十进制的 IP 字符串</strong>转换成一个网络字节序的长整数型数 (u_long 类型) inet_aton () 函数将将点分十进制地址转换为二进制的网络字节序地址，结 ** 果地址保存在结构体类型为 in_addr 的 inp 中，** 该结构体第一个成员为 uint32_t 类型（unsigned int 类型）的 in_addr_t。</p></blockquote><ul><li>返回值：1 表示转换成功，0 表示失败有错误号 errno</li></ul><p><strong>同时适用于 IP v4 和 IP v6：</strong></p><pre><code class="language-C++">#include &lt;arpa/inet.h&gt;
// **p:点分十进制的IP字符串**，n:表示network，网络字节序的整数
int inet_pton(int af, const char *src, void *dst);
af:地址族： AF_INET AF_INET6
src:需要转换的点分十进制的IP字符串
dst:转换后的结果保存在这个里面  
// 将网络字节序的整数，转换成点分十进制的IP地址字符串
const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);
af:地址族： AF_INET AF_INET6
src: 要转换的ip的整数的地址
dst: 转换成IP地址字符串保存的地方
size：第三个参数的大小（数组的大小）
**返回值：返回转换后的数据的地址（字符串），和 dst 是一样的**
/*
#include &lt;arpa/inet.h&gt;
// p:点分十进制的IP字符串，n:表示network，网络字节序的整数
int inet_pton(int af, const char *src, void *dst);
af:地址族： AF_INET  AF_INET6
src:需要转换的点分十进制的IP字符串
dst:转换后的结果保存在这个里面
// 将网络字节序的整数，转换成点分十进制的IP地址字符串
const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);
af:地址族： AF_INET  AF_INET6
src: 要转换的ip的整数的地址
dst: 转换成IP地址字符串保存的地方
size：第三个参数的大小（数组的大小）
返回值：返回转换后的数据的地址（字符串），和 dst 是一样的
*/
#include &lt;stdio.h&gt;
#include &lt;arpa/inet.h&gt;
int main() &#123;
// 创建一个ip字符串,点分十进制的IP地址字符串
char buf[] = &quot;192.168.1.4&quot;;**//第二个参数类型为字符数组**
unsigned int num = 0;**//第三个参数的类型为无符号整型的地址---注意传入地址加&amp;**
// 将点分十进制的IP字符串转换成网络字节序的整数
inet_pton(AF_INET, buf, &amp;num);
unsigned char * p = (unsigned char *)&amp;num;
//把四个字节分别打印出来：每次+1=字节+1
printf(&quot;%d %d %d %d\n&quot;, *p, *(p+1), *(p+2), *(p+3));
// 将网络字节序的IP整数转换成点分十进制的IP字符串
char ip[16] = &quot;&quot;;
const char * str =  inet_ntop(AF_INET, &amp;num, ip, 16);
printf(&quot;str : %s\n&quot;, str);
printf(&quot;ip : %s\n&quot;, ip);
printf(&quot;%d\n&quot;, ip == str);
return 0;
&#125;
</code></pre><blockquote><p>解析 unsigned char * p = (unsigned char *)#</p></blockquote><blockquote><p>二.(unsigned char *)&amp;a 运算顺序 1. 先取 a 的地址 2. 将 &amp; a 强制类型转化为 unsigned char * 类型，也就是指向 a 的地址 3. 取出 unsigned char * 指针的值</p></blockquote><h2 id="套接字函数"><a class="anchor" href="#套接字函数">#</a> 套接字函数</h2><pre><code class="language-C++">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt; // 包含了这个头文件，上面两个就可以省略
int socket(int domain, int type, int protocol);
</code></pre><ul><li><p>功能：创建一个套接字</p></li><li><p>参数：</p><ul><li><p>domain: 协议族</p><p>AF_INET : ipv4</p><p>AF_INET6 : ipv6</p><p>AF_UNIX, AF_LOCAL : <strong>本地套接字通信</strong>（进程间通信）</p></li><li><p>type: 通信过程中使用的协议类型</p><p>SOCK_STREAM : 流式协议</p><p>SOCK_DGRAM : 报式协议</p></li><li><p>protocol : 具体的一个协议。一般写 0，则：</p><ul><li>SOCK_STREAM : 流式协议默认使用 TCP</li><li>SOCK_DGRAM : 报式协议默认使用 UDP</li></ul></li></ul></li><li><p>返回值：</p><ul><li>成功：<strong>返回文件描述符</strong>，操作的就是内核缓冲区。</li><li>失败：-1</li></ul></li></ul><pre><code class="language-C++">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // socket命名
</code></pre><ul><li>功能：绑定，将 fd 和本地的 IP + 端口进行绑定</li><li>参数：<ul><li>sockfd : 通过 socket 函数得到的文件描述符</li><li>addr 😗* 需要绑定的 socket 地址，这个地址封装了 ip 和端口号的信息 **</li><li>addrlen : 第二个参数结构体占的内存大小</li></ul></li></ul><pre><code class="language-C++">int listen(int sockfd, int backlog); // /proc/sys/net/core/somaxconn
</code></pre><ul><li>功能：监听这个 socket 上的连接</li><li>参数：<ul><li>sockfd : 通过 socket () 函数得到的文件描述符</li><li>backlog : 未连接的和已经连接的和的最大值， 5 即可</li></ul></li><li>返回值：listen 成功返回 0，失败返回 - 1 并设置 errno</li></ul><pre><code class="language-C++">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
</code></pre><ul><li>功能：<strong>接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接</strong></li><li>参数：<ul><li>sockfd : <strong>用于监听的文件描述符</strong></li><li>addr : <strong>传出参数，记录了连接成功后客户端的地址信息</strong>（ip，port）</li><li>addrlen : 指定第二个参数的对应的内存大小</li></ul></li><li>返回值：<ul><li>成功 ：用于通信的文件描述符</li><li>-1 ： 失败</li></ul></li></ul><pre><code class="language-C++">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre><ul><li>功能： 客户端连接服务器</li><li>参数：<ul><li>sockfd : <strong>用于通信的文件描述符</strong></li><li>addr : 客户端要连接的服务器的地址信息</li><li>addrlen : 第二个参数的内存大小</li></ul></li><li>返回值：成功 0， 失败 -1</li></ul><pre><code class="language-C++">ssize_t write( int fd, const void *buf, size_t count); // 写数据
ssize_t read(int fd, void *buf, size_t count); // 读数据
</code></pre><blockquote><p>fd：文件描述符 buf：读取数据存放的地方，数组的地址→传出参数 count：指定数组的大小 需要包含的头文件 unistd.h</p></blockquote><ul><li>read 函数返回值</li></ul><blockquote><blockquote><p>0 实际读到的字节数 = 0 已经读到结尾（对端已经关闭断开连接）<br>-1 需要进一步判断 errno 的值 errno = EAGAIN or EWOULDBLOCK 设置了非阻塞方式读，并且没有数据到达 errno = EINTR 慢速系统调用被中断 errno = ECONNRESET 说明收到 RST 标志，连接被重置。需要 close errno = “其他” 异常</p></blockquote></blockquote><p>ssize_t 类型通常用于文件操作的 write、read 函数，用于表示可以被执行 read 和 write 操作的数据块的大小，其在头文件 unistd.h 中的定义如下，被 typedef 定义为__ssize_t 类型</p><ul><li>其实 ssize_t 是 signed size_t 类型，其中 size_t 类型是在标准 C 语言库中进行定义的</li><li>size_t 其本质是为了方便代码在不同的系统上移植而定义的，在 32 位的 Linux 中 size_t 为 unsigned int 类型即为 32 位无符号整数，在 64 位的 Linux 中其为 unsigned long 即为 64 位无符号整数。</li></ul><hr><h1 id="以下内容源自linux高性能服务器编程unix网络编程"><a class="anchor" href="#以下内容源自linux高性能服务器编程unix网络编程">#</a> 以下内容源自 Linux 高性能服务器编程 / UNIX 网络编程</h1><p>参考 Linux 多进程开发：进程：通信</p><h2 id="客户端"><a class="anchor" href="#客户端">#</a> 客户端</h2><h3 id="创建socket"><a class="anchor" href="#创建socket">#</a> 创建 socket</h3><h3 id="连接函数connect"><a class="anchor" href="#连接函数connect">#</a> 连接函数 connect</h3><p>TCP 客户通过 connect 函数来建立与 TCP 服务器的连接：</p><p>int connect (int sockfd, const struct sockaddr *servaddr,socklen_t addrlen); 返回：成功则为 0，若出错则为 - 1</p><blockquote><p>解释： sockfd 是由 socket 数返回的套接字描述符 第 2 个、第 3 个参数分别是一个指向套接字地址结构的指针和该结构的大小</p></blockquote><p>客户在调用函数 onnect 前不必非得调用 bind 函数， 因为如果需要的话，内核会确定源 IP 地址，并选择 个临时端口作为源端口。TCP 套接字调用 connect 函数会激发 TCP 三次握手，仅在连接成功或出错时返回。</p><ul><li>connect 函数建立导致客户端套接字从 CLOSED 状态转为→SYN_SENT 状态</li><li>若 connect 失败则该套接字不再可用，必须关闭，不能对该套接字再次调用 connect 函数</li></ul><h2 id="服务端"><a class="anchor" href="#服务端">#</a> 服务端</h2><h3 id="创建socket可读写控制关闭的文件描述符"><a class="anchor" href="#创建socket可读写控制关闭的文件描述符">#</a> 创建 socket：可读写控制关闭的文件描述符</h3><blockquote><p>int socket( int domain,int type,int protocol)</p></blockquote><ul><li>domain 参数告诉系统使用哪个底层协议簇，TCP/IP 使用 PF_INET（IPV4）</li><li>type 指定服务类型：主要包括 SOCK_STREAM（流服务）和 SOCK_UGRAM（数据报服务）。对 TCP/IP 协议族而言，<strong>SOCK_STREAM*<em>*<em> 表示传输层使用 TCP 协议，*</em>**SOCK_DGRAM**</em>* 表示传输层使用 UDP 协议</strong></li><li>protocol 参数是在前两个参数构成的协议集合下，再选择一个具体的协议，不过这个值通常是唯一的（由前两个参数完全决定），<strong>几乎在所有情况下都设置为 0，表示使用默认协议</strong></li></ul><p>调用成功返回一个<strong> socket 文件描述符（小的非负整数值）=sockfd</strong>，失败返回 - 1 并设置 errno</p><h3 id="命名socket"><a class="anchor" href="#命名socket">#</a> 命名 socket</h3><blockquote><p>创建 socket 时，我们给它指定了地址族，但并未指定具体用哪个地址 给 socket 命名：将一个 socket 与 socket 地址绑定</p></blockquote><p>客户端采用匿名方式 —— 使用操作系统自动分配的 socket 地址：把 一个本地协议地址赋给 一个套接字 系统调用函数：</p><blockquote><p>int bind(int sockfd,const struct sockaddr* my_addr,socklen_t addrlen);</p></blockquote><ul><li>bind 将 my_addr 所指向的 socket 地址分配给未命名的 sockfd 文件描述符，addrlen 参数指出该 socket 地址的长度。</li><li>bind 成功则返回 0，失败返回 - 1 并设置 errno 包括以下两种</li></ul><blockquote><p>EACCES: 被绑定的地址是受保护的地址 EADDRINUSE: 被绑定的地址正在使用中</p></blockquote><p><strong>可以将 sizeof (addr_in) 传入第三个 参数</strong></p><pre><code>sizeof` 是 `C/C++` 中的一个操作符（operator），返回一个对象或者类型所占的内存字节数。其返回值类型为 `size_t
</code></pre><p>sizeof (type_name); //sizeof (类型);<br>sizeof (object); // 或 sizeof object 都属于 sizeof 对象；</p><hr><p>上述两个函数都需要: include &lt;sys/types.h&gt; include&lt;sys/socket.h&gt;</p><h3 id="监听socket"><a class="anchor" href="#监听socket">#</a> 监听 socket</h3><p>socket 被命名后需要使用系统调用创建一个监听队列来存放待处理的客户连接：</p><blockquote><p>int listen( int sockfd,int backlog);</p></blockquote><blockquote><p>listen 函数仅由 TCP 服务器调用，并做如下两件事：</p></blockquote><ol><li><p>listen 函数创建一个套接字时，他被假设为一个主动套接字。listen 函数把 1 个未连接的套接字转换成 1 个被动套接字，指示内核接受指向套接字的连接请求。</p></li><li><p>第二个参数规定了内核应该为相应套接字排队的最大连接个数。 内核为每个给定的监听套接字维护两个队列：</p><p>（1）未完成连接队列：每个 SYN 分节对应队列中的一项，套接字正处于 SYN_RCVD 状态</p><p>（2）已完成连接队列：每个已完成三次握手的客户对应队列中的一项，套接字处于 ESTABLISHED 状态</p></li></ol><blockquote><p>1. 每当来自客户的 SYN 到达，<strong>TCP 在未完成连接队列中创建一个新项</strong>，然后服务器响应 SYN 第二个分节，并捎带对客户的 SYN 的 ACK。该项一直保留在未完成连接队列中，直到三次握手第三个分节到达或该项超时为止。如果三次握手正常，该项则<strong>从未完成连接队列转移到已完成连接队列的队尾</strong>。 2. 当进程调用 accept 函数时，已完成连接队列中的队头项将返回给进程，如果该队列为空那么进程将被投入睡眠，直到 TCP 在该队列中放入一项才唤醒它</p></blockquote><ul><li>sockfd 参数指定被监听的 socket。</li><li>backlog 参数提示内核<strong>监听队列的最大长度</strong>→监听队列长度如果超过 backlog，服务器将不手里新的客户连接，客户端将收到 ECONNREFUSED 错误信息，以前表示已连接队列 + 半连接队列之和</li><li>listen 成功返回 0，失败返回 - 1 并设置 errno</li></ul><h3 id="接受连接"><a class="anchor" href="#接受连接">#</a> 接受连接</h3><p>accept 函数由 TCP 服务器调用，用于<strong>从已完成连接队列队头返回下一个已完成连接</strong>。<strong>从 listen 监听队列中接受一个连接</strong></p><blockquote><p>int accept(int sockfd,struct sockaddr *addr,socklen_t *addrlen);</p></blockquote><ul><li>sockfd 参数是执行过 listen 系统调用的监听 socket 套接字描述符</li><li>addr 参数获取被接受连接的远端 socket 地址</li><li>远端 socket 地址结构长度由 * addrlen 参数所引用的整数值设置，返回时，该整数值为该套接字地址结构内的确切字节数</li><li>accept 成功时，<strong>那么其返回值是由 内核自动 生成的 1 个套接字全新描述符</strong> = 称为<strong>已连接套接字描述符</strong>，该 socket 唯一地表示了被接受的这个连接。失败则返回 - 1 并设置 errno。如果<strong>已完成连接队列为空，那么进程被投入睡眠</strong></li></ul><p>服务器可以通过该 socket 来与被接受连接对应的客户端通信</p><p>已连接套接字每次在循环中关闭，但监听套接字在服务器的整个有效期内都保持开放</p><p>而现在由于考虑到 syn 攻击，backlog 参数的含义改为了已连接队列之和，去除了半连接队列之和了。</p><p>举一个例子，在 socket 编程当中，如果我们在服务端不用 accept 函数，listen 函数的第二个参数设置为 5，那么这个时候，可以成功连接的客户端就是最多可以成功连入 5 个，每连入一个，队列的项数就会加一 (减一的话就是用 accept 函数去取出来)，所以当项数达到 5 时，客户端自然就会连不上了。</p><blockquote><p>注意本函数最多返回三个值：分别对应函数三个参数</p></blockquote><ul><li>新套接字描述符 / 出错指示整数</li><li>客户进程的协议地址→addr</li><li>客户进程的协议地址大小→addrlen</li></ul><hr><h4 id="socket状态"><a class="anchor" href="#socket状态">#</a> socket 状态</h4><ol><li>调用 socket 函数创建了一个套接字以后，改套接字就对应的和相应的输出缓冲区和输入缓冲区建立了联系，此时改套接字的状态正处于 CLOSED (观察 TCP 状态转换图即可)</li><li>当我们调用 listen 函数以后，改套接字的状态就变成了 LISTEN 监听状态，此时，处于等待客户端连入的状态。</li><li>对于一个调用 listen 进行监听的套接字’操作系统会为其维护 2 个队列：未完成连接队列和已完成连接队列。 （1）未完成连接队列中的连接 当客户端发送 TCP 连接三次握手的第 1 次（即 SYN 包）时，服务器端会在未完成连接队列中创建一个与该 SYN 包对应的项，可以把该项看成一个半连接（因为连接尚未建立）该半连接的状态会从 LISTEN 变成 SYNRCVD 同时向客户端返回第 2 次握手的包。 （SYN’ACK）而此时服务器正在等待完成第 3 次握手 （2）已完成连接队列中的连接 3 次握手完成后该连接就变成 ESTABLISHED 状态，每个已经完成 3 次握手的客户端连接（完整说法应该是 “服务器端的与客户端对应的 socket 连接”）都放在这个队列中作为一项。</li></ol><p>.png)</p><p>从上图可以看到客户端发送的三次握手从第 1 个 SYN 包到 ** <code>在三次握手完成之前</code> <strong>连接都会在未完成连接队列中；直到</strong> <code>在三次握手完成后</code> ** 该连接就从未完成连接队列转移到已完成连接队列</p><p>而 listen 函数” 曾经 “的含义为这两个队列的和不超过 backlog，实际上由于操作系统的原因可能会比这个值稍微多一些。</p><p>.png)</p><hr><h3 id="web服务器端通过socket监听来自用户的请求"><a class="anchor" href="#web服务器端通过socket监听来自用户的请求">#</a> Web 服务器端通过 <code>socket</code> 监听来自用户的请求。</h3><p>源代码如下：</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>#include &lt;sys/socket.h>  </pre></td></tr><tr><td data-num="2"></td><td><pre>#include &lt;netinet/in.h>  </pre></td></tr><tr><td data-num="3"></td><td><pre>/* 创建监听socket文件描述符 */  </pre></td></tr><tr><td data-num="4"></td><td><pre>int listenfd = socket(PF_INET, SOCK_STREAM, 0);  /* 创建监听socket的TCP/IP的IPV4 socket地址 struct sockaddr_in address;  </pre></td></tr><tr><td data-num="5"></td><td><pre>bzero(&amp;address, sizeof(address));  </pre></td></tr><tr><td data-num="6"></td><td><pre>address.sin_family = AF_INET;  </pre></td></tr><tr><td data-num="7"></td><td><pre>address.sin_addr.s_addr = htonl(INADDR_ANY);  /* INADDR_ANY：将套接字绑定到所有可用的接口   </pre></td></tr><tr><td data-num="8"></td><td><pre>address.sin_port = htons(port);  </pre></td></tr><tr><td data-num="9"></td><td><pre>int flag = 1;  </pre></td></tr><tr><td data-num="10"></td><td><pre>/* SO_REUSEADDR 允许端口被重复使用 */  </pre></td></tr><tr><td data-num="11"></td><td><pre>setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, sizeof(flag));  </pre></td></tr><tr><td data-num="12"></td><td><pre>/* 绑定socket和它的地址 */  </pre></td></tr><tr><td data-num="13"></td><td><pre>ret = bind(listenfd, (struct sockaddr*)&amp;address, sizeof(address));   </pre></td></tr><tr><td data-num="14"></td><td><pre>/* 创建监听队列以存放待处理的客户连接，在这些客户连接被accept()之前 */  </pre></td></tr><tr><td data-num="15"></td><td><pre>ret = listen(listenfd, 5);</pre></td></tr></table></figure><h4 id="代码分析"><a class="anchor" href="#代码分析">#</a> 代码分析：</h4><blockquote><p>创建监听 socket 的 TCP/IP 的 IPV4 socket 地址</p></blockquote><ul><li>struct sockaddr_in address;</li></ul><blockquote><p>bzero 函数是 c++ string.h 中的函数 *。* 功能描述：置字节字符串前 n 个字节为零且包括‘\0’。 原型:extern void bzero (void *s, int n); 参数说明:s 要置零的数据的起始地址；n 要置零的数据字节个数。 用法:#include &lt;string.h&gt; 功能:<strong> 置字节字符串 s 的前 n 个字节为零且包括‘\0’</strong>。 说明:bzero 无返回值</p></blockquote><ul><li>bzero(&amp;address, sizeof(address));</li></ul><blockquote><p>创建套接字时，用该字段指定地址族，对于 TCP/IP 协议的，必须设置为 AF_INET。变量 address 是一个结构体，其中成员变量 sin_family 是<strong>地址族类型变量</strong></p></blockquote><ul><li>address.sin_family = AF_INET;</li></ul><ol><li>sin_addr 是套接字中的 IP 地址，sin_addr 的类型是联合，因此可以通过三种不同的方式访问它：作为 s_un_b（四个 1 字节整数）、s_un_w（两个 2 字节整数）或作为 s_addr（一个 4 字节整数）。INADDR_ANY：将套接字绑定到所有可用的接口</li><li><strong>网络编程_常用的基本函数介绍</strong> ——htonl、ntohl、htons、ntohs htonl 函数：将主机的 unsigned long 值转换成网络字节顺序（32 位）（一般主机跟网络上传输的字节顺序是不通的，分大小端），函数返回一个网络字节顺序的数字。 ntohl 函数：将网络字节顺序（32 位）转为主机字节</li></ol><ul><li>address.sin_addr.s_addr = htonl(INADDR_ANY);</li></ul><blockquote><p>htons 是将整型变量从主机字节顺序转变成网络字节顺序， 就是整数在地址空间存储方式变为高位字节存放在内存的低地址处。</p></blockquote><ul><li>address.sin_port = htons(port);</li></ul><blockquote><p>SO_REUSEADDR 允许端口被重复使用</p></blockquote><ul><li>setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, sizeof(flag));</li></ul><p>setsockopt 函数解析：</p><p>SO_REUSEADDR 参数，打开或关闭地址复用功能。当 option_value 不等于 0 时，打开，否则，关闭。它实际所做的工作是置 sock-&gt;sk-&gt;sk_reuse 为 1 或 0。</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>#include &lt;sys/socket.h></pre></td></tr><tr><td data-num="2"></td><td><pre>int setsockopt(int sockfd, int level, int optname,</pre></td></tr><tr><td data-num="3"></td><td><pre>const void *optval, socklen_t optlen);</pre></td></tr><tr><td data-num="4"></td><td><pre>参数说明：</pre></td></tr><tr><td data-num="5"></td><td><pre>(1) int sockfd: 很简单，套接字描述符</pre></td></tr><tr><td data-num="6"></td><td><pre>(2) int level: 选项定义的层次；目前仅支持SOL_SOCKET和IPPROTO_TCP层次，若要在套接字级别上设置选项，就必须把level设置为 SOL_SOCKET</pre></td></tr><tr><td data-num="7"></td><td><pre>(3) int optname: 指定准备设置的选项，option_name可以有哪些取值，这取决于level</pre></td></tr><tr><td data-num="8"></td><td><pre>(4) const void *optval: 指针，指向存放选项值的缓冲区</pre></td></tr><tr><td data-num="9"></td><td><pre>(5) socklen_t optlen: optval缓冲区的长度</pre></td></tr></table></figure><blockquote><p>绑定 socket 和它的地址</p></blockquote><ul><li>ret = bind(listenfd, (struct sockaddr*)&amp;address, sizeof(address));</li></ul><blockquote><p>创建监听队列以存放待处理的客户连接，在这些客户连接被 accept () 之前</p></blockquote><ul><li>ret = listen(listenfd, 5);</li></ul><hr><blockquote><p>assert (ret≠-1) 函数的作用是现计算表达式 expression ，如果其值为假（即为 0），那么它先向 stderr 打印一条出错信息，然后通过调用 abort 来终止程序运行。</p></blockquote><p>书本 95 页服务器程序：</p><blockquote><pre><code>const char* ip=argv[1]; int port =atoi(argv[2]); int backlog =atoi(argv[3]); int inet_pton(int AF_INET, ip ,&amp;address.sin_addr);
</code></pre></blockquote><p>需要以下包： include &lt;sys/types.h&gt;<br>include &lt;sys/socket.h&gt;<br>include &lt;arpa/inet.h&gt;</p><p>解释：接收 IP 地址、端口还、backlog 值。调用 <code>inet_pton</code> 函数：可以在将 IP 地址在 “点分十进制” 和 “整数” 之间转换</p><blockquote><p>int inet_pton(int af, const char *src, void <em>dst);<br>这个函数转换字符串到网络地址，第一个参数 af 是地址族，转换后存在 dst 中<br>inet_pton 是 inet_addr 的扩展，支持的多地址族有下列：<br>af = AF_INET<br>src 为指向字符型的地址，即 ASCII 的地址的首地址（ddd.ddd.ddd.ddd 格式的），函数将该地址<br>转换为<strong> in_addr</strong> 的结构体，并复制在</em> dst 中</p></blockquote><blockquote><p>af =AF_INET6<br>src 为指向 IPV6 的地址，函数将该地址转换为<strong> in6_addr</strong> 的结构体，并复制在 * dst 中如果函数出错将返回一个负值，并将 errno 设置为 EAFNOSUPPORT，如果参数 af 指定的地址族和 src 格式不对，函数将返回 0。</p></blockquote><hr><h2 id="多线程实现并发服务器"><a class="anchor" href="#多线程实现并发服务器">#</a> 多线程实现并发服务器</h2><p>参考：Linux 多线程开发</p><p><strong>用户区中堆是共享，每个线程对应一个栈区 —— 不共享</strong></p><hr><h1 id="tcp状态转换"><a class="anchor" href="#tcp状态转换">#</a> TCP 状态转换</h1><p><img data-src="/2022/10/15/cpp/%E9%A1%B9%E7%9B%AE/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9Asocket%E3%80%81IO%E5%A4%8D%E7%94%A8%E3%80%81epoll/image-16684837417685.png" title="image-16684837417685"></p><p><img data-src="/2022/10/15/cpp/%E9%A1%B9%E7%9B%AE/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9Asocket%E3%80%81IO%E5%A4%8D%E7%94%A8%E3%80%81epoll/image-16684837417686.png" title="image-16684837417686"></p><p>（红色实现可以视为客户端发送请求，绿色虚线视为服务器，黑色是一些异常）</p><blockquote><p>为什么在服务端要分两次发送 ACK 和 FIN，不一次性发送 —— 为什么第二第三次挥手不合并？</p></blockquote><ul><li>因为客户端发送 FIN 后，服务端再发送 ACK 表示同意客户端断开连接，但服务端可能还需要发送数据给客户端，因此可以在服务端发送完数据后再发送 FIN 给客户端，表示服务端断开连接。</li><li>三次握手时可以一次性发送：因为建立连接是双方互相的通信，而四次挥手是单方面的意愿</li></ul><blockquote><p>为什么连接的主动关闭方必须处于 TIME_WAIT 状态并持续 2MSL 时间？<em>MSL 指一个片段在网络中最大的存活时间，2MSL 就是</em><em><strong>一个发送和一个回复所需的最大时间</strong></em></p></blockquote><ul><li>确保安全性：如果服务端没有接收到客户端最后发送的 ACK，那么能够让 TCP 连接的主动关闭方在它发送的 ACK 丢失的情况下重新发送最终的 ACK，直到确认服务端收到为止。</li><li>主动关闭方重新发送的最终 ACK 并不是因为被动关闭方重传了 ACK（它们并不消耗序列号，被动关闭方也不会重传），而<strong>是因为被动关闭方重传了它的 FIN</strong>。事实上，<strong>被动关闭方总是重传 FIN 直到它收到一个最终的 ACK。</strong></li></ul><p>2MSL（Maximum Segment Lifetime），主动断开连接的一方，最后进入一个 TIME_WAIT 状态，这个状态会持续: 2msl。msl: 官方建议: 2 分钟，实际是 30s</p><h2 id="半关闭"><a class="anchor" href="#半关闭">#</a> 半关闭</h2><p>半关闭状态：FIN_WAIT_1 不能发送数据（不包括协议 ACK 确认），但可以接收数据</p><p>当 TCP 连接中 A 向 B 发送 FIN 请求关闭，另一端 B 回应 ACK 之后（A 端进入 FIN_WAIT_2 状态），并没有立即发送 FIN 给 A，A 方处于半连接状态（半开关），此时 A 可以接收 B 发送的数据，但是 A 已经不能再向 B 发送数据。从程序的角度，可以<strong>使用 API 来控制实现半连接状态：</strong></p><pre><code class="language-C++">#include &lt;sys/socket.h&gt;
int shutdown(int sockfd, int how);
sockfd: 需要关闭的socket的描述符
how: 允许为shutdown操作选择以下几种方式:
    SHUT_RD(0)： 关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。
    SHUT_WR(1): 关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。
    SHUT_RDWR(2):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。
</code></pre><p>使用 close 中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为 0 时才关闭连接。<strong>shutdown *<em>** 不考虑描述符的引用计数，直接关闭描述符 **</em>*。也可选择中止一个方向的连接，只中止读或只中止写</strong>。</p><p>多进程中，创建的子进程和父进程共享文件描述符表，创建一个子进程引用计数加一</p><blockquote><p>注意： 如果有多个进程共享一个套接字，close 每被调用一次，计数减 1 ，直到计数为 0 时，也就是所用进程都调用了 close，套接字将被释放。 在多进程中如果一个进程调用了 shutdown (sfd, SHUT_RDWR) 后，其它的进程将无法通过该文件描述符 sfd 进行通信。但如果一个进程 close (sfd) 将不会影响到其它进程。</p></blockquote><h2 id="端口复用"><a class="anchor" href="#端口复用">#</a> 端口复用</h2><p>首先有个问题：通信双方有一方先断开连接，比如服务端先断开连接，那么处于 FIN_WAIT_2，客户端处于 CLOSE_WAIT，而客户端也断开连接，那么服务端处于 TIME_WAIT，<strong>此时服务端需要等待 2msl 时间才能释放它所占用的端口号</strong>，期间如果重新启动服务器./server 那么会一直显示： bind: Address already in use</p><p>如果希望服务器主动结束后能立刻运行，那么需要端口复用！</p><blockquote><p>tcp 协议中 FIN_WAIT2 到 Time_wait 的状态是有时间的，如果超过这个时间，服务端内核就会直接结束，所以如果服务端在 FIN_WAIT_2 状态一定时间后会自动结束进程</p></blockquote><p><img data-src="/2022/10/15/cpp/%E9%A1%B9%E7%9B%AE/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9Asocket%E3%80%81IO%E5%A4%8D%E7%94%A8%E3%80%81epoll/image-16684837417687.png" title="image-16684837417687"></p><p>当客户端也断开后（给服务端发送了 FIN），服务端进入 TIME_WAIT</p><p>端口复用最常用的用途是:</p><ul><li>防止服务器重启时之前绑定的端口还未释放</li><li>程序突然退出而系统没有释放端口</li><li>还能设置套接字的属性</li></ul><h4 id="recv函数"><a class="anchor" href="#recv函数">#</a> recv 函数</h4><p>**int recv( SOCKET s, char FAR *buf, int len, int flags ); **</p><p>不论是客户还是服务器应用程序都用 recv 函数从 TCP 连接的另一端接收数据。</p><ul><li>该函数的第一个参数指定接收端套接字描述符；</li><li>第二个参数指明一个缓冲区，该缓冲区用来存放 recv 函数接收到的数据；</li><li>第三个参数指明 buf 的长度；</li><li>第四个参数一般置 0。</li></ul><blockquote><p>这 里只描述同步 Socket 的 recv 函数的执行流程： 当应用程序调用 recv 函数时，recv 先等待 s 的发送缓冲中的数据被协议传送完毕，如果协议在传送 s 的发送缓冲中的数据时出现网络错误 ，那么 recv 函数返回 SOCKET_ERROR</p></blockquote><p>如果 s 的发送缓冲中没有数 据或者数据被协议成功发送完毕后，recv 先检查套接字 s 的接收缓冲区，如果 s 接收缓冲区中没有数据或者协议正在接收数据，那么 recv 就一直等待，只到 协议把数据接收完毕。当协议把数据接收完毕，recv 函数就把 s 的接收缓冲中的数据 copy 到 buf 中（注意协议接收到的数据可能大于 buf 的长度，所以 在这种情况下要调用几次 recv 函数才能把 s 的接收缓冲中的数据 copy 完。recv 函数仅仅是 copy 数据，真正的接收数据是协议来完成的），<strong>recv 函数返回其实际 copy 的字节数。</strong></p><p>如果 recv 在 copy 时出错，那么它返回 SOCKET_ERROR；如果 recv 函数在等待协议接收数据时网络中断 了，那么它返回 0</p><pre><code class="language-C++">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
// 设置套接字的属性（不仅仅能设置端口复用）
int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
参数（在UNP（Unix网络编程）书籍中使用）：
</code></pre><ul><li><p>sockfd : 要操作的文件描述符</p></li><li><p>level : 级别 - SOL_SOCKET (端口复用的级别)</p></li><li><p>optname : 选项的名称，</p><p>端口复用都可以使用</p><ul><li>SO_REUSEADDR</li><li>SO_REUSEPORT</li></ul></li><li><p>optval : 端口复用的值（整型）</p><ul><li>1 : 可以复用</li><li>0 : 不可以复用</li></ul></li><li><p>optlen : optval 参数的大小</p></li></ul><p><strong>端口复用，设置的时机是</strong> ** 在服务器绑定端口之前 ****。 **setsockopt (); bind ();</p><pre><code class="language-C++">常看网络相关信息的命令
netstat
参数：
-a 所有的socket
-p 显示正在使用socket的程序的名称
-n 直接使用IP地址，而不通过域名服务器
</code></pre><p>.png)</p><p>0.0.0.0ip 绑定了 9999 端口号，server 是应用程序的名称</p><h2 id="io多路复用io多路转接面试必问"><a class="anchor" href="#io多路复用io多路转接面试必问">#</a> I/O 多路复用（I/O 多路转接）面试必问</h2><h3 id="select-poll-和-epoll要手动写出来知道原理"><a class="anchor" href="#select-poll-和-epoll要手动写出来知道原理">#</a> <strong>select、poll 和 epoll</strong> 要手动写出来，知道原理</h3><ol><li><strong>I/O 多路复用使得程序能同时监听多个文件描述符，能够提高程序的性能</strong>，Linux 下实现 I/O 多路复用的系统调用主要有 <strong>select、poll 和 epoll</strong>。</li><li>之前的做法是一个一个文件描述符去遍历，无法同时监听</li></ol><p>输入输出对应的是程序和内存： 输入：程序 / 文件→内存 输出：内存→文件</p><p>.png)</p><ol><li>阻塞等待 (（阻塞 IO 模型即 BIO 模型）</li></ol><p>.png)</p><p>.png)</p><p>每有一个客户端连接进来，就创建一个线程去读取接收客户端数据，而主线程不受影响</p><h3 id="非阻塞忙轮询非阻塞模型即nio"><a class="anchor" href="#非阻塞忙轮询非阻塞模型即nio">#</a> 非阻塞，忙轮询（非阻塞模型即 NIO）</h3><p>可以设置 read 不阻塞，此时有数据就读，没数据就返回一个值继续往下执行，但需要不断循环判断是否有数据进来 <img data-src="/2022/10/15/cpp/%E9%A1%B9%E7%9B%AE/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9Asocket%E3%80%81IO%E5%A4%8D%E7%94%A8%E3%80%81epoll/ock.png" title="ock"></p><p>.png)</p><p>当有客户端连接进来，accept 就将该 cfd 添加到一个表里面；然后再逐个判断每个文件描述符 cfd 是否有数据通信，当有数据通信就调用 read/recv 读取，没有就继续往下循环。</p><p>当客户端数量巨大时逐个遍历是否有数据写入</p><p>IO 多路转接</p><p>.png)</p><p>.png)</p><p>现在将所有客户端的文件描述符 cfd 统一交给内核，内核去检测再返回，因此只调用了一次就查出是哪个</p><h2 id="select-api介绍"><a class="anchor" href="#select-api介绍">#</a> select API 介绍</h2><blockquote><p>主旨思想： 1. 首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中。</p></blockquote><ol><li>调用一个系统函数（即 select），监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行 I/O 操作时，该函数才返回。 a. 这个函数是阻塞 b. 函数对文件描述符的检测的操作是由内核完成的 3. 在返回时，它会告诉进程有多少（哪些）描述符要进行 I/O 操作</li></ol><pre><code class="language-C++">// sizeof(fd_set) = 128个字节 =1024位，每个标志位保存一个文件描述符
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/select.h&gt;
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
</code></pre><ul><li><p>参数：</p><ul><li><p>nfds : 委托内核检测的<strong>最大文件描述符的值 + 1</strong>→为了能够遍历到最大的文件描述符，类似： for (int i=0;i&lt;n+1;i++)</p></li><li><p>readfds : 要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性。</p><p>检测读缓冲区有没有数据</p><p>。没有数据标志位置 0，有数据置为 1. 因此最后返回的是标志位为 1 的文件描述符。</p><ul><li>一般检测读操作</li><li>对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲区<ul><li>是一个传入传出参数</li></ul></li></ul></li><li><p>writefds : 要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性</p><ul><li>委托内核检测写缓冲区是不是还可以写数据（不满的就可以写），满了标志位置 0，不满置 1</li></ul></li><li><p>exceptfds : 检测发生异常的文件描述符的集合</p></li><li><p>timeout : 设置的超时时间</p></li></ul></li></ul><pre><code class="language-C++">struct timeval &#123;
    long tv_sec; /* seconds */
    long tv_usec; /* microseconds */
&#125;;
    - NULL : 永久阻塞，直到检测到了文件描述符有变化
    - tv_sec = 0 tv_usec = 0， 不阻塞
    - tv_sec &gt; 0 tv_usec &gt; 0， 阻塞对应的时间
</code></pre><ul><li><p>返回值 :</p><ul><li><p>-1 : 失败</p></li><li><blockquote><p>0 (n) : 检测的集合中有 n 个文件描述符发生了变化</p></blockquote></li></ul></li></ul><pre><code class="language-C++">// 将参数文件描述符fd对应的标志位设置为0（clear）
void FD_CLR(int fd, fd_set *set);
// 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，如果是0返回0， 是1返回1
int FD_ISSET(int fd, fd_set *set);
// 将参数文件描述符fd 对应的标志位，设置为1
void FD_SET(int fd, fd_set *set);
// fd_set一共有1024 bit, 全部初始化为0
void FD_ZERO(fd_set *set);
</code></pre><p>1. 要检测读缓冲区，首先建立一个 fd_set，存放每个文件描述符读缓冲区的标志位。每个比特位代表一个文件描述符 （注意前三个是被占用的！）</p><p>2. 然后将要检测的文件描述符标志位置 1, 以上都是在用户态中进行</p><p>3. 之后调用 select，将 fd_set 拷贝到内核态检测有哪些位是有数据→置 1，没有数据的→置 0，再将结构 fd_set 返回到用户态，用户只需要一次遍历用户态中的 fd_set 就能知道有多少文件描述符有数据</p><p>.png)</p><h2 id="poll-api介绍及代码编写"><a class="anchor" href="#poll-api介绍及代码编写">#</a> poll API 介绍及代码编写</h2><p><strong>核心：将主动询问内核转变为等待内核通知</strong>，从主动轮询→被动通知 <strong>一次系统调用 select/poll 就可以实现管理多个 client 事件（读写 accept 等）</strong>，降低非阻塞 IO 频繁无效系统调用问题</p><p>select () 函数缺点：<strong>内核态中依然要遍历所有文件描述符</strong>，每次调用需要拷贝全量描述符到内核态</p><p>.png)</p><p>POLL</p><pre><code class="language-C++">#include &lt;poll.h&gt;
struct pollfd &#123;
    int fd; /* 委托内核检测的文件描述符 */
    short events; /* 委托内核检测文件描述符的什么事件 */
    short revents; /* 文件描述符实际发生的事件 */
&#125;;
struct pollfd myfd;
   myfd.fd = 5;
   myfd.events = POLLIN | POLLOUT;  同时检测两个事件：同时委托内核进行读写操作
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
</code></pre><ul><li><p>参数：</p><ul><li><p>fds : 是一个 struct pollfd 结构体数组，这是一个需要检测的文件描述符的集合</p></li><li><p>nfds : 这个是第一个参数数组中最后一个有效元素的下标 + 1</p></li><li><p>timeout : 阻塞时长</p><p>0 : 不阻塞</p><p>-1 : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞</p><blockquote><p>0 : 阻塞的时长</p></blockquote></li></ul></li><li><p>返回值：</p><p>-1 : 失败</p><blockquote><p>0（n） : 成功，n 表示检测到集合中有 n 个文件描述符发生变化</p></blockquote></li></ul><blockquote><p>poll 数组如果已满，没有可用的位置存放新连接 accept 进来的文件描述符 cfd，那么就等待下一次处理。注意新连接的 cfd 不会丢弃，在 TCP 缓冲区中，等到 poll 数组中有可用的就可以继续连接了</p></blockquote><p>如果有数据传入，则调用 read 返回 len，len=0 说明读取完毕，先 close 关闭该文件描述符，再将该结构体的文件描述符置为 - 1，fd [i].fd=-1</p><p>.png)</p><h2 id="epoll-api-介绍"><a class="anchor" href="#epoll-api-介绍">#</a> epoll API 介绍</h2><p>改进：</p><p><strong>首先调用 epoll_create 在 *<em>** 内核区创建 epoll 实例 **</em>*—— 结构体数据</strong></p><p>struct rb_root rbr;// 存放文件描述符，底层是红黑树 struct list_head rdlist;// 检测到发生改变的（有数据传入的）文件描述符，底层双链表</p><p>.png)</p><p>#include &lt;sys/epoll.h&gt;</p><p>//epoll_create 创建一个新的 epoll 实例，返回指向该实例的描述符 epollfd 用来调用所有 epoll 相关接口。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检测的文件描述符的信息（红黑树），还有一个是<strong>就绪列表</strong>，存放检测到数据发生改变的文件描述符信息（双向链表）。</p><p>当 epollfd 不再使用时，需要调用 close () 关闭，当指向 epoll 的文件描述符关闭后内核会摧毁 epoll 实例并释放相关资源。</p><p>epoll_ctl: 将哪个客户端 fd 的哪些事件 event 交给哪个 epoll (epollfd) 来管理（增删改）</p><p>int epoll_create(int size);</p><ul><li><p>参数：</p><p>size : 目前没有意义了。随便写一个数，必须大于 0</p></li><li><p>返回值：</p><p>-1 : 失败</p><blockquote><p>0 : 文件描述符，指向 epoll 实例的描述符</p></blockquote></li></ul><pre><code class="language-C++">typedef union epoll_data &#123;
    void *ptr;
    int fd;
    uint32_t u32;
    uint64_t u64;
&#125; epoll_data_t;
struct epoll_event &#123;
    uint32_t events; /* Epoll events */
    epoll_data_t data; /* User data variable */
&#125;;
</code></pre><p>常见的 Epoll 检测事件：</p><ul><li>EPOLLIN</li><li>EPOLLOUT</li><li>EPOLLERR</li></ul><p>// 对 epoll 实例进行管理：添加文件描述符信息，删除信息，修改信息</p><p><strong>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</strong></p><ul><li><p>参数：</p><ul><li><p>epfd : <strong>epoll 实例对应的文件描述符</strong></p></li><li><p>op : 要进行什么操作</p><p>EPOLL_CTL_ADD: 添加</p><p>EPOLL_CTL_MOD: 修改</p><p>EPOLL_CTL_DEL: 删除</p></li><li><p>fd : <strong>要检测的文件描述符</strong></p></li><li><p>event : 检测文件描述符什么事情</p></li></ul></li></ul><p>// 检测函数</p><p><strong>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</strong></p><ul><li>参数：<ul><li>epfd : epoll 实例对应的文件描述符</li><li>events : <strong>传出参数，保存了发送了变化的文件描述符的信息</strong></li><li>maxevents : 第二个参数结构体数组的大小</li><li>timeout : 阻塞时间<ul><li>0 : 不阻塞</li><li>-1 : 阻塞，直到检测到 fd 数据发生变化，解除阻塞</li><li>0 : 阻塞的时长（毫秒）</li></ul></li></ul></li><li>返回值：只返回发生变化的文件描述符到用户区<ul><li>成功，返回发送变化的文件描述符的个数 &gt; 0</li><li>失败 -1</li></ul></li></ul><p>问题：在最开始调用 epoll_ctl 把监听的文件描述符放进红黑树的时候传入了 &amp; epev，也就是 epev 的指针，为什么后面传入新的文件描述符的时候可<strong>以重用这个 epev</strong> 呢，这样重用 epev 的话前面传入的监听描述符不就被改动了嘛？</p><blockquote><p>epoll_ctl 会在 epoll fd 红黑树中重新添加一个节点，而不是覆盖 lfd 的节点，然后新添加的节点会关联这个 event。<br>至于每次重用 event，而不会影响之前的已经在 rb tree 中传入的节点，应该是拷贝了 event 的数据。</p></blockquote><h3 id="epoll的工作模式"><a class="anchor" href="#epoll的工作模式">#</a> Epoll 的工作模式</h3><p>.png)</p><ul><li><p>LT 模式：水平触发（缺省工作方式）</p><p>a. 用户不读数据，数据一直在缓冲区，epoll 会一直通知</p><p>b. 用户只读一部分数据，epoll 会通知</p><p>c. 缓冲区数据读完了，不通知</p></li></ul><blockquote><p>只要监听的文件描述符缓冲区中有数据，就会触发 epoll_wait 有返回值，内核就会通知你这个文件描述符是就绪的，这是默认的 epoll_wait 的方式。 同时支持阻塞和非阻塞</p></blockquote><ul><li><p>ET 模式：边沿触发 —— 效率高：减少 epoll 事件被重复触发的次数</p><p>a. 用户不读数据，数据一直在缓冲区，epoll 下次检测不通知</p><p>b. 用户只读一部分数据，epoll 不通知</p><p>c. 缓冲区数据读完了，不通知</p></li></ul><blockquote><p>1. 只有监听的文件描述符的读 / 写事件发生，才会触发 epoll_wait 有返回值；比如：当 fd 文件描述符缓冲区来了 8 字节数据，内核会通知一次，你只读两个字节，内核不会通知你缓冲区还有数据（文件描述符就绪），直到你读完所有缓冲区数据，下次数据来了内核才会通知您 <strong>2. 只支持非阻塞</strong> —— 因为该模式要求最好当内核通知触发时一次性读取完所有缓冲区数据，那么就需要在<strong> while 循环</strong>中不断 read 读取数据，而 read 就得设置成非阻塞，否则就会卡在那。<strong>必须使用非阻塞套接字</strong>，避免由于一个文件描述符的阻塞读 / 写把处理多个文件描述符任务饿死</p></blockquote><pre><code class="language-C++">struct epoll_event &#123;
    uint32_t events; /* Epoll events */
    epoll_data_t data; /* User data variable */
&#125;;
常见的Epoll检测事件：
    EPOLLET             边沿触发（在accept后设置event）
    EPOLLIN
    EPOLLOUT
</code></pre><blockquote><p>EPOLLONESHOT：即使可以使用 ET 模式，<strong>一个 socket 上的某个事件还是可能被触发多次</strong>。这在并发程序中就会引起一个 问题。比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据的处理过程中该 socket 上又有新数据可读（EPOLLIN 再次被触发），此时另外一个线程被唤醒来读取这些新的数据。于 是就出现了两个线程同时操作一个 socket 的局面。<strong>一个 socket 连接在任一时刻都只被一个线程处理，可 以使用 epoll 的 EPOLLONESHOT 事件实现</strong>。 对于注册了 EPOLLONESHOT 事件的文件描述符，<strong>操作系统最多触发其上注册的一个可读、可写或者异 常事件，且只触发一次，除非我们使用 epoll_ctl 函数重置该文件描述符上注册的 EPOLLONESHOT 事 件</strong>。这样，当一个线程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的。但反过来思考，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， 该线程就应该立即重置这个 socket 上的 EPOLLONESHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能被触发，进 而让其他工作线程有机会继续处理这个 socket。</p></blockquote><p>epoll 更在细致的执行流程</p><ul><li>创建内核事件表（epoll_create）。这里主要是向内核申请创建一个 fd 的文件描述符作为内核事件表（<strong>B + 树结构的文件</strong>，没有数量限制），这个描述符用来保存应用进程需要监控哪些 fd 和对应类型的事件。 （简单理解<strong>内核申请一个 B + 树来监听事件</strong>）</li><li>添加或移出监控的 fd 和事件类型（epoll_ctl）。调用此方法可以是向内核的内核事件表 动态的添加和移出 fd 和对应事件类型。</li><li><strong>epoll_wait 绑定回调事件</strong>：<strong>内核向事件表的 fd 绑定一个回调函数</strong>。当监控的<strong> fd 活跃</strong>时，会调用 callback 函数<strong>把事件加到一个活跃事件队列</strong>里；最后在 epoll_wait 返回的时候内核会把<strong>活跃事件队列里的 fd 和事件类型返回给应用进程</strong>。</li></ul><p>总结：</p><ul><li>最后，从 epoll 整体思路上来看，采用<strong>事先就在内核创建一个事件监听表</strong>，后面只需要往里面添加移出对应事件，因为本身事件表就在内核空间，所以就避免了向 select、poll 一样每次都要把自己需要监听的事件列表传输过去，然后又传回来，这也就避免了事件信息需要在用户空间和内核空间相互拷贝的问题。</li><li>然后 epoll 并不是像 select 一样去遍历事件列表，然后逐个轮询的监控 fd 的事件状态，而是<strong>事先就建立了 fd 与之对应的回调函数</strong>，当事件激活后主动回调 callback 函数，这也就避免了遍历事件列表的这个操作，所以 epoll 并不会像 select 和 poll 一样随着监控的 fd 变多而效率降低，这种事件机制也是 epoll 要比 select 和 poll 高效的主要原因。</li></ul><div class="tags"><a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C++</a> <a href="/tags/webserver/" rel="tag"><i class="ic i-tag"></i> webserver</a> <a href="/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9Asocket%E3%80%81IO%E5%A4%8D%E7%94%A8%E3%80%81epoll/" rel="tag"><i class="ic i-tag"></i> Linux网络编程：socket、IO复用、epoll</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-11-29 13:37:43" itemprop="dateModified" datetime="2022-11-29T13:37:43+08:00">2022-11-29</time> </span><span id="2022/10/15/cpp/项目/Linux网络编程：socket、IO复用、epoll/" class="item leancloud_visitors" data-flag-title="Linux网络编程：socket、IO复用、epoll" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/alipay.jpg" alt="Sean Barrett 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Sean Barrett <i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong> <a href="https://aristotlednzk.github.io.com/2022/10/15/cpp/%E9%A1%B9%E7%9B%AE/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9Asocket%E3%80%81IO%E5%A4%8D%E7%94%A8%E3%80%81epoll/" title="Linux网络编程：socket、IO复用、epoll">https://aristotlednzk.github.io.com/2022/10/15/cpp/项目/Linux网络编程：socket、IO复用、epoll/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/10/15/bug/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipexbei4hj20zk0m8npd.jpg" title="bug"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> bug</span><h3>bug</h3></a></div><div class="item right"><a href="/2022/10/18/%E8%A8%80/%E5%8F%B0%E9%A3%8E%E4%B8%8E%E7%A7%8B/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giciusoyjnj219g0u0x56.jpg" title="台风与秋"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 言</span><h3>台风与秋</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">前置知识：</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#socket%E5%9C%B0%E5%9D%80api"><span class="toc-number"></span> <span class="toc-text">socket 地址 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8socket%E5%9C%B0%E5%9D%80"><span class="toc-number">1.</span> <span class="toc-text">通用 socket 地址：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%93%E7%94%A8socket%E5%9C%B0%E5%9D%80"><span class="toc-number">2.</span> <span class="toc-text">专用 socket 地址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ip%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number"></span> <span class="toc-text">IP 地址转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">套接字函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A5%E4%B8%8B%E5%86%85%E5%AE%B9%E6%BA%90%E8%87%AAlinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bunix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">以下内容源自 Linux 高性能服务器编程 &#x2F; UNIX 网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number"></span> <span class="toc-text">客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAsocket"><span class="toc-number">1.</span> <span class="toc-text">创建 socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%87%BD%E6%95%B0connect"><span class="toc-number">2.</span> <span class="toc-text">连接函数 connect</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number"></span> <span class="toc-text">服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAsocket%E5%8F%AF%E8%AF%BB%E5%86%99%E6%8E%A7%E5%88%B6%E5%85%B3%E9%97%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.</span> <span class="toc-text">创建 socket：可读写控制关闭的文件描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8Dsocket"><span class="toc-number">2.</span> <span class="toc-text">命名 socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%ACsocket"><span class="toc-number">3.</span> <span class="toc-text">监听 socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%97%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.</span> <span class="toc-text">接受连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#socket%E7%8A%B6%E6%80%81"><span class="toc-number">4.1.</span> <span class="toc-text">socket 状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E9%80%9A%E8%BF%87socket%E7%9B%91%E5%90%AC%E6%9D%A5%E8%87%AA%E7%94%A8%E6%88%B7%E7%9A%84%E8%AF%B7%E6%B1%82"><span class="toc-number">5.</span> <span class="toc-text">Web 服务器端通过 socket 监听来自用户的请求。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">5.1.</span> <span class="toc-text">代码分析：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number"></span> <span class="toc-text">多线程实现并发服务器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcp%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number"></span> <span class="toc-text">TCP 状态转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8A%E5%85%B3%E9%97%AD"><span class="toc-number"></span> <span class="toc-text">半关闭</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">端口复用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#recv%E5%87%BD%E6%95%B0"><span class="toc-number">0.1.</span> <span class="toc-text">recv 函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8io%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE"><span class="toc-number"></span> <span class="toc-text">I&#x2F;O 多路复用（I&#x2F;O 多路转接）面试必问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#select-poll-%E5%92%8C-epoll%E8%A6%81%E6%89%8B%E5%8A%A8%E5%86%99%E5%87%BA%E6%9D%A5%E7%9F%A5%E9%81%93%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">select、poll 和 epoll 要手动写出来，知道原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BF%99%E8%BD%AE%E8%AF%A2%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B%E5%8D%B3nio"><span class="toc-number">2.</span> <span class="toc-text">非阻塞，忙轮询（非阻塞模型即 NIO）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select-api%E4%BB%8B%E7%BB%8D"><span class="toc-number"></span> <span class="toc-text">select API 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#poll-api%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99"><span class="toc-number"></span> <span class="toc-text">poll API 介绍及代码编写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#epoll-api-%E4%BB%8B%E7%BB%8D"><span class="toc-number"></span> <span class="toc-text">epoll API 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">Epoll 的工作模式</span></a></li></ol></li></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2022/10/15/cpp/%E9%A1%B9%E7%9B%AE/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9Asocket%E3%80%81IO%E5%A4%8D%E7%94%A8%E3%80%81epoll/" rel="bookmark" title="Linux网络编程：socket、IO复用、epoll">Linux网络编程：socket、IO复用、epoll</a></li><li><a href="/2022/11/15/cpp/%E9%A1%B9%E7%9B%AE/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" rel="bookmark" title="Linux多线程开发">Linux多线程开发</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sean Barrett" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sean Barrett</p><div class="description" itemprop="description">思及我域</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">21</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">16</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">16</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FyaXN0b3RsZUROWks=" title="https:&#x2F;&#x2F;github.com&#x2F;AristotleDNZK"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTk0NTI2OTQy" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;94526942"><i class="ic i-cloud-music"></i></span> <a href="/jiang1302833@163.com" title="jiang1302833@163.com" class="item email"><i class="ic i-envelope"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-clipboard"></i>书架</a><ul class="submenu"><li class="item"><a href="/books/deeplearning-books/" rel="section"><i class="ic i-fedora"></i>人工智能</a></li><li class="item"><a href="/books/philosophy-books/" rel="section"><i class="ic i-fedora"></i>哲学</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>链环</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/10/15/bug/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/10/18/%E8%A8%80/%E5%8F%B0%E9%A3%8E%E4%B8%8E%E7%A7%8B/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E8%A8%80/" title="分类于 言">言</a></div><span><a href="/2022/10/18/%E8%A8%80/%E5%8F%B0%E9%A3%8E%E4%B8%8E%E7%A7%8B/" title="台风与秋">台风与秋</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/bug/" title="分类于 bug">bug</a></div><span><a href="/2022/10/15/bug/" title="bug">bug</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/cpp/" title="分类于 C++">C++</a> <i class="ic i-angle-right"></i> <a href="/categories/cpp/%E9%A1%B9%E7%9B%AE/" title="分类于 项目">项目</a></div><span><a href="/2022/11/15/cpp/%E9%A1%B9%E7%9B%AE/%E5%8D%8A%E5%90%8C%E6%AD%A5-%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="半同步&#x2F;半反应堆线程池">半同步/半反应堆线程池</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/philosophy/" title="分类于 哲学社科">哲学社科</a> <i class="ic i-angle-right"></i> <a href="/categories/philosophy/%E4%B8%AD%E5%93%B2/" title="分类于 中哲">中哲</a></div><span><a href="/2022/10/11/philosophy/%E7%8E%8B%E9%98%B3%E6%98%8E%E5%BF%83%E5%AD%A6/" title="王阳明心学">王阳明心学</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/cpp/" title="分类于 C++">C++</a> <i class="ic i-angle-right"></i> <a href="/categories/cpp/%E9%A1%B9%E7%9B%AE/" title="分类于 项目">项目</a></div><span><a href="/2022/11/10/cpp/%E9%A1%B9%E7%9B%AE/Tinywebserver%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/" title="Tinywebserver项目记录">Tinywebserver项目记录</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/10/09/hello-world/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 转码之路">转码之路</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a></div><span><a href="/2022/11/15/computer-science/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" title="单例模式">单例模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%A8%80/" title="分类于 言">言</a></div><span><a href="/2022/10/21/%E8%A8%80/%E4%B8%96%E7%95%8C%E3%82%A2%E3%83%B3%E3%83%89%E5%B4%87%E9%AB%98/" title="世界アンド崇高">世界アンド崇高</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/philosophy/" title="分类于 哲学社科">哲学社科</a> <i class="ic i-angle-right"></i> <a href="/categories/philosophy/%E8%A5%BF%E5%93%B2/" title="分类于 西哲">西哲</a></div><span><a href="/2022/10/12/philosophy/%E7%8E%B0%E8%B1%A1%E5%AD%A6-%E8%83%A1%E5%A1%9E%E5%B0%94/%E7%8E%B0%E8%B1%A1%E5%AD%A6-%E8%83%A1%E5%A1%9E%E5%B0%94/" title="现象学&#x2F;胡塞尔">现象学/胡塞尔</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/GAN%E8%AF%BE%E9%A2%98/" title="分类于 GAN课题">GAN课题</a></div><span><a href="/2022/10/14/GAN%E8%AF%BE%E9%A2%98/%E7%9B%B8%E6%9C%BA%E6%89%8B%E7%9C%BC%E6%A0%87%E5%AE%9A/%E7%9B%B8%E6%9C%BA%E6%89%8B%E7%9C%BC%E6%A0%87%E5%AE%9A/" title="相机手眼标定">相机手眼标定</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sean Barrett @ Sean Barrett</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">49k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">44 分钟</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/10/15/cpp/项目/Linux网络编程：socket、IO复用、epoll/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>