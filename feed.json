{
    "version": "https://jsonfeed.org/version/1",
    "title": null,
    "subtitle": "远行者回忆录——人类往事",
    "icon": "https://aristotlednzk.github.io.com/images/favicon.ico",
    "description": "思及我域",
    "home_page_url": "https://aristotlednzk.github.io.com",
    "items": [
        {
            "id": "https://aristotlednzk.github.io.com/2022/11/15/cpp/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/",
            "url": "https://aristotlednzk.github.io.com/2022/11/15/cpp/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/",
            "title": "Linux多线程开发",
            "date_published": "2022-11-15T03:28:58.000Z",
            "content_html": "<h2 id=\"线程概念\"><a class=\"anchor\" href=\"#线程概念\">#</a> 线程概念</h2>\n<p>与进程 (process）类似，线程 (thread) 是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。(传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程)</p>\n<p><strong>进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。</strong></p>\n<p>线程是轻量级的进程（LWP: Light weight Process)，在 Linux 环境下线程的本质仍是进程。</p>\n<p>查看指定进程的 LWP 号：ps -Lf pid</p>\n<ul>\n<li>进程之间的信息难以共享</li>\n<li>fork（）创建进程的代价相对较高 —— 写时复制</li>\n<li>创建线程是共用原来的虚拟地址空间，只是<strong>栈空间和代码段.text</strong> 细分给不同线程，而堆空间都是共享的</li>\n</ul>\n<p><img data-src=\"/2022/11/15/cpp/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png\" class=\"\" title=\"多线程\"></p>\n<h2 id=\"线程创建\"><a class=\"anchor\" href=\"#线程创建\">#</a> 线程创建</h2>\n<p>main 函数所在线程称为主线程。 程序默认只有一个进程和线程</p>\n<pre><code class=\"language-C++\">pthread_t tid;\nint ret=pthread_create(&amp;tid,NULL,callback,NULL);\n\nint pthread_create(pthread_t *thread,const pthread_attr_t *attr,void *(start_routine) (void *),void *arg);\n</code></pre>\n<p>thread: 传出参数，线程创建成功后，子线程的线程 ID 被写到该变量中 attr：设置线程的属性，默认值 NULL start_routine：函数指针，<strong>这个函数是子线程需要处理的逻辑代码</strong> arg：第三个参数使用，传参</p>\n<p>返回值：成功返回 0，失败返回错误号</p>\n<h2 id=\"线程同步\"><a class=\"anchor\" href=\"#线程同步\">#</a> 线程同步</h2>\n<p>线程优势：能够通过全局变量来共享信息。但必须确保线程安全</p>\n<p>临界区：访问共享资源的代码片段，并且这段代码的执行应该为原子操作 —— 同时访问同一个共享资源的线程不能执行该区域代码到一半中断。</p>\n<p>线程同步：当有一个线程在对内存进行操作的时候，其他线程都不能对这个内存地址进行操作，知道该线程完成操作，其他线程都处于等待状态</p>\n<p><strong>终止线程</strong>：在哪个线程中调用就终止哪个线程</p>\n<pre><code class=\"language-C++\">pthread_exit(void* retval);\n</code></pre>\n<p>retval：需要传递一个指针作为返回值，可以在 pthread_join () 中获取到</p>\n<pre><code class=\"language-C++\">pthread_t pthread_self(void);\npthread_self();\n</code></pre>\n<p>获取当前的线程的线程 ID</p>\n<pre><code class=\"language-C++\">pthread_exit(NULL);\n</code></pre>\n<p>由于 return 0 会让进程退出，那所有线程资源都会被释放，因此可以在主线程中调用，让其他线程继续执行，单独<strong>让主线程退出，当主线程退出时，不会影响其他正常运行的线程</strong></p>\n<h2 id=\"互斥量\"><a class=\"anchor\" href=\"#互斥量\">#</a> 互斥量</h2>\n<p>确保同时仅有一个线程可以访问某共享资源，保证对共享资源的原子访问。</p>\n<p>互斥量有两种状态：已锁定和未锁定。至多只有一个线程可以锁定该互斥量。只有所有者才能给互斥量解锁</p>\n<p><strong>创建互斥量类型 pthread_mutex_t</strong>：一般在全局创建，在主函数 main 中初始化</p>\n<p><strong>初始化互斥量</strong></p>\n<pre><code class=\"language-C++\">int pthread_mutex_init(pthread_mutex_init *restrict mutex, const pthread_mutexattr_t attr);\n</code></pre>\n<p>mutex：需要初始化的互斥量变量 attr：互斥量相关的属性，默认 NULL</p>\n<p>restrict：C 语言修饰符，被修饰的指针不能由另外的一个指针进行操作</p>\n<p><strong>释放互斥量的资源</strong></p>\n<pre><code class=\"language-C++\">int pthread_mutex_destroy(pthread_mutex_init * mutex);\n</code></pre>\n<p><strong>加锁：阻塞的</strong>：如果已经有一个线程加锁了，那么其他线程只能阻塞等待</p>\n<pre><code class=\"language-C++\">int pthread_mutex_lock(pthread_mutex_init * mutex);\n</code></pre>\n<p><strong>解锁</strong></p>\n<pre><code class=\"language-C++\">int pthread_mutex_unlock(pthread_mutex_init * mutex);\n</code></pre>\n<h2 id=\"条件变量互斥锁\"><a class=\"anchor\" href=\"#条件变量互斥锁\">#</a> 条件变量 + 互斥锁</h2>\n<p>条件变量其实就是一种通知机制：当线程发现资源被锁定时条件变量就会将其阻塞，让出 CPU 的控制权给其他线程，当资源被释放时，那些阻塞线程被唤醒，线程重新检查资源可用性，从而获得资源并上锁或是重新阻塞。因此条件变量是一种通知模型的同步方式。</p>\n<p>条件变量一般是用于<strong>让生产者线程和消费者线程之间以及消费者线程之间互斥的访问临界资源</strong>（临界资源指的是<strong>同时只允许一个线程访问的共享资源</strong>）。条件变量的使用一般是需要结合互斥锁来进行（条件变量相关函数的输入参数就是互斥锁），从而使得各个线程能够互斥的访问该临界资源。</p>\n<p>想办法：当资源上的锁被释放时就通知等待该资源的线程，当有线程正在使用资源时就将其他想访问该资源的线程阻塞呢</p>\n<h3 id=\"二-条件变量的使用\"><a class=\"anchor\" href=\"#二-条件变量的使用\">#</a> 二 条件变量的使用</h3>\n<p>条件变量在 pthread.h 头文件中。</p>\n<h4 id=\"21-条件变量的初始化\"><a class=\"anchor\" href=\"#21-条件变量的初始化\">#</a> 2.1 条件变量的初始化</h4>\n<pre><code class=\"language-C++\">int pthread_cond_init(pthread_cond_t* *cond,const pthread_condattr_t* *cond_attr);\n</code></pre>\n<p>函数功能：用于初始化一个条件变量。</p>\n<p>函数参数：</p>\n<p>1.cond：用于指向目标条件变量。</p>\n<p>2.cond_attr：用于设置条件变量属性，置 NULL 表示条件变量属性为默认值。</p>\n<h4 id=\"22-条件变量的销毁\"><a class=\"anchor\" href=\"#22-条件变量的销毁\">#</a> 2.2 条件变量的销毁</h4>\n<pre><code class=\"language-C++\">int pthread_cond_destroy(pthread_cond_t*cond);\n</code></pre>\n<p>函数功能：用于销毁条件变量。</p>\n<h4 id=\"23-条件变量的通知机制\"><a class=\"anchor\" href=\"#23-条件变量的通知机制\">#</a> 2.3 条件变量的通知机制</h4>\n<pre><code class=\"language-C++\">int pthread_cond_signal(pthread_cond_t**cond);\nint pthread_cond_broadcast(pthread_cond_t**cond);\n</code></pre>\n<p><strong>函数功能：</strong></p>\n<p>条件变量的通知方法有两种：</p>\n<p>1. 根据线程的优先级和调度策略唤醒一个等待条件变量的线程的 pthread_cond_signal () 函数</p>\n<p>2. 唤醒所有等待条件变量的线程的 pthread_cond_broadcast () 函数。</p>\n<h4 id=\"24-条件变量的等待\"><a class=\"anchor\" href=\"#24-条件变量的等待\">#</a> 2.4 条件变量的等待</h4>\n<pre><code class=\"language-C++\">int pthread_cond_wait(pthread_cond_t**cond，pthread_mutex_t* *mutex);\nint pthread_cond_timedwait(pthread_cond_t*cond，pthread_mutex_t *mutex,const struct timespec *abstime);\n</code></pre>\n<p><strong>pthread_cond_wait</strong> 函数功能：调用该函数的线程会阻塞等待</p>\n<p>当没有容器内数据了，用于<strong>阻塞等待生产者生产数据，直到符合某个条件变量</strong>即被其他线程调用 pthread_cond_signal 唤醒才继续执行。函数的内部实现机制是：</p>\n<ul>\n<li>1. 当调用该函数前，一般会判断某个临界资源是否满足要求，如果不满足，则调用该函数，函数内部实现：<strong>将该线程挂起放在条件变量的请求队列，然后解除互斥锁</strong>（以便生产者拿到锁去生产数据）；</li>\n<li>2. 当该<strong>线程被唤醒不阻塞时，会再次对互斥锁加锁</strong>，然后返回，从而继续判断临界资源是否满足条件。</li>\n</ul>\n<p>pthread_cond_timedwait 函数功能：等待多长时间，调用了这个函数，线程会阻塞，直到指定时间结束</p>\n<h4 id=\"25-条件变量为什么要和互斥锁结合使用\"><a class=\"anchor\" href=\"#25-条件变量为什么要和互斥锁结合使用\">#</a> 2.5 条件变量为什么要和互斥锁结合使用</h4>\n<p>我个人的理解是，<strong>条件变量主要是使用一种通知机制来让各个线程来处理临界资源，但是为了保证线程安全，需要使得各个线程来互斥的访问临界资源</strong>：</p>\n<p>如果没有互斥锁，则：</p>\n<p>1. 调用条件变量通知函数唤醒所有的等待线程的话，很有可能导致临界资源被多个线程重复处理，甚至导致错误的发生，因此为了方便，每个线程被唤醒返回 pthread_cond_wait () 函数时，一般会对互斥锁加锁，这样其他被唤醒的线程只能阻塞等待此线程释放该互斥锁，从而实现互斥的对于临界资源的访问。</p>\n<p>2. 当此<strong>线程处理完临界资源后</strong>会在此调用 pthread_cond_wait () 函数，<strong>将该线程挂起至等待条件变量队列</strong>，然后释放互斥锁，让其他线程被唤醒继续处理该临界资源。</p>\n<h3 id=\"问题集\"><a class=\"anchor\" href=\"#问题集\">#</a> 问题集：</h3>\n<p><strong> <code>pthread_cond_wait内部为什么要解锁？</code> </strong></p>\n<p>如果 while 或者 if 判断的时候，满足执行条件，线程便会调用 pthread_cond_wait 阻塞自己，此时它还在持有锁，如果他不解锁，那么其他线程将会无法访问公有资源。</p>\n<p>具体到 pthread_cond_wait 的内部实现，当 pthread_cond_wait 被调用线程阻塞的时候，pthread_cond_wait 会自动释放互斥锁。</p>\n<p><strong> <code>为什么要把调用线程放入条件变量的请求队列后再解锁？</code> </strong></p>\n<p>线程是并发执行的，如果在把调用线程 A 放在等待队列之前，就释放了互斥锁，这就意味着其他线程比如线程 B 可以获得互斥锁去访问公有资源，这时候线程 A 所等待的条件改变了，但是它<strong>没有被放在等待队列上，导致 A 忽略了等待条件被满足的信号。</strong></p>\n<p>倘若在线程 A 调用 pthread_cond_wait 开始，到把 A 放在等待队列的过程中，都持有互斥锁，其他线程无法得到互斥锁，就不能改变公有资源。</p>\n<p><strong> <code>为什么最后还要加锁？</code> </strong></p>\n<p>将线程放在条件变量的请求队列后，将其解锁，此时等待被唤醒，若成功竞争到互斥锁，再次加锁。</p>\n<p><strong> <code>为什么判断线程执行的条件用while而不是if？</code> </strong></p>\n<p>一般来说，在多线程资源竞争的时候，在一个使用资源的线程里面（消费者）判断资源是否可用，不可用，便调用 pthread_cond_wait，在另一个线程里面（生产者）如果判断资源可用的话，则调用 pthread_cond_signal 发送一个资源可用信号。</p>\n<p>在 wait 成功之后，资源就一定可以被使用么？答案是否定的，如果同时有两个或者两个以上的线程正在等待此资源，wait 返回后，资源可能已经被使用了。</p>\n<p>再具体点，<strong>有可能多个线程都在等待这个资源可用的信号，信号发出后只有一个资源可用</strong>，但是有 A，B 两个线程都在等待，B 比较速度快，获得互斥锁，然后加锁，消耗资源，然后解锁，<strong>之后 A 获得互斥锁，但 A 回去发现资源已经被使用了</strong>，它便有两个选择，一个是去访问不存在的资源，另一个就是继续等待，那么<strong>继续等待下去的条件就是使用 while</strong>，要不然使用 if 的话 pthread_cond_wait 返回后，就会顺序执行下去。</p>\n<p>所以，在这种情况下，应该使用 while 而不是 if:</p>\n<pre><code class=\"language-C++\">while(resource == FALSE)  \npthread_cond_wait(&amp;cond, &amp;mutex);\n</code></pre>\n<p>如果只有一个消费者，那么使用 if 是可以的。</p>\n<h2 id=\"信号量\"><a class=\"anchor\" href=\"#信号量\">#</a> 信号量</h2>\n<p>本身不能保证线程安全，需要和互斥锁一起使用</p>\n<p><strong>信号量初始化</strong></p>\n<pre><code class=\"language-C++\">int sem_init(sem_t *sem,int pshared,unsigned int value);\n</code></pre>\n<p>value：设置信号量中的值，表示可用的资源个数。类比灯泡用一个灭一个 sem：信号量变量的地址 pshared：代表这个变量是用在线程之间（0）还是进程之间（非 0）</p>\n<p>** 加锁一个信号量：**<strong> 阻塞函数 - 对信号量值减一</strong>：当调用的信号量 sem 中的值 value 为 0 时才阻塞，<strong> 调用一次 wait，value 值 - 1</strong></p>\n<pre><code class=\"language-C++\">int sem_wait(sem_t *sem);\n</code></pre>\n<p><strong>解锁一个信号量</strong>：<strong>增加信号量的值</strong>：<strong>调用一次 value+1</strong></p>\n<pre><code class=\"language-C++\">int sem_post(sem_t *sem);\n</code></pre>\n<p><strong>释放资源</strong></p>\n<pre><code class=\"language-C++\">int sem_destroy(sem_t *sem);\n</code></pre>\n",
            "tags": [
                "C++",
                "项目",
                "Linux高性能服务器编程",
                "C++",
                "项目",
                "Linux高性能服务器编程"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/11/15/cpp/%E5%8D%8A%E5%90%8C%E6%AD%A5-%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E7%BA%BF%E7%A8%8B%E6%B1%A0/",
            "url": "https://aristotlednzk.github.io.com/2022/11/15/cpp/%E5%8D%8A%E5%90%8C%E6%AD%A5-%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E7%BA%BF%E7%A8%8B%E6%B1%A0/",
            "title": "半同步/半反应堆线程池",
            "date_published": "2022-11-15T03:17:40.000Z",
            "content_html": "<h2 id=\"两种高效的事件处理事件分发模式\"><a class=\"anchor\" href=\"#两种高效的事件处理事件分发模式\">#</a> 两种高效的事件处理（事件分发）模式</h2>\n<ul>\n<li>Reactor 模式（反应堆）—— 依赖同步 IO，主线程中处理 IO，监听就绪事件的发生，然后通知工作线程进行读写数据（IO 操作）+ 读写完成后的处理逻辑</li>\n<li>Proactor 模式（前摄器）—— 依赖异步 IO，主线程和内核处理全部的 IO（包括读写数据），监听完成事件（异步 IO 产生的是完成信号，即信号产生时读写已经完成）的发生，然后通知工作线程进行读写完成后的处理逻辑</li>\n<li>模拟 Proactor 模式 —— Linux 中没有真正的异步 IO，AIO（aio_read 等）内部是用 pthread 模拟的（多线程 + 请求队列 + 信号等）。故使用同步 IO 来模拟 Proactor 的模式，即称为模拟 Proactor。\n<ul>\n<li>模拟 Proactor 与 Proactor 的区别是：前者的数据读写由用户完成，后者的数据读写由内核完成；</li>\n<li>模拟 Proactor 与 Proactor 的共同点是：通知给工作线程的都是完成事件，以此避免了工作线程中的读写操作（IO 操作</li>\n</ul>\n</li>\n</ul>\n<hr />\n<h2 id=\"两种高效的并发模式\"><a class=\"anchor\" href=\"#两种高效的并发模式\">#</a> 两种高效的并发模式：</h2>\n<ol>\n<li>半同步 / 半异步模式</li>\n<li>领导者 / 追随者模式</li>\n</ol>\n<p>并发模式：多个逻辑单元和 IO 处理单元之间协调完成任务的方法</p>\n<ol>\n<li>IO 模型中：同步 / 异步\n<ul>\n<li>同步 / 异步区分的是内核向应用程序通知的是何种 IO 事件（就绪 / 完成事件），以及该由谁来完成 IO 读写（应用程序还是内核）</li>\n</ul>\n</li>\n<li>并发模式中：同步 / 异步\n<ul>\n<li>同步是指程序完全按照<strong>代码序列的顺序</strong>执行</li>\n<li>异步是指程序的执行需要由<strong>系统事件来驱动</strong>（中断、信号）</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>服务器适合半同步 / 半异步模式！ 同步线程：按照同步方式运行的线程 异步线程效率更高</p>\n</blockquote>\n<h2 id=\"半同步半异步模式\"><a class=\"anchor\" href=\"#半同步半异步模式\">#</a> 半同步 / 半异步模式</h2>\n<p>同步线程用于处理客户逻辑</p>\n<p>异步线程用于处理 IO 事件：</p>\n<ul>\n<li>异步线程监听到客户请求就将其封装成请求对象插入到请求队列</li>\n<li>请求队列通知某个工作在同步模式的工作进程来读取并处理该请求对象</li>\n</ul>\n<blockquote>\n<p>具体选择哪个工作线程取决于请求队列的设计：轮流选取 Round Robin、条件变量 + 信号量随机选取</p>\n</blockquote>\n<hr />\n<ul>\n<li>半同步 / 半异步模式 —— 同步线程与异步线程结合的模式</li>\n<li>Reactor 和 Proactor 都属于半同步 / 半异步模式</li>\n</ul>\n<p>半同步 / 半异步模式中异步线程怎么分发任务给同步线程呢？（即怎么协同处理事件呢）：</p>\n<ul>\n<li>用 Reactor 模式分发 —— 半同步 / 半反应器模式</li>\n<li>用模拟 Proactor 模式分发 —— 半同步 / 半模拟前摄器模式（这个模式是我自己造的，为了分清楚概念而已）</li>\n</ul>\n<p>我的理解：</p>\n<ol>\n<li>从游双老师书上的描述来看，Reactor 和 Proactor 模式应该都是属于半同步 / 半异步模式的（Reactor 和 Proactor 都是一个异步线程分发任务给其他同步线程，与不分发任务的领导者 / 追随者模式有着本质上的不同，它们显然都是半同步 / 半异步的模式）。</li>\n<li>因此，Reactor 和 Proactor 模式又像是 “半同步 / 半异步模式” 的子分类。书上是这样描述的：“结合考虑两种事件处理模式… 半同步 / 半异步模式就存在多种变体，其中一种就是半同步 / 半反应堆模式”，意思就是 “半同步 / 半异步模式 + Reactor 模式 = 半同步 / 半反应堆模式（half-sync/half-reactive）”</li>\n</ol>\n<h3 id=\"半同步半反应堆模式\"><a class=\"anchor\" href=\"#半同步半反应堆模式\">#</a> 半同步 / 半反应堆模式</h3>\n<p><img data-src=\"/2022/11/15/cpp/%E5%8D%8A%E5%90%8C%E6%AD%A5-%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E7%BA%BF%E7%A8%8B%E6%B1%A0/image.png\" class=\"\" title=\"img\"></p>\n<p>异步线程只有一个由主线程充当，负责监听所有 socket 上的事件：</p>\n<ol>\n<li>如果监听 socket 上有<strong>可读事件发生</strong>，即有新的连接请求到来，接收连接并向 epoll 内核事件表注册该 socket 上的读写事件。</li>\n<li>如果<strong>连接</strong> socket 上有<strong>读写事件发生</strong>，即有新的客户请求到来或有数据要发送至客户端。 模拟 Proactor 中：主线程首先循环读取数据完毕，随后将读取的数据封装成请求对象<strong>插入请求队列</strong>中。</li>\n<li>所有工作线程睡眠在请求队列上，当有任务到来时它们将通过竞争获取任务的接管权，从请求队列中取出任务对象直接处理无需读写操作。</li>\n</ol>\n<blockquote>\n<p>半同步 / 半反应堆模式缺点：</p>\n</blockquote>\n<ol>\n<li>主线程和工作线程共享请求队列，因此主线程往请求队列中添加任务或工作线程从请求队列中取出任务都需要对请求队列加锁保护。浪费 CPU 时间</li>\n<li>每个工作线程在同一时间只能处理一个客户请求，如果客户数量 &gt; 工作线程数→导致请求队列中任务堆积，客户端响应速度会越来越慢</li>\n</ol>\n<p><strong>改进方案：</strong></p>\n<p>主线程只负责监听 socket，连接 socket 由工作线程管理</p>\n<p>当有新连接到来时，主线程接收，并通过<strong>向管道写数据的方式</strong>将新返回的连接发给某个工作线程，该连接 socket 上的任何 IO 操作都由工作线程处理。工作线程检测到有数据可读就将连接 socket 上的读写事件注册到<strong>自己的 epoll 内核事件表</strong>。</p>\n<p><img data-src=\"/2022/11/15/cpp/%E5%8D%8A%E5%90%8C%E6%AD%A5-%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-16684823541241.png\" class=\"\" title=\"img\"></p>\n<h3 id=\"领导者追随者模式\"><a class=\"anchor\" href=\"#领导者追随者模式\">#</a> 领导者 / 追随者模式</h3>\n<p>含义：多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。 包含组件：句柄集、线程集、事件处理器、具体事件处理器</p>\n<p>任意时间点都只有一个领导者线程：负责监听 IO 事件，其他线程都是追随者，它们休眠在线程池等待成为新的领导者。</p>\n<ul>\n<li>当前领导者如果检测到 IO 事件，首先从线程池推选出新的领导者线程，然后处理 IO 事件</li>\n<li>此时新领导者等待新的 IO 事件，旧领导者处理 IO 事件，二者形成并发</li>\n</ul>\n<hr />\n<h2 id=\"有限状态机用于http请求的读取和分析\"><a class=\"anchor\" href=\"#有限状态机用于http请求的读取和分析\">#</a> 有限状态机：用于 HTTP 请求的读取和分析</h2>\n<p>之前探讨了关于服务器的 IO 处理单元、请求队列和逻辑单元之间协调完成任务的各种模式。</p>\n<p>现在介绍逻辑单元内部高效编程方法：有限状态机：</p>\n<p>主状态机有三种可能状态：当前正在分析<strong>请求行</strong>、当前正在分析<strong>头部字段</strong>、当前正在分析<strong>消息体</strong> 从状态机有三种可能状态（行的读取状态）：<strong>读到一个完整的行</strong>、行出错、行数据尚不完整</p>\n<p>从状态机用于解析出一行内容，</p>\n<ul>\n<li>判断 HTTP 头部结束的一句是遇到一个空行，该空行仅包含一对回车换行符 (\\r  和  \\n)。</li>\n<li>如果一次读操作没有读入 HTTP 请求的整个头部，即没有遇到空行那么必须等待客户继续写数据再次读入，返回 LINE_OPEN。因此每完成一次读操作就需要分析读入的数据是否有空行。</li>\n<li>在寻找空行的过程中，我们可以同时完成对整个 HTTP 请求头部的分析</li>\n</ul>\n<p>主状态机在内部调用从状态机:</p>\n<ol>\n<li>分析从状态机，parse_line 函数：它从 buffer 中解析出一个行。从状态机初始状态是 LINE_OK，原始驱动力来自于 buffer 中新到达的客户数据。</li>\n<li>在 main 函数中循环调用 recv 函数往 buffer 中读入客户数据，每次成功读取数据后就调用 process_read 函数来分析新读入的数据。\n<ul>\n<li>process_read 作为分析 http 请求的入口函数</li>\n<li>process_read 函数首先调用 parse_line 函数来获取一个行，当读取到一个完整的行后 parse_line 函数就可以将这行内容交给 process_read 函数中的主状态机来处理了。</li>\n</ul>\n</li>\n</ol>\n<p><img data-src=\"/2022/11/15/cpp/%E5%8D%8A%E5%90%8C%E6%AD%A5-%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-16684823541242.png\" class=\"\" title=\"img\"></p>\n<p>parse_line<strong> 只是提取出一行</strong>，并不解析其中内容</p>\n<p>parse_request_line<strong> 解析 http 请求行，获得请求方法，目标 url 及 http 版本号</strong> parse_headers<strong> 解析 http 请求的一个头部信息</strong> parse_content<strong> 解析 http 请求的消息体</strong></p>\n<ol>\n<li>主状态机初始状态为 CHECK_STATE_REQUESTLINE</li>\n<li>如果主状态机当前状态为 CHECK_STATE_REQUESTLINE，说明 parse_line 解析出的行是请求行，调用 parse_request_line 函数处理，分析完请求后将主状态机设置为 CHECK_STATE_HEADER 实现状态转移</li>\n<li>如果主状态机当前状态为 CHECK_STATE_HEADER，说明 parse_line 解析出的行是请求头部，调用 parse_headers 函数处理，并将主状态机设置为 CHECK_STATE_CONTENT</li>\n</ol>\n<h3 id=\"流程\"><a class=\"anchor\" href=\"#流程\">#</a> 流程：</h3>\n<p>浏览器端发出 HTTP 请求报文，服务器端接收该报文并<strong>调用 process_read 对其进行解析</strong>，根据解析结果 HTTP_CODE 做出响应，process_write () 填写相应的回复到缓冲区。</p>\n<h2 id=\"池\"><a class=\"anchor\" href=\"#池\">#</a> 池</h2>\n<p>并发编程：进程池、线程池</p>\n<blockquote>\n<p>当需要一个工作线程、进程来处理新到来的客户请求时可以直接从进程池、线程池中取得一个执行实体，无序动态调用 fork 或 pthread_create 函数创建</p>\n</blockquote>\n<p>连接池</p>\n<blockquote>\n<p>连接池是服务器预先和数据库程序建立的一组连接的集合。 当某个逻辑单元需要访问数据库时，它可以直接从连接池中取得一个连接的实体并使用，完成访问后逻辑单元再将该连接还给连接池</p>\n</blockquote>\n<hr />\n",
            "tags": [
                "C++",
                "项目",
                "C++",
                "项目"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/11/15/cpp/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/",
            "url": "https://aristotlednzk.github.io.com/2022/11/15/cpp/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/",
            "title": "IO多路复用",
            "date_published": "2022-11-15T03:16:14.000Z",
            "content_html": "<p>epoll_create 创建一个新的 epoll 实例，返回指向该实例的描述符 epollfd 用来调用所有 epoll 相关接口。在<strong>内核中创建了一个数据</strong>，这个数据中有两个比较重要的数据，一个是<strong>需要检测的文件描述符的信息</strong>（红黑树），还有一个是<strong>就绪列表</strong>，<strong>存放检测到数据发生改变的文件描述符信息</strong>（双向链表）。</p>\n<p>当 epollfd 不再使用时，需要调用 close () 关闭，当指向 epoll 的文件描述符关闭后内核会摧毁 epoll 实例并释放相关资源。</p>\n<p>epoll_ctl: 将哪个客户端 fd 的哪些事件 event 交给哪个 epoll (epollfd) 来管理（增删改）</p>\n<p>什么时候将就绪的客户端 fd 添加到就绪事件链表？ 当内核监听到有<strong>就绪事件中断</strong>时就会将就绪事件<strong>从红黑树迁移一份到就绪事件链表</strong>中</p>\n<p><img data-src=\"/2022/11/15/cpp/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/image.png\" class=\"\" title=\"img\"></p>\n<p><img data-src=\"/2022/11/15/cpp/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/image-16684834064061.png\" class=\"\" title=\"img\"></p>\n<p><img data-src=\"/2022/11/15/cpp/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/image-16684834064062.png\" class=\"\" title=\"img\"></p>\n",
            "tags": [
                "C++",
                "项目",
                "Linux高性能服务器编程",
                "C++",
                "项目"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/11/15/computer-science/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/",
            "url": "https://aristotlednzk.github.io.com/2022/11/15/computer-science/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/",
            "title": "单例模式",
            "date_published": "2022-11-15T03:07:24.000Z",
            "content_html": "<p>考察：要求实现各种变形，懒汉式、饿汉式</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXprek56SXpOakk0Tnc9PSZhbXA7bWlkPTIyNDc0ODU3MjImYW1wO2lkeD0xJmFtcDtzbj1lMzE1YTlmM2U4OTNkYjk4Mjc2YTE4MTE3YTI0NjEyZSZhbXA7c291cmNlPTQxI3dlY2hhdF9yZWRpcmVjdA==\">https://mp.weixin.qq.com/s?__biz=MzkzNzIzNjI4Nw==&amp;mid=2247485722&amp;idx=1&amp;sn=e315a9f3e893db98276a18117a24612e&amp;source=41#wechat_redirect</span></p>\n<p>有时候我们想让一个类能够保证自己仅仅能生成一个实例化对象  (对应上面的窗口类去保证自己创建对象时候的唯一性)  ，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p>\n<h2 id=\"单例模式的设计思路\"><a class=\"anchor\" href=\"#单例模式的设计思路\">#</a> <strong>单例模式的设计思路</strong></h2>\n<p>应该怎么保证上面窗口类在按钮类的回调函数里面调用的时候<br />\n能够 不用 if else 判断 而由窗口类对象自己去保证唯一性呢？</p>\n<p>第一步</p>\n<pre><code>首先应该不能让外界调用new的方式去创建他的对象 因为如果这样的话   外部还是可以产生多个对象了。\n我们还是得引入if else来判断 ,\n所以我们就应该阻止其他程序建立对象,   阻止的方式就是把构造函数声明为私有\n</code></pre>\n<p>第二步</p>\n<p>其次应该让这个窗口类对象应在作为静态成员对象声明在自己类的内部声明 因为这样的话 我们就可以在类里面实现对这个对象的唯一性判断 (由于它是静态的 各个类对象之间会共有这一个成员对象)</p>\n<p>第三步</p>\n<p>最后 应该在判断完这个静态成员类对象唯一以后应该有一个全局唯一接口 (静态成员函数) 让外面访问这个对象</p>\n<p>总结一下实现步骤： 1.<strong> 私有化构造函数，不让其他程序创建的对象初始化。</strong> 2.<strong> 在本类中 new 一个静态本类对象。</strong> 3. 定义一个静态成员函数，它的功能是让其他程序可以通过这个函数获取到本类的对象。</p>\n<h3 id=\"饿汉式\"><a class=\"anchor\" href=\"#饿汉式\">#</a> 饿汉式：</h3>\n<p><strong>1. 资源的占用:</strong></p>\n<p>饿汉模式 在类创建的就得 new 好它的静态成员对象 故占用空间</p>\n<p><strong>2. 类中静态成员 初始化顺序不确定所导致的异常.</strong></p>\n<p>也就是说类中的两个静态成员</p>\n<p>getInstance 和 Instance 不同编译单元中的初始化顺序是未定义的，</p>\n<p>如果在 Instance 初始化完成之前调用</p>\n<p>getInstance () 方法会返回一个未定义的实例</p>\n<p>由于要进行线程同步，所以在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能。这是以空间换时间</p>\n<pre><code class=\"language-C++\">class Singleton\n&#123;\n    //1.声明构造函数为私有\n    private:\n    Singleton()&#123;&#125;;\n    //2.声明一个本类的对象\n    private:\n    static Singleton* instance;\n    //3.对外提供本类对象的公共接口\n    public:\n    static Singleton* getInstance() \n    &#123;\n        return instance;\n    &#125;\n&#125;;\nSingleton* Singleton::instance=new Singleton;\n</code></pre>\n<ul>\n<li>静态成员函数</li>\n</ul>\n<ol>\n<li><strong>静态成员函数可以在类内直接定义也可以在类外定义（初始化 / 实现），在类外实现时不需要加 static。</strong></li>\n<li>静态成员函数只能访问静态数据成员和静态成员函数，普通成员函数可以访问静态成员函数和静态数据成员</li>\n<li>静态成员函数属于类，不属于任意一个类对象</li>\n<li>静态成员函数没有 this 指针</li>\n<li>可以使用 &lt;类名&gt;::&lt; 函数名 &gt; 访问，也可由类对象使用 (./-&gt;) 访问</li>\n</ol>\n<blockquote>\n<p>第一条解释：不能在类声明中初始化静态成员变量，因为声明描述了如何分配内存，但不分配内存。静态类成员位于 ** 静态存储区，*<em> 并 *<em> 不是类对象的组成部分</em></em>，所以需要在类声明之外使用单独的语句进行初始化。在类声明中不可初始化静态数据成员的一种例外情况是，静态数据成员为整型或枚举型 const。</p>\n</blockquote>\n<ul>\n<li>静态数据成员</li>\n</ul>\n<ol>\n<li>对于类静态数据成员，无论有多少个该类的对象，该静态数据成员在内存中只有一份拷贝 (其他普通数据成员，每个类对象都有自己的内存拷贝)，该静态数据成员由所有该类对象共享</li>\n<li>静态数据成员存储在全局数据区，在定义时分配存储空间，程序运行结束时销毁</li>\n<li><strong>静态数据成员不能再类中定义和初始化，只能在类中声明，在类外进行定义和初始化，默认初始化为 0</strong></li>\n<li>静态数据成员的初始化为 &lt;类型名&gt; &lt; 类名 &gt;::&lt; 变量名 &gt; = &lt; 值 &gt;</li>\n<li>静态数据成员遵从 public private protected 访问规则</li>\n<li>静态数据成员可以直接使用类名加作用域运算符 (::) 直接访问 &lt; 类名 &gt;::&lt; 变量名 &gt;(访问规则允许的情况下)</li>\n</ol>\n<h3 id=\"懒汉式\"><a class=\"anchor\" href=\"#懒汉式\">#</a> 懒汉式：</h3>\n<pre><code class=\"language-C++\">class Singleton\n&#123;\n    //1.声明构造函数为私有\n    private:\n    Singleton()&#123;&#125;;\n    //2.声明一个本类的对象\n    private:\n    static Singleton* instance;\n    //3.对外提供本类对象的公共接口\n    public:\n    static Singleton* getInstance() \n    &#123;\n        if(instance==NULL)\n        &#123;\n            instance=new Singleton;\n        &#125;\n    return instance;\n    &#125;\n&#125;;\nSingleton* Singleton::instance=NULL;\n</code></pre>\n<p><strong>1. 内存泄露</strong></p>\n<p>①析构函数没有被执行：</p>\n<p>程序退出时，析构函数没被执行.</p>\n<p>这在某些设计不可靠的系统上会导致资源泄漏，</p>\n<p>想一想上面的 Instance 指向的空间什么时候释放呢？</p>\n<p>更严重的问题是，该实例的析构函数什么时候执行？</p>\n<p>如果在类的析构行为中有必须的操作，</p>\n<p>比如关闭文件，释放外部资源，那么上面的代码无法实现这个要求。</p>\n<p>我们需要一种方法，正常的删除该实例。</p>\n<p>**2. 线程安全  **</p>\n<p>②线程不安全：我们注意到在 static Singleton* getInstance () 方法中，<br />\n是通过 if 语句判断 静态实例变量 是否被初始化来觉得是否进行初始化，<br />\n那么在多线程中就有可能出现多次初始化的问题。<br />\n比方说，有两个多线程同时进入到这个方法中，<br />\n同时执行 if 语句的判断，<br />\n那么就会出现两次两次初始化静态实例变量的情况。</p>\n<h3 id=\"懒汉式线程安全\"><a class=\"anchor\" href=\"#懒汉式线程安全\">#</a> 懒汉式（线程安全）：</h3>\n<p>1.<strong> 用双重检测锁 DLC 解决线程安全</strong></p>\n<pre><code class=\"language-C++\">class Singleton \n&#123; \n  public: \n  static pthread_mutex_t mutex; \n  static Singleton* getInstance(); \n  protected: //定义线程互斥锁\n  Singleton() \n  &#123; \n      pthread_mutex_init(&amp;mutex); \n  &#125; \n  private: \n  static Singleton* p; \n&#125;; \n  pthread_mutex_t Singleton::mutex; //初始化互斥锁\n  Singleton* Singleton::p = NULL; //类外初始化静态指针：通过作用域调用\n  Singleton* Singleton::getInstance() //获取实例\n  &#123; \n      if (NULL == p) \n      &#123; \n          pthread_mutex_lock(&amp;mutex); \n          if (NULL == p) \n              p = new Singleton(); \n          pthread_mutex_unlock(&amp;mutex); \n      &#125; \n      return p; \n  &#125;\n</code></pre>\n<p><strong>2. 内部静态变量实现懒汉模式</strong></p>\n<pre><code class=\"language-C++\">class Singleton \n&#123; \n    public: \n    static pthread_mutex_t mutex; //静态成员：互斥锁变量\n    static Singleton* getInstance(); //静态成员函数\n    protected: \n    Singleton() \n    &#123; \n        pthread_mutex_init(&amp;mutex); \n    &#125; \n&#125;; \npthread_mutex_t Singleton::mutex; //类外初始化\nSingleton* Singleton::getInstance() //类外定义/实现\n**&#123; **\n    pthread_mutex_lock(&amp;mutex); \n**    static singleton ss; **\n    pthread_mutex_unlock(&amp;mutex); \n**    return &amp;ss; **\n&#125;\n</code></pre>\n<p>简单工厂模式：</p>\n<p>1. 实现了客户端和创建对象的工厂类打交道（传入参数让工厂直到应该创建什么类型的对象），与具体实现类的解耦。<br />\n2. 增加新的功能是通过修改源代码实现，不符合开闭原则</p>\n",
            "tags": [
                "转码之路",
                "设计模式",
                "转码之路",
                "设计模式"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/11/10/cpp/Tinywebserver%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/",
            "url": "https://aristotlednzk.github.io.com/2022/11/10/cpp/Tinywebserver%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/",
            "title": "Tinywebserver项目记录",
            "date_published": "2022-11-10T10:49:44.000Z",
            "content_html": "<h1 id=\"partimywebserver\"><a class=\"anchor\" href=\"#partimywebserver\">#</a> PartⅠ：mywebserver</h1>\n<h2 id=\"一-lockerhlockercpp-与tiny相同\"><a class=\"anchor\" href=\"#一-lockerhlockercpp-与tiny相同\">#</a> 一、locker.h，locker.cpp （与 Tiny 相同）</h2>\n<p><strong>互斥锁类 locker</strong><br />\n&lt;u&gt; 用于内存池 &lt;/u&gt;：请求队列（工作队列）的互斥访问</p>\n<p>向工作队列中添加任务 append () 时，会访问 / 修改请求队列</p>\n<p>线程中运行的主要逻辑：从请求队列中取出请求并执行其 process () 函数，故会访问 / 修改请求队列</p>\n<p><strong>条件变量类 cond</strong><br />\n 项目中没有用到</p>\n<p><strong>信号量类 sem</strong><br />\n&lt;u&gt; 用于内存池 &lt;/u&gt;：<strong>请求队列 —— 生产者消费者模型</strong></p>\n<p>append () 向请求队列中添加请求，则信号量 ++（post ()）</p>\n<p>run () 从请求队列中取出请求，则信号量–（wait ()）</p>\n<h2 id=\"二-threadpoolh-线程池\"><a class=\"anchor\" href=\"#二-threadpoolh-线程池\">#</a> 二、threadpool.h 线程池</h2>\n<p>创建多个线程<br />\n创建一定数量（m_thread_number）的线程（pthread_create ()），线程的入口函数 worker () 需要是静态函数，原因：</p>\n<ul>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mjc0NTAxL2FydGljbGUvZGV0YWlscy8xMTcwODMxNzU/dXRtX21lZGl1bT1kaXN0cmlidXRlLnBjX3JlbGV2YW50Lm5vbmUtdGFzay1ibG9nLWJhaWR1anNfYmFpZHVsYW5kaW5nd29yZC0wJmFtcDtzcG09MTAwMS4yMTAxLjMwMDEuNDI0Mg==\">https://blog.csdn.net/qq_39274501/article/details/117083175?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&amp;spm=1001.2101.3001.4242</span></p>\n</li>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvUEI4dk13aThzQjRKdzNXekFLcFdPUQ==\">https://mp.weixin.qq.com/s/PB8vMwi8sB4Jw3WzAKpWOQ</span></p>\n</li>\n<li>\n<p>类中调用 pthread_create () 时，类的成员函数作为 pthread_create () 的参数时，必须是静态函数</p>\n</li>\n<li>\n<p>因为类的成员函数有一个隐藏的参数 ——this 指针，而线程的入口函数必须是接受一个 void 指针作为参数，故入口函数的参数中有一个隐藏的 this 指针是不允许的。为了解决矛盾，我们使用 static 成员函数，其独立于实例，参数中不会有 this 指针，故其可以用作线程的入口函数</p>\n</li>\n</ul>\n<p><strong>将线程设为脱离</strong><br />\n创建线程后，将线程设为脱离（pthread_detach ()），这是为了自动回收线程资源</p>\n<p><code>pthread_detach()的作用——当线程终止时，线程的资源将会立即被回收，而不用等待另一个线程调用pthread_join</code> <br />\n <code>/* Indicate that the thread TH is never to be joined with PTHREAD\\_JOIN.   The resources of TH will therefore be freed immediately when it   terminates, instead of waiting for another thread to perform PTHREAD\\_JOIN   on it.  */</code> <br />\n <code>extern int pthread\\_detach (pthread\\_t \\_\\_th) \\_\\_THROW;</code></p>\n<p><strong>请求队列（工作队列）</strong><br />\n请求队列 —— 以队列形式组织，其实现了：<strong>将主线程和工作线程解耦</strong>（主线程向请求队列中添加任务，工作线程通过竞争来取得任务并执行任务）</p>\n<p>请求队列的访问：由于会有多个线程对其进行访问 / 修改，故通过<strong>互斥锁实现互斥访问</strong></p>\n<p>工作线程竞争请求队列中的任务：<strong>通过信号量实现生产者 / 消费者模型</strong>，任务交给哪个线程执行是随机的。（也可以用 Round Robin 算法让线程轮流获取任务）</p>\n<p><strong>工作线程们运行的函数</strong><br />\n worker ()-&gt;run ()</p>\n<ol>\n<li>worker ()：只是一个桥梁，静态成员函数，用作 pthread_create () 的参数；其中只是调用线程的主要逻辑 run ()</li>\n<li>run ()：类的成员函数，需要静态成员函数 worker () 作为媒介来成为线程的工作函数。其主要逻辑：&lt;u &gt; 竟态获取请求队列中的任务 &lt;/u&gt;，通过调用请求类的 process 函数处理请求，process 函数调用 process_read 函数和 process_write 函数分别完成报文解析与报文响应两个任务</li>\n</ol>\n<p><strong>只实现了 Proactor 模式</strong></p>\n<ol>\n<li>run () 中只执行 process () 过程，数据的读写是在主线程 main () 中完成的</li>\n<li>reactor 模式的实现 —— 把数据读写放到工作线程中完成就行了（参考 Tinywebserver）</li>\n</ol>\n<h2 id=\"三-maincpp\"><a class=\"anchor\" href=\"#三-maincpp\">#</a> 三、main.cpp</h2>\n<p><strong>网络编程常规步骤</strong><br />\n略</p>\n<p><strong>循环获取就绪事件并处理</strong><br />\n这便是主线程的主要工作逻辑。</p>\n<p>由于是 Proactor 模式，故可读可写事件发生时，main 中将数据读入 / 写出完毕，然后再通知工作线程进行后续逻辑处理</p>\n<p>由于该项目中，写完成后，没有后续的处理逻辑，故只有读完成后才会通知工作线程（将任务 append 到线程池的请求队列）</p>\n<p>项目中只实现了 LT+ONESHOT 模式。虽然是 LT 模式，但是由于是 ONESHOT，故也要用非阻塞 IO 循环读取以保证将 TCP 缓存中的数据全部读出。（在 ET 模式下，事件触发后需要将缓冲区中的数据完全读完，否则会陷入死锁，故必须要用非阻塞 IO 循环读取）。<br />\n为什么必须要用 ONESHOT 呢？（ONESHOT 的作用）——《Linux 高性能服务器编程》P157：</p>\n<ul>\n<li>即使是用 ET 模式，一个 socket 上的事件还是可能被触发多次（LT 模式则更是如此），这在并发编程中就会引起一个问题：socket 上的数据被获取后，一个线程开始处理数据（此时 HTTP 请求报文可能并不完整）；而在处理数据的过程中，又有新的数据可读（EPOLLIN 再次被触发），此时另一个线程被唤醒去处理新到来的数据。这就会出现同时有两个线程操作同一个 socket 的情况，这显然是不被期望的。</li>\n<li>正常情况应该是：数据到来–&gt; 数据被读入 socket 对应的 http_conn 类对象 H 中–&gt; 唤醒一个线程去操作这个类对象 H (处理数据)，数据处理过程中不应再次触发事件，避免又有另一个线程开始对该类对象 H 进行操作。</li>\n</ul>\n<h2 id=\"四-http_connhhttp_conncpp\"><a class=\"anchor\" href=\"#四-http_connhhttp_conncpp\">#</a> 四、http_conn.h，http_conn.cpp</h2>\n<h3 id=\"主要逻辑\"><a class=\"anchor\" href=\"#主要逻辑\">#</a> 主要逻辑</h3>\n<p>** 处理 HTTP 请求：** 通过主从状态机</p>\n<ol>\n<li>\n<p>process_read ()—— 正常流程下，process_read () 返回的是 do_request () 的结果</p>\n</li>\n<li>\n<p>parse_line()</p>\n</li>\n<li>\n<p>get_line()</p>\n</li>\n<li>\n<p>parse_request_line()</p>\n</li>\n<li>\n<p>parse_hearders()</p>\n</li>\n<li>\n<p>parse_content()</p>\n</li>\n</ol>\n<p><strong>do_request ()：根据 HTTP 请求的解析结果，进行处理得到后续生成响应所需的前提状态</strong></p>\n<ol>\n<li>\n<p>首先对 GET 请求和不同 POST 请求（登录，注册，请求图片，视频等等）做不同的预处理</p>\n</li>\n<li>\n<p>获取请求资源的信息，并判断请求的合法性：分析目标文件的属性，若目标文件存在、对所有用户可读且不是目录</p>\n</li>\n<li>\n<p>若合法：则将文件只读地打开，使用 mmap 将其映射到内存地址 m_file_address 处，并告诉调用者获取文件成功。</p>\n</li>\n</ol>\n<p><strong>处理 CGI</strong></p>\n<p>根据标志判断是登录检测还是注册检测</p>\n<p>将用户名和密码提取出来</p>\n<p><strong>生成 HTTP 响应数据并放入发送缓存</strong></p>\n<ul>\n<li>process_write ()—— 根据 process_read ()（do_request ()）获得的文件合法性，生成响应报文放入发送缓冲区，并设置发送缓冲区的标志信息</li>\n<li>process_write () 处理完成之后，注册 EPOLLOUT 事件，等待主线程调用 write () 发送缓冲区中的数据</li>\n</ul>\n<p><strong>其他函数</strong></p>\n<ul>\n<li>write ()—— 采用分散写 writev ()，客户请求的资源（响应体）和 process_write () 生成的报文数据（状态行和响应头），分别放在两块内存中，前者在文件映射到的内存中，后者在发送缓存中</li>\n<li>setnonblocking ()、addfd ()、removefd ()、modfd () 等 socket 编程常用函数也定义在 http_conn.cpp 中（因为类中也会用到这些函数）</li>\n</ul>\n<p><strong>有限状态机 - 处理 HTTP 请求中使用</strong></p>\n<ul>\n<li>\n<p>主状态机：当前解析到哪部分（请求首行、请求头部、请求体）</p>\n</li>\n<li>\n<p>第一行是首行，解析完直接跳到解析头部状态</p>\n</li>\n<li>\n<p>头部解析时若遇到空行，则说明头部解析完毕，若有请求体则跳到解析请求体状态（头部中会有 Content-Length 来告诉你有没有请求体）</p>\n</li>\n<li>\n<p>请求体解析</p>\n</li>\n<li>\n<p>从状态机：请求数据的每一行的处理状态（完整的一行、不完整的一行、错误的一行）</p>\n</li>\n<li>\n<p>请求分析结果状态机：用于标记请求报文解析的结果，并用于决定后续的报文解析和响应生成</p>\n</li>\n<li>\n<p>请求方法状态机：用于标记请求报文中的请求方法，该项目中只支持 GET</p>\n</li>\n</ul>\n<h2 id=\"partii整个项目的模型\"><a class=\"anchor\" href=\"#partii整个项目的模型\">#</a> PartⅡ：整个项目的模型</h2>\n<h3 id=\"一-mywebserver\"><a class=\"anchor\" href=\"#一-mywebserver\">#</a> 一、mywebserver：</h3>\n<ol>\n<li>并发模式：半同步 / 半反应堆模式 —— 我认为应该叫 “半同步 / 半模拟前摄器模式”</li>\n<li>事件处理（事件分发）模型：同步 IO 模拟的 Proactor 模型</li>\n</ol>\n<h3 id=\"二-tinywebserver\"><a class=\"anchor\" href=\"#二-tinywebserver\">#</a> 二、Tinywebserver：</h3>\n<ol>\n<li>并发模式：半同步 / 半反应堆模式、半同步 / 半模拟前摄器模式 都实现了（其实就是实现了下面的 Reactor 和模拟 Proactor）</li>\n<li>事件处理（事件分发）模型：同步 IO 模拟的 Proactor 模型、Reactor 模型 都实现了（通过 threadpool.h 中的 m_actor_model 变量实现选择用哪种模型，就是选择 read () 和 write () 在主线程完成还是工作线程完成而已）</li>\n</ol>\n",
            "tags": [
                "C++",
                "项目",
                "C++",
                "项目"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/11/02/%E9%97%BB%E8%AF%B4/%E7%88%B1%E6%AC%B2%E4%B9%8B%E6%AD%BB/",
            "url": "https://aristotlednzk.github.io.com/2022/11/02/%E9%97%BB%E8%AF%B4/%E7%88%B1%E6%AC%B2%E4%B9%8B%E6%AD%BB/",
            "title": "爱欲之死",
            "date_published": "2022-11-02T14:07:23.000Z",
            "content_html": "<h3 id=\"reading中\"><a class=\"anchor\" href=\"#reading中\">#</a> Reading 中...</h3>\n<p>作者：韩炳哲    韩裔德国哲学家</p>\n<p>绩效社会、他者消失、否定性消失 balabala...</p>\n<p>还未看完，持续更新～</p>\n",
            "tags": [
                "阅读笔记",
                "西哲",
                "阅读笔记"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/23/%E8%A8%80/%E4%BA%BA%E7%B1%BB%E5%BE%80%E4%BA%8B/",
            "url": "https://aristotlednzk.github.io.com/2022/10/23/%E8%A8%80/%E4%BA%BA%E7%B1%BB%E5%BE%80%E4%BA%8B/",
            "title": "人类往事",
            "date_published": "2022-10-23T06:28:16.000Z",
            "content_html": "<h2 id=\"初章\"><a class=\"anchor\" href=\"#初章\">#</a> 初章</h2>\n<ul>\n<li>\n<p>本篇为我个人原创小说的导言，小说标题也尚未确定，内容纯属个人胡思乱想，对现实生活略有参考但并无影射，写小说的初衷不能说是完全一时兴起，只能说是用于闲暇时光消遣。本人将不定期更新篇章，有生之年是否完结也是未知数，想看小说后续请前往本博客分类：言 - 我的狂想曲 - 我的小说。</p>\n<p><code>可预见的逻辑bug技术细节凌乱叙事请海涵。随时欢迎关于小说内容的任何方面探讨。</code></p>\n</li>\n</ul>\n<h3 id=\"人类往事\"><a class=\"anchor\" href=\"#人类往事\">#</a> 人类往事</h3>\n<p>嗯哼～还没想好……</p>\n",
            "tags": [
                "言",
                "我的狂想曲",
                "我的小说",
                "言",
                "我的狂想曲",
                "我的小说"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/21/%E8%A8%80/%E4%B8%96%E7%95%8C%E3%82%A2%E3%83%B3%E3%83%89%E5%B4%87%E9%AB%98/",
            "url": "https://aristotlednzk.github.io.com/2022/10/21/%E8%A8%80/%E4%B8%96%E7%95%8C%E3%82%A2%E3%83%B3%E3%83%89%E5%B4%87%E9%AB%98/",
            "title": "世界アンド崇高",
            "date_published": "2022-10-21T12:02:05.000Z",
            "content_html": "<h2 id=\"那些错过的篇章\"><a class=\"anchor\" href=\"#那些错过的篇章\">#</a> 那些错过的篇章</h2>\n<p>这两天补完了剑风传奇和孤高之人，优秀作品的闪光点是纯粹的</p>\n<p>ああ 蒙昧の 蒙昧の</p>\n<p>枷に「保護」さえ写し見せ</p>\n<p>灰舞え 灰舞え 灰舞えよ ああ</p>\n<p>ああ 在るは難き唯一の出自を</p>\n<p><img data-src=\"/2022/10/21/%E8%A8%80/%E4%B8%96%E7%95%8C%E3%82%A2%E3%83%B3%E3%83%89%E5%B4%87%E9%AB%98/%E5%89%91%E9%A3%8E1.jpg\" class=\"\" title=\"剑风1\"></p>\n<p><img data-src=\"/2022/10/21/%E8%A8%80/%E4%B8%96%E7%95%8C%E3%82%A2%E3%83%B3%E3%83%89%E5%B4%87%E9%AB%98/%E5%89%91%E9%A3%8E.jpg\" class=\"\" title=\"剑风1\"></p>\n<hr />\n<p>见山即见崇高</p>\n<p>K2 东壁独攀者</p>\n<p><img data-src=\"/2022/10/21/%E8%A8%80/%E4%B8%96%E7%95%8C%E3%82%A2%E3%83%B3%E3%83%89%E5%B4%87%E9%AB%98/%E5%AD%A4%E9%AB%98%E4%B9%8B%E4%BA%BA.jpg\" class=\"\" title=\"孤高之人\"></p>\n",
            "tags": [
                "言",
                "言",
                "随笔集"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/19/philosophy/%E4%BA%BA%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%9A%84%E9%BB%98%E4%BC%9A%E7%BB%B4%E5%BA%A6/",
            "url": "https://aristotlednzk.github.io.com/2022/10/19/philosophy/%E4%BA%BA%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%9A%84%E9%BB%98%E4%BC%9A%E7%BB%B4%E5%BA%A6/",
            "title": "人类知识的默会维度",
            "date_published": "2022-10-19T02:28:56.000Z",
            "content_html": "<h3 id=\"大学阅读笔记收官第一篇\"><a class=\"anchor\" href=\"#大学阅读笔记收官第一篇\">#</a> 大学阅读笔记收官 —— 第一篇</h3>\n<ul>\n<li>\n<p>默会知识论启程读本</p>\n<p>欢迎书友评论</p>\n</li>\n</ul>\n<p><img data-src=\"/2022/10/19/philosophy/%E4%BA%BA%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%9A%84%E9%BB%98%E4%BC%9A%E7%BB%B4%E5%BA%A6/5.png\" class=\"\" width=\"5\"></p>\n<p><img data-src=\"/2022/10/19/philosophy/%E4%BA%BA%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%9A%84%E9%BB%98%E4%BC%9A%E7%BB%B4%E5%BA%A6/25.png\" class=\"\" width=\"25\"></p>\n",
            "tags": [
                "哲学社科",
                "西哲",
                "哲学社科",
                "西哲",
                "阅读笔记"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/18/%E8%A8%80/%E5%8F%B0%E9%A3%8E%E4%B8%8E%E7%A7%8B/",
            "url": "https://aristotlednzk.github.io.com/2022/10/18/%E8%A8%80/%E5%8F%B0%E9%A3%8E%E4%B8%8E%E7%A7%8B/",
            "title": "台风与秋",
            "date_published": "2022-10-18T11:00:56.000Z",
            "content_html": "<h3 id=\"深圳の秋\"><a class=\"anchor\" href=\"#深圳の秋\">#</a> 深圳の秋</h3>\n<p>三点一线的路上：<br />\n浮现出蚀之刻、真理与斗争的画面……</p>\n<p>食堂：<br />\n每次咬合齿肉镶嵌的冲击<br />\n思考，进食动作带来的快感……</p>\n<p>寒雨台风林海声：<br />\n来自它的呼唤<br />\n与世俱灭的斗志不允许你回顾从前……</p>\n<hr />\n<p>远行即远征</p>\n",
            "tags": [
                "言",
                "言",
                "随笔集"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/15/cpp/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9Asocket%E3%80%81IO%E5%A4%8D%E7%94%A8%E3%80%81epoll/",
            "url": "https://aristotlednzk.github.io.com/2022/10/15/cpp/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9Asocket%E3%80%81IO%E5%A4%8D%E7%94%A8%E3%80%81epoll/",
            "title": "Linux网络编程：socket、IO复用、epoll",
            "date_published": "2022-10-15T09:10:54.000Z",
            "content_html": "<h3 id=\"前置知识\"><a class=\"anchor\" href=\"#前置知识\">#</a> 前置知识：</h3>\n<p>Linux 系统 API 特点：如果调用失败一般返回 - 1</p>\n<p><strong>errno</strong>：属于 Linux 系统函数库，库里面的一个全局变量，记录的是最近的错误号</p>\n<blockquote>\n<p>perror (const char *s): 用于打印 errno 对应的错误描述 所需头文件 stdio.h</p>\n</blockquote>\n<blockquote>\n<p>close (): 关闭一个文件描述符，文件描述符可以重用 所需头文件 unistd.h</p>\n</blockquote>\n<ul>\n<li>int open(const char *pathname,int flags);</li>\n</ul>\n<blockquote>\n<p>功能：用于打开一个已经存在的文件 第一个参数：要打开的文件路径 第二个参数：权限 (三者互斥)：O_RDONLY 只读     O_WRONLY 只写     O_RDWR 可读可写 返回值：成功则返回新的文件描述符，如果产生错误则返回 - 1，设置 errno 包含三个头文件：sys/types.h    sys/stat.h     fcntl.h</p>\n</blockquote>\n<ul>\n<li>int open(const char *pathname,int flags，mode);</li>\n</ul>\n<h2 id=\"socket地址api\"><a class=\"anchor\" href=\"#socket地址api\">#</a> socket 地址 API</h2>\n<p>字节序问题：CPU 累加器一次装载 4 个字节，那么 4 个字节在内存中排列的顺序将影响它被累加器装载成的整数的值</p>\n<blockquote>\n<p>主机字节序 &amp; 网络字节序：</p>\n</blockquote>\n<ul>\n<li>大端字节序：<strong>一个整数的高位字节存储在内存的低位地址</strong>，低位字节（0-7bit）存储在内存高位地址， 称为<strong>网络字节序</strong></li>\n<li>小端字节序相反→现代多采用：称为<strong>主机字节序</strong></li>\n</ul>\n<h3 id=\"通用socket地址\"><a class=\"anchor\" href=\"#通用socket地址\">#</a> 通用 socket 地址：</h3>\n<p>AF_前缀表示地址族， PF_前缀表示协议族。</p>\n<p>unsigned short int→两个字节</p>\n<p>旧版：</p>\n<p>sa_family_t sa_family;//sa_family_t 地址族类型 char sa_data [14];// 只有 14 个字节</p>\n<p><img data-src=\"/2022/10/15/cpp/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9Asocket%E3%80%81IO%E5%A4%8D%E7%94%A8%E3%80%81epoll/image.png\" class=\"\" title=\"image\"></p>\n<h3 id=\"专用socket地址\"><a class=\"anchor\" href=\"#专用socket地址\">#</a> 专用 socket 地址</h3>\n<p>在设置和获取 IP 地址和端口号的上海更方便</p>\n<blockquote>\n<p>TCP 协议族 sockaddr_in 和 sockaddr_in6 两个专用 socket 地址结构体，分别用 IP v4 和 IP v6 所有 socket 编程接口使用的地址参数类型都是<strong> sockaddr</strong>→专用 socket 地址类型的遍历实际使用需要转换为通用 socket 地址类型 sockaddr</p>\n</blockquote>\n<p><img data-src=\"/2022/10/15/cpp/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9Asocket%E3%80%81IO%E5%A4%8D%E7%94%A8%E3%80%81epoll/2.png\" class=\"\" width=\"2\"></p>\n<p>sockaddr_in 每段都划分好了相应成员，最终转换为 sockaddr 指针即可</p>\n<p>.png)</p>\n<pre><code class=\"language-C++\">// TCP/IP 协议族有 sockaddr_in 和 sockaddr_in6 两个专用的 socket 地址结构体，它们分别用于 IPv4 和 IPv6：\n#include &lt;netinet/in.h&gt;\nstruct sockaddr_in&#123;\nsa_family_t sin_family; /* _*SOCKADDR_COMMON(sin*) */\nin_port_t sin_port; /* Port number. */\nstruct in_addr sin_addr; /* Internet address. */\n/* Pad to size of `struct sockaddr'. */\nunsigned char sin_zero[sizeof (struct sockaddr) - __SOCKADDR_COMMON_SIZE - sizeof (in_port_t) - sizeof (struct in_addr)];\n&#125;;\nstruct in_addr&#123;\nin_addr_t s_addr;\n&#125;;\nstruct sockaddr_in6&#123;\nsa_family_t sin6_family;\nin_port_t sin6_port; /* Transport layer port # */\nuint32_t sin6_flowinfo; /* IPv6 flow information */\nstruct in6_addr sin6_addr; /* IPv6 address */\nuint32_t sin6_scope_id; /* IPv6 scope-id */\n&#125;;\ntypedef unsigned short uint16_t;\ntypedef unsigned int uint32_t;\ntypedef uint16_t in_port_t;\ntypedef uint32_t in_addr_t;\n#define __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))\n</code></pre>\n<h2 id=\"ip地址转换\"><a class=\"anchor\" href=\"#ip地址转换\">#</a> IP 地址转换</h2>\n<blockquote>\n<p>字符串 ip - 整数和主机 - 网络字节序的转换</p>\n</blockquote>\n<p>通常，人们习惯用可读性好的<strong>字符串来表示 IP 地址</strong>，比如用点分十进制字符串表示 IPv4 地址，以及用十六进制字符串表示 IPv6 地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用<strong>点分十进制字符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址</strong>之间的转换：</p>\n<p>只适用于 IP v4：</p>\n<pre><code class=\"language-C++\">#include &lt;arpa/inet.h&gt;\nin_addr_t inet_addr(const char *cp);//该函数返回值类型为in_addr_t=uint32_t=unsigned int类型，参数为字符常量 \nint inet_aton(const char *cp, struct in_addr *inp);//将点分十进制地址转换为网络字节序地址\nchar *inet_ntoa(struct in_addr in);\n</code></pre>\n<blockquote>\n<p>inet_addr（）将一个<strong>点分十进制的 IP 字符串</strong>转换成一个网络字节序的长整数型数 (u_long 类型) inet_aton () 函数将将点分十进制地址转换为二进制的网络字节序地址，结 ** 果地址保存在结构体类型为 in_addr 的 inp 中，** 该结构体第一个成员为 uint32_t 类型（unsigned int 类型）的 in_addr_t。</p>\n</blockquote>\n<ul>\n<li>返回值：1 表示转换成功，0 表示失败有错误号 errno</li>\n</ul>\n<p><strong>同时适用于 IP v4 和 IP v6：</strong></p>\n<pre><code class=\"language-C++\">#include &lt;arpa/inet.h&gt;\n// **p:点分十进制的IP字符串**，n:表示network，网络字节序的整数\nint inet_pton(int af, const char *src, void *dst);\naf:地址族： AF_INET AF_INET6\nsrc:需要转换的点分十进制的IP字符串\ndst:转换后的结果保存在这个里面  \n// 将网络字节序的整数，转换成点分十进制的IP地址字符串\nconst char *inet_ntop(int af, const void *src, char *dst, socklen_t size);\naf:地址族： AF_INET AF_INET6\nsrc: 要转换的ip的整数的地址\ndst: 转换成IP地址字符串保存的地方\nsize：第三个参数的大小（数组的大小）\n**返回值：返回转换后的数据的地址（字符串），和 dst 是一样的**\n/*\n#include &lt;arpa/inet.h&gt;\n// p:点分十进制的IP字符串，n:表示network，网络字节序的整数\nint inet_pton(int af, const char *src, void *dst);\naf:地址族： AF_INET  AF_INET6\nsrc:需要转换的点分十进制的IP字符串\ndst:转换后的结果保存在这个里面\n// 将网络字节序的整数，转换成点分十进制的IP地址字符串\nconst char *inet_ntop(int af, const void *src, char *dst, socklen_t size);\naf:地址族： AF_INET  AF_INET6\nsrc: 要转换的ip的整数的地址\ndst: 转换成IP地址字符串保存的地方\nsize：第三个参数的大小（数组的大小）\n返回值：返回转换后的数据的地址（字符串），和 dst 是一样的\n*/\n#include &lt;stdio.h&gt;\n#include &lt;arpa/inet.h&gt;\nint main() &#123;\n// 创建一个ip字符串,点分十进制的IP地址字符串\nchar buf[] = &quot;192.168.1.4&quot;;**//第二个参数类型为字符数组**\nunsigned int num = 0;**//第三个参数的类型为无符号整型的地址---注意传入地址加&amp;**\n// 将点分十进制的IP字符串转换成网络字节序的整数\ninet_pton(AF_INET, buf, &amp;num);\nunsigned char * p = (unsigned char *)&amp;num;\n//把四个字节分别打印出来：每次+1=字节+1\nprintf(&quot;%d %d %d %d\\n&quot;, *p, *(p+1), *(p+2), *(p+3));\n// 将网络字节序的IP整数转换成点分十进制的IP字符串\nchar ip[16] = &quot;&quot;;\nconst char * str =  inet_ntop(AF_INET, &amp;num, ip, 16);\nprintf(&quot;str : %s\\n&quot;, str);\nprintf(&quot;ip : %s\\n&quot;, ip);\nprintf(&quot;%d\\n&quot;, ip == str);\nreturn 0;\n&#125;\n</code></pre>\n<blockquote>\n<p>解析 unsigned char * p = (unsigned char *)#</p>\n</blockquote>\n<blockquote>\n<p>二.(unsigned char *)&amp;a 运算顺序 1. 先取 a 的地址 2. 将 &amp; a 强制类型转化为 unsigned char * 类型，也就是指向 a 的地址 3. 取出 unsigned char * 指针的值</p>\n</blockquote>\n<h2 id=\"套接字函数\"><a class=\"anchor\" href=\"#套接字函数\">#</a> 套接字函数</h2>\n<pre><code class=\"language-C++\">#include &lt;sys/types.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;arpa/inet.h&gt; // 包含了这个头文件，上面两个就可以省略\nint socket(int domain, int type, int protocol);\n</code></pre>\n<ul>\n<li>\n<p>功能：创建一个套接字</p>\n</li>\n<li>\n<p>参数：</p>\n<ul>\n<li>\n<p>domain: 协议族</p>\n<p>AF_INET : ipv4</p>\n<p>AF_INET6 : ipv6</p>\n<p>AF_UNIX, AF_LOCAL : <strong>本地套接字通信</strong>（进程间通信）</p>\n</li>\n<li>\n<p>type: 通信过程中使用的协议类型</p>\n<p>SOCK_STREAM : 流式协议</p>\n<p>SOCK_DGRAM : 报式协议</p>\n</li>\n<li>\n<p>protocol : 具体的一个协议。一般写 0，则：</p>\n<ul>\n<li>SOCK_STREAM : 流式协议默认使用 TCP</li>\n<li>SOCK_DGRAM : 报式协议默认使用 UDP</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>返回值：</p>\n<ul>\n<li>成功：<strong>返回文件描述符</strong>，操作的就是内核缓冲区。</li>\n<li>失败：-1</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-C++\">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // socket命名\n</code></pre>\n<ul>\n<li>功能：绑定，将 fd 和本地的 IP + 端口进行绑定</li>\n<li>参数：\n<ul>\n<li>sockfd : 通过 socket 函数得到的文件描述符</li>\n<li>addr 😗* 需要绑定的 socket 地址，这个地址封装了 ip 和端口号的信息 **</li>\n<li>addrlen : 第二个参数结构体占的内存大小</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-C++\">int listen(int sockfd, int backlog); // /proc/sys/net/core/somaxconn\n</code></pre>\n<ul>\n<li>功能：监听这个 socket 上的连接</li>\n<li>参数：\n<ul>\n<li>sockfd : 通过 socket () 函数得到的文件描述符</li>\n<li>backlog : 未连接的和已经连接的和的最大值， 5 即可</li>\n</ul>\n</li>\n<li>返回值：listen 成功返回 0，失败返回 - 1 并设置 errno</li>\n</ul>\n<pre><code class=\"language-C++\">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);\n</code></pre>\n<ul>\n<li>功能：<strong>接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接</strong></li>\n<li>参数：\n<ul>\n<li>sockfd : <strong>用于监听的文件描述符</strong></li>\n<li>addr : <strong>传出参数，记录了连接成功后客户端的地址信息</strong>（ip，port）</li>\n<li>addrlen : 指定第二个参数的对应的内存大小</li>\n</ul>\n</li>\n<li>返回值：\n<ul>\n<li>成功 ：用于通信的文件描述符</li>\n<li>-1 ： 失败</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-C++\">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\n</code></pre>\n<ul>\n<li>功能： 客户端连接服务器</li>\n<li>参数：\n<ul>\n<li>sockfd : <strong>用于通信的文件描述符</strong></li>\n<li>addr : 客户端要连接的服务器的地址信息</li>\n<li>addrlen : 第二个参数的内存大小</li>\n</ul>\n</li>\n<li>返回值：成功 0， 失败 -1</li>\n</ul>\n<pre><code class=\"language-C++\">ssize_t write( int fd, const void *buf, size_t count); // 写数据\nssize_t read(int fd, void *buf, size_t count); // 读数据\n</code></pre>\n<blockquote>\n<p>fd：文件描述符 buf：读取数据存放的地方，数组的地址→传出参数 count：指定数组的大小 需要包含的头文件 unistd.h</p>\n</blockquote>\n<ul>\n<li>read 函数返回值</li>\n</ul>\n<blockquote>\n<blockquote>\n<p>0 实际读到的字节数 = 0 已经读到结尾（对端已经关闭断开连接）<br />\n-1 需要进一步判断 errno 的值 errno = EAGAIN or EWOULDBLOCK 设置了非阻塞方式读，并且没有数据到达 errno = EINTR 慢速系统调用被中断 errno = ECONNRESET 说明收到 RST 标志，连接被重置。需要 close errno = “其他” 异常</p>\n</blockquote>\n</blockquote>\n<p>ssize_t 类型通常用于文件操作的 write、read 函数，用于表示可以被执行 read 和 write 操作的数据块的大小，其在头文件 unistd.h 中的定义如下，被 typedef 定义为__ssize_t 类型</p>\n<ul>\n<li>其实 ssize_t 是 signed size_t 类型，其中 size_t 类型是在标准 C 语言库中进行定义的</li>\n<li>size_t 其本质是为了方便代码在不同的系统上移植而定义的，在 32 位的 Linux 中 size_t 为 unsigned int 类型即为 32 位无符号整数，在 64 位的 Linux 中其为 unsigned long 即为 64 位无符号整数。</li>\n</ul>\n<hr />\n<h1 id=\"以下内容源自linux高性能服务器编程unix网络编程\"><a class=\"anchor\" href=\"#以下内容源自linux高性能服务器编程unix网络编程\">#</a> 以下内容源自 Linux 高性能服务器编程 / UNIX 网络编程</h1>\n<p>参考 Linux 多进程开发：进程：通信</p>\n<h2 id=\"客户端\"><a class=\"anchor\" href=\"#客户端\">#</a> 客户端</h2>\n<h3 id=\"创建socket\"><a class=\"anchor\" href=\"#创建socket\">#</a> 创建 socket</h3>\n<h3 id=\"连接函数connect\"><a class=\"anchor\" href=\"#连接函数connect\">#</a> 连接函数 connect</h3>\n<p>TCP 客户通过 connect 函数来建立与 TCP 服务器的连接：</p>\n<p>int connect (int sockfd, const struct sockaddr *servaddr,socklen_t addrlen); 返回：成功则为 0，若出错则为 - 1</p>\n<blockquote>\n<p>解释： sockfd 是由 socket 数返回的套接字描述符 第 2 个、第 3 个参数分别是一个指向套接字地址结构的指针和该结构的大小</p>\n</blockquote>\n<p>客户在调用函数 onnect 前不必非得调用 bind 函数， 因为如果需要的话，内核会确定源 IP 地址，并选择 个临时端口作为源端口。TCP 套接字调用 connect 函数会激发 TCP 三次握手，仅在连接成功或出错时返回。</p>\n<ul>\n<li>connect 函数建立导致客户端套接字从 CLOSED 状态转为→SYN_SENT 状态</li>\n<li>若 connect 失败则该套接字不再可用，必须关闭，不能对该套接字再次调用 connect 函数</li>\n</ul>\n<h2 id=\"服务端\"><a class=\"anchor\" href=\"#服务端\">#</a> 服务端</h2>\n<h3 id=\"创建socket可读写控制关闭的文件描述符\"><a class=\"anchor\" href=\"#创建socket可读写控制关闭的文件描述符\">#</a> 创建 socket：可读写控制关闭的文件描述符</h3>\n<blockquote>\n<p>int socket( int domain,int type,int protocol)</p>\n</blockquote>\n<ul>\n<li>domain 参数告诉系统使用哪个底层协议簇，TCP/IP 使用 PF_INET（IPV4）</li>\n<li>type 指定服务类型：主要包括 SOCK_STREAM（流服务）和 SOCK_UGRAM（数据报服务）。对 TCP/IP 协议族而言，<strong>SOCK_STREAM*<em>*<em> 表示传输层使用 TCP 协议，*</em>**SOCK_DGRAM**</em>* 表示传输层使用 UDP 协议</strong></li>\n<li>protocol 参数是在前两个参数构成的协议集合下，再选择一个具体的协议，不过这个值通常是唯一的（由前两个参数完全决定），<strong>几乎在所有情况下都设置为 0，表示使用默认协议</strong></li>\n</ul>\n<p>调用成功返回一个<strong> socket 文件描述符（小的非负整数值）=sockfd</strong>，失败返回 - 1 并设置 errno</p>\n<h3 id=\"命名socket\"><a class=\"anchor\" href=\"#命名socket\">#</a> 命名 socket</h3>\n<blockquote>\n<p>创建 socket 时，我们给它指定了地址族，但并未指定具体用哪个地址 给 socket 命名：将一个 socket 与 socket 地址绑定</p>\n</blockquote>\n<p>客户端采用匿名方式 —— 使用操作系统自动分配的 socket 地址：把 一个本地协议地址赋给 一个套接字 系统调用函数：</p>\n<blockquote>\n<p>int bind(int sockfd,const struct sockaddr* my_addr,socklen_t addrlen);</p>\n</blockquote>\n<ul>\n<li>bind 将 my_addr 所指向的 socket 地址分配给未命名的 sockfd 文件描述符，addrlen 参数指出该 socket 地址的长度。</li>\n<li>bind 成功则返回 0，失败返回 - 1 并设置 errno 包括以下两种</li>\n</ul>\n<blockquote>\n<p>EACCES: 被绑定的地址是受保护的地址 EADDRINUSE: 被绑定的地址正在使用中</p>\n</blockquote>\n<p><strong>可以将 sizeof (addr_in) 传入第三个 参数</strong></p>\n<pre><code>sizeof` 是 `C/C++` 中的一个操作符（operator），返回一个对象或者类型所占的内存字节数。其返回值类型为 `size_t\n</code></pre>\n<p>sizeof (type_name);  //sizeof (类型);<br />\nsizeof (object);   // 或 sizeof object 都属于 sizeof 对象；</p>\n<hr />\n<p>上述两个函数都需要: include &lt;sys/types.h&gt; include&lt;sys/socket.h&gt;</p>\n<h3 id=\"监听socket\"><a class=\"anchor\" href=\"#监听socket\">#</a> 监听 socket</h3>\n<p>socket 被命名后需要使用系统调用创建一个监听队列来存放待处理的客户连接：</p>\n<blockquote>\n<p>int listen( int sockfd,int backlog);</p>\n</blockquote>\n<blockquote>\n<p>listen 函数仅由 TCP 服务器调用，并做如下两件事：</p>\n</blockquote>\n<ol>\n<li>\n<p>listen 函数创建一个套接字时，他被假设为一个主动套接字。listen 函数把 1 个未连接的套接字转换成 1 个被动套接字，指示内核接受指向套接字的连接请求。</p>\n</li>\n<li>\n<p>第二个参数规定了内核应该为相应套接字排队的最大连接个数。 内核为每个给定的监听套接字维护两个队列：</p>\n<p>（1）未完成连接队列：每个 SYN 分节对应队列中的一项，套接字正处于 SYN_RCVD 状态</p>\n<p>（2）已完成连接队列：每个已完成三次握手的客户对应队列中的一项，套接字处于 ESTABLISHED 状态</p>\n</li>\n</ol>\n<blockquote>\n<p>1. 每当来自客户的 SYN 到达，<strong>TCP 在未完成连接队列中创建一个新项</strong>，然后服务器响应 SYN 第二个分节，并捎带对客户的 SYN 的 ACK。该项一直保留在未完成连接队列中，直到三次握手第三个分节到达或该项超时为止。如果三次握手正常，该项则<strong>从未完成连接队列转移到已完成连接队列的队尾</strong>。 2. 当进程调用 accept 函数时，已完成连接队列中的队头项将返回给进程，如果该队列为空那么进程将被投入睡眠，直到 TCP 在该队列中放入一项才唤醒它</p>\n</blockquote>\n<ul>\n<li>sockfd 参数指定被监听的 socket。</li>\n<li>backlog 参数提示内核<strong>监听队列的最大长度</strong>→监听队列长度如果超过 backlog，服务器将不手里新的客户连接，客户端将收到 ECONNREFUSED 错误信息，以前表示已连接队列 + 半连接队列之和</li>\n<li>listen 成功返回 0，失败返回 - 1 并设置 errno</li>\n</ul>\n<h3 id=\"接受连接\"><a class=\"anchor\" href=\"#接受连接\">#</a> 接受连接</h3>\n<p>accept 函数由 TCP 服务器调用，用于<strong>从已完成连接队列队头返回下一个已完成连接</strong>。<strong>从 listen 监听队列中接受一个连接</strong></p>\n<blockquote>\n<p>int accept(int sockfd,struct sockaddr *addr,socklen_t *addrlen);</p>\n</blockquote>\n<ul>\n<li>sockfd 参数是执行过 listen 系统调用的监听 socket 套接字描述符</li>\n<li>addr 参数获取被接受连接的远端 socket 地址</li>\n<li>远端 socket 地址结构长度由 * addrlen 参数所引用的整数值设置，返回时，该整数值为该套接字地址结构内的确切字节数</li>\n<li>accept 成功时，<strong>那么其返回值是由 内核自动 生成的 1 个套接字全新描述符</strong> = 称为<strong>已连接套接字描述符</strong>，该 socket 唯一地表示了被接受的这个连接。失败则返回 - 1 并设置 errno。如果<strong>已完成连接队列为空，那么进程被投入睡眠</strong></li>\n</ul>\n<p>服务器可以通过该 socket 来与被接受连接对应的客户端通信</p>\n<p>已连接套接字每次在循环中关闭，但监听套接字在服务器的整个有效期内都保持开放</p>\n<p>而现在由于考虑到 syn 攻击，backlog 参数的含义改为了已连接队列之和，去除了半连接队列之和了。</p>\n<p>举一个例子，在 socket 编程当中，如果我们在服务端不用 accept 函数，listen 函数的第二个参数设置为 5，那么这个时候，可以成功连接的客户端就是最多可以成功连入 5 个，每连入一个，队列的项数就会加一 (减一的话就是用 accept 函数去取出来)，所以当项数达到 5 时，客户端自然就会连不上了。</p>\n<blockquote>\n<p>注意本函数最多返回三个值：分别对应函数三个参数</p>\n</blockquote>\n<ul>\n<li>新套接字描述符 / 出错指示整数</li>\n<li>客户进程的协议地址→addr</li>\n<li>客户进程的协议地址大小→addrlen</li>\n</ul>\n<hr />\n<h4 id=\"socket状态\"><a class=\"anchor\" href=\"#socket状态\">#</a> socket 状态</h4>\n<ol>\n<li>调用 socket 函数创建了一个套接字以后，改套接字就对应的和相应的输出缓冲区和输入缓冲区建立了联系，此时改套接字的状态正处于 CLOSED (观察 TCP 状态转换图即可)</li>\n<li>当我们调用 listen 函数以后，改套接字的状态就变成了 LISTEN 监听状态，此时，处于等待客户端连入的状态。</li>\n<li>对于一个调用 listen 进行监听的套接字’操作系统会为其维护 2 个队列：未完成连接队列和已完成连接队列。 （1）未完成连接队列中的连接 当客户端发送 TCP 连接三次握手的第 1 次（即 SYN 包）时，服务器端会在未完成连接队列中创建一个与该 SYN 包对应的项，可以把该项看成一个半连接（因为连接尚未建立）该半连接的状态会从 LISTEN 变成 SYNRCVD 同时向客户端返回第 2 次握手的包。 （SYN’ACK）而此时服务器正在等待完成第 3 次握手 （2）已完成连接队列中的连接 3 次握手完成后该连接就变成 ESTABLISHED 状态，每个已经完成 3 次握手的客户端连接（完整说法应该是 “服务器端的与客户端对应的 socket 连接”）都放在这个队列中作为一项。</li>\n</ol>\n<p>.png)</p>\n<p>从上图可以看到客户端发送的三次握手从第 1 个 SYN 包到 ** <code>在三次握手完成之前</code> <strong>连接都会在未完成连接队列中；直到</strong> <code>在三次握手完成后</code>  ** 该连接就从未完成连接队列转移到已完成连接队列</p>\n<p>而 listen 函数” 曾经 “的含义为这两个队列的和不超过 backlog，实际上由于操作系统的原因可能会比这个值稍微多一些。</p>\n<p>.png)</p>\n<hr />\n<h3 id=\"web服务器端通过socket监听来自用户的请求\"><a class=\"anchor\" href=\"#web服务器端通过socket监听来自用户的请求\">#</a> Web 服务器端通过 <code>socket</code>  监听来自用户的请求。</h3>\n<p>源代码如下：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>#include &lt;sys/socket.h>  </pre></td></tr><tr><td data-num=\"2\"></td><td><pre>#include &lt;netinet/in.h>  </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>/* 创建监听socket文件描述符 */  </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>int listenfd = socket(PF_INET, SOCK_STREAM, 0);  /* 创建监听socket的TCP/IP的IPV4 socket地址 struct sockaddr_in address;  </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>bzero(&amp;address, sizeof(address));  </pre></td></tr><tr><td data-num=\"6\"></td><td><pre>address.sin_family = AF_INET;  </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>address.sin_addr.s_addr = htonl(INADDR_ANY);  /* INADDR_ANY：将套接字绑定到所有可用的接口   </pre></td></tr><tr><td data-num=\"8\"></td><td><pre>address.sin_port = htons(port);  </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>int flag = 1;  </pre></td></tr><tr><td data-num=\"10\"></td><td><pre>/* SO_REUSEADDR 允许端口被重复使用 */  </pre></td></tr><tr><td data-num=\"11\"></td><td><pre>setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, sizeof(flag));  </pre></td></tr><tr><td data-num=\"12\"></td><td><pre>/* 绑定socket和它的地址 */  </pre></td></tr><tr><td data-num=\"13\"></td><td><pre>ret = bind(listenfd, (struct sockaddr*)&amp;address, sizeof(address));   </pre></td></tr><tr><td data-num=\"14\"></td><td><pre>/* 创建监听队列以存放待处理的客户连接，在这些客户连接被accept()之前 */  </pre></td></tr><tr><td data-num=\"15\"></td><td><pre>ret = listen(listenfd, 5);</pre></td></tr></table></figure><h4 id=\"代码分析\"><a class=\"anchor\" href=\"#代码分析\">#</a> 代码分析：</h4>\n<blockquote>\n<p>创建监听 socket 的 TCP/IP 的 IPV4 socket 地址</p>\n</blockquote>\n<ul>\n<li>struct sockaddr_in address;</li>\n</ul>\n<blockquote>\n<p>bzero 函数是 c++ string.h 中的函数 *。* 功能描述：置字节字符串前 n 个字节为零且包括‘\\0’。 原型:extern void bzero (void *s, int n); 参数说明:s 要置零的数据的起始地址；n 要置零的数据字节个数。 用法:#include &lt;string.h&gt; 功能:<strong> 置字节字符串 s 的前 n 个字节为零且包括‘\\0’</strong>。 说明:bzero 无返回值</p>\n</blockquote>\n<ul>\n<li>bzero(&amp;address, sizeof(address));</li>\n</ul>\n<blockquote>\n<p>创建套接字时，用该字段指定地址族，对于 TCP/IP 协议的，必须设置为 AF_INET。变量 address 是一个结构体，其中成员变量 sin_family 是<strong>地址族类型变量</strong></p>\n</blockquote>\n<ul>\n<li>address.sin_family = AF_INET;</li>\n</ul>\n<ol>\n<li>sin_addr 是套接字中的 IP 地址，sin_addr 的类型是联合，因此可以通过三种不同的方式访问它：作为 s_un_b（四个 1 字节整数）、s_un_w（两个 2 字节整数）或作为 s_addr（一个 4 字节整数）。INADDR_ANY：将套接字绑定到所有可用的接口</li>\n<li><strong>网络编程_常用的基本函数介绍</strong> ——htonl、ntohl、htons、ntohs htonl 函数：将主机的 unsigned long 值转换成网络字节顺序（32 位）（一般主机跟网络上传输的字节顺序是不通的，分大小端），函数返回一个网络字节顺序的数字。 ntohl 函数：将网络字节顺序（32 位）转为主机字节</li>\n</ol>\n<ul>\n<li>address.sin_addr.s_addr = htonl(INADDR_ANY);</li>\n</ul>\n<blockquote>\n<p>htons 是将整型变量从主机字节顺序转变成网络字节顺序， 就是整数在地址空间存储方式变为高位字节存放在内存的低地址处。</p>\n</blockquote>\n<ul>\n<li>address.sin_port = htons(port);</li>\n</ul>\n<blockquote>\n<p>SO_REUSEADDR 允许端口被重复使用</p>\n</blockquote>\n<ul>\n<li>setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, sizeof(flag));</li>\n</ul>\n<p>setsockopt 函数解析：</p>\n<p>SO_REUSEADDR 参数，打开或关闭地址复用功能。当 option_value 不等于 0 时，打开，否则，关闭。它实际所做的工作是置 sock-&gt;sk-&gt;sk_reuse 为 1 或 0。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>#include &lt;sys/socket.h></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>int setsockopt(int sockfd, int level, int optname,</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>const void *optval, socklen_t optlen);</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>参数说明：</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>(1) int sockfd: 很简单，套接字描述符</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>(2) int level: 选项定义的层次；目前仅支持SOL_SOCKET和IPPROTO_TCP层次，若要在套接字级别上设置选项，就必须把level设置为 SOL_SOCKET</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>(3) int optname: 指定准备设置的选项，option_name可以有哪些取值，这取决于level</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>(4) const void *optval: 指针，指向存放选项值的缓冲区</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>(5) socklen_t optlen: optval缓冲区的长度</pre></td></tr></table></figure><blockquote>\n<p>绑定 socket 和它的地址</p>\n</blockquote>\n<ul>\n<li>ret = bind(listenfd, (struct sockaddr*)&amp;address, sizeof(address));</li>\n</ul>\n<blockquote>\n<p>创建监听队列以存放待处理的客户连接，在这些客户连接被 accept () 之前</p>\n</blockquote>\n<ul>\n<li>ret = listen(listenfd, 5);</li>\n</ul>\n<hr />\n<blockquote>\n<p>assert (ret≠-1) 函数的作用是现计算表达式 expression ，如果其值为假（即为 0），那么它先向 stderr 打印一条出错信息，然后通过调用 abort 来终止程序运行。</p>\n</blockquote>\n<p>书本 95 页服务器程序：</p>\n<blockquote>\n<pre><code>const char* ip=argv[1]; int port =atoi(argv[2]); int backlog =atoi(argv[3]); int inet_pton(int AF_INET, ip ,&amp;address.sin_addr);\n</code></pre>\n</blockquote>\n<p>需要以下包： include &lt;sys/types.h&gt;<br />\ninclude &lt;sys/socket.h&gt;<br />\ninclude &lt;arpa/inet.h&gt;</p>\n<p>解释：接收 IP 地址、端口还、backlog 值。调用 <code>inet_pton</code>  函数：可以在将 IP 地址在 “点分十进制” 和 “整数” 之间转换</p>\n<blockquote>\n<p>int inet_pton(int af, const char *src, void <em>dst);<br />\n 这个函数转换字符串到网络地址，第一个参数 af 是地址族，转换后存在 dst 中<br />\n inet_pton 是 inet_addr 的扩展，支持的多地址族有下列：<br />\naf = AF_INET<br />\nsrc 为指向字符型的地址，即 ASCII 的地址的首地址（ddd.ddd.ddd.ddd 格式的），函数将该地址<br />\n转换为<strong> in_addr</strong> 的结构体，并复制在</em> dst 中</p>\n</blockquote>\n<blockquote>\n<p>af =AF_INET6<br />\nsrc 为指向 IPV6 的地址，函数将该地址转换为<strong> in6_addr</strong> 的结构体，并复制在 * dst 中如果函数出错将返回一个负值，并将 errno 设置为 EAFNOSUPPORT，如果参数 af 指定的地址族和 src 格式不对，函数将返回 0。</p>\n</blockquote>\n<hr />\n<h2 id=\"多线程实现并发服务器\"><a class=\"anchor\" href=\"#多线程实现并发服务器\">#</a> 多线程实现并发服务器</h2>\n<p>参考：Linux 多线程开发</p>\n<p><strong>用户区中堆是共享，每个线程对应一个栈区 —— 不共享</strong></p>\n<hr />\n<h1 id=\"tcp状态转换\"><a class=\"anchor\" href=\"#tcp状态转换\">#</a> TCP 状态转换</h1>\n<p><img data-src=\"/2022/10/15/cpp/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9Asocket%E3%80%81IO%E5%A4%8D%E7%94%A8%E3%80%81epoll/image-16684837417685.png\" class=\"\" title=\"image-16684837417685\"></p>\n<p><img data-src=\"/2022/10/15/cpp/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9Asocket%E3%80%81IO%E5%A4%8D%E7%94%A8%E3%80%81epoll/image-16684837417686.png\" class=\"\" title=\"image-16684837417686\"></p>\n<p>（红色实现可以视为客户端发送请求，绿色虚线视为服务器，黑色是一些异常）</p>\n<blockquote>\n<p>为什么在服务端要分两次发送 ACK 和 FIN，不一次性发送 —— 为什么第二第三次挥手不合并？</p>\n</blockquote>\n<ul>\n<li>因为客户端发送 FIN 后，服务端再发送 ACK 表示同意客户端断开连接，但服务端可能还需要发送数据给客户端，因此可以在服务端发送完数据后再发送 FIN 给客户端，表示服务端断开连接。</li>\n<li>三次握手时可以一次性发送：因为建立连接是双方互相的通信，而四次挥手是单方面的意愿</li>\n</ul>\n<blockquote>\n<p>为什么连接的主动关闭方必须处于 TIME_WAIT 状态并持续 2MSL 时间？<em>MSL 指一个片段在网络中最大的存活时间，2MSL 就是</em><em><strong>一个发送和一个回复所需的最大时间</strong></em></p>\n</blockquote>\n<ul>\n<li>确保安全性：如果服务端没有接收到客户端最后发送的 ACK，那么能够让 TCP 连接的主动关闭方在它发送的 ACK 丢失的情况下重新发送最终的 ACK，直到确认服务端收到为止。</li>\n<li>主动关闭方重新发送的最终 ACK 并不是因为被动关闭方重传了 ACK（它们并不消耗序列号，被动关闭方也不会重传），而<strong>是因为被动关闭方重传了它的 FIN</strong>。事实上，<strong>被动关闭方总是重传 FIN 直到它收到一个最终的 ACK。</strong></li>\n</ul>\n<p>2MSL（Maximum Segment Lifetime），主动断开连接的一方，最后进入一个 TIME_WAIT 状态，这个状态会持续: 2msl。msl: 官方建议: 2 分钟，实际是 30s</p>\n<h2 id=\"半关闭\"><a class=\"anchor\" href=\"#半关闭\">#</a> 半关闭</h2>\n<p>半关闭状态：FIN_WAIT_1 不能发送数据（不包括协议 ACK 确认），但可以接收数据</p>\n<p>当 TCP 连接中 A 向 B 发送 FIN 请求关闭，另一端 B 回应 ACK 之后（A 端进入 FIN_WAIT_2 状态），并没有立即发送 FIN 给 A，A 方处于半连接状态（半开关），此时 A 可以接收 B 发送的数据，但是 A 已经不能再向 B 发送数据。从程序的角度，可以<strong>使用 API 来控制实现半连接状态：</strong></p>\n<pre><code class=\"language-C++\">#include &lt;sys/socket.h&gt;\nint shutdown(int sockfd, int how);\nsockfd: 需要关闭的socket的描述符\nhow: 允许为shutdown操作选择以下几种方式:\n    SHUT_RD(0)： 关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。\n    SHUT_WR(1): 关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。\n    SHUT_RDWR(2):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。\n</code></pre>\n<p>使用 close 中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为 0 时才关闭连接。<strong>shutdown *<em>** 不考虑描述符的引用计数，直接关闭描述符 **</em>*。也可选择中止一个方向的连接，只中止读或只中止写</strong>。</p>\n<p>多进程中，创建的子进程和父进程共享文件描述符表，创建一个子进程引用计数加一</p>\n<blockquote>\n<p>注意： 如果有多个进程共享一个套接字，close 每被调用一次，计数减 1 ，直到计数为 0 时，也就是所用进程都调用了 close，套接字将被释放。 在多进程中如果一个进程调用了 shutdown (sfd, SHUT_RDWR) 后，其它的进程将无法通过该文件描述符 sfd 进行通信。但如果一个进程 close (sfd) 将不会影响到其它进程。</p>\n</blockquote>\n<h2 id=\"端口复用\"><a class=\"anchor\" href=\"#端口复用\">#</a> 端口复用</h2>\n<p>首先有个问题：通信双方有一方先断开连接，比如服务端先断开连接，那么处于 FIN_WAIT_2，客户端处于 CLOSE_WAIT，而客户端也断开连接，那么服务端处于 TIME_WAIT，<strong>此时服务端需要等待 2msl 时间才能释放它所占用的端口号</strong>，期间如果重新启动服务器./server 那么会一直显示： bind: Address already in use</p>\n<p>如果希望服务器主动结束后能立刻运行，那么需要端口复用！</p>\n<blockquote>\n<p>tcp 协议中 FIN_WAIT2 到 Time_wait 的状态是有时间的，如果超过这个时间，服务端内核就会直接结束，所以如果服务端在 FIN_WAIT_2 状态一定时间后会自动结束进程</p>\n</blockquote>\n<p><img data-src=\"/2022/10/15/cpp/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9Asocket%E3%80%81IO%E5%A4%8D%E7%94%A8%E3%80%81epoll/image-16684837417687.png\" class=\"\" title=\"image-16684837417687\"></p>\n<p>当客户端也断开后（给服务端发送了 FIN），服务端进入 TIME_WAIT</p>\n<p>端口复用最常用的用途是:</p>\n<ul>\n<li>防止服务器重启时之前绑定的端口还未释放</li>\n<li>程序突然退出而系统没有释放端口</li>\n<li>还能设置套接字的属性</li>\n</ul>\n<h4 id=\"recv函数\"><a class=\"anchor\" href=\"#recv函数\">#</a> recv 函数</h4>\n<p>**int recv( SOCKET s,   char FAR *buf,   int len,   int flags   );  **</p>\n<p>不论是客户还是服务器应用程序都用 recv 函数从 TCP 连接的另一端接收数据。</p>\n<ul>\n<li>该函数的第一个参数指定接收端套接字描述符；</li>\n<li>第二个参数指明一个缓冲区，该缓冲区用来存放 recv 函数接收到的数据；</li>\n<li>第三个参数指明 buf 的长度；</li>\n<li>第四个参数一般置 0。</li>\n</ul>\n<blockquote>\n<p>这 里只描述同步 Socket 的 recv 函数的执行流程： 当应用程序调用 recv 函数时，recv 先等待 s 的发送缓冲中的数据被协议传送完毕，如果协议在传送 s 的发送缓冲中的数据时出现网络错误 ，那么 recv 函数返回 SOCKET_ERROR</p>\n</blockquote>\n<p>如果 s 的发送缓冲中没有数 据或者数据被协议成功发送完毕后，recv 先检查套接字 s 的接收缓冲区，如果 s 接收缓冲区中没有数据或者协议正在接收数据，那么 recv 就一直等待，只到 协议把数据接收完毕。当协议把数据接收完毕，recv 函数就把 s 的接收缓冲中的数据 copy 到 buf 中（注意协议接收到的数据可能大于 buf 的长度，所以 在这种情况下要调用几次 recv 函数才能把 s 的接收缓冲中的数据 copy 完。recv 函数仅仅是 copy 数据，真正的接收数据是协议来完成的），<strong>recv 函数返回其实际 copy 的字节数。</strong></p>\n<p>如果 recv 在 copy 时出错，那么它返回 SOCKET_ERROR；如果 recv 函数在等待协议接收数据时网络中断 了，那么它返回 0</p>\n<pre><code class=\"language-C++\">#include &lt;sys/types.h&gt;\n#include &lt;sys/socket.h&gt;\n// 设置套接字的属性（不仅仅能设置端口复用）\nint setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);\n参数（在UNP（Unix网络编程）书籍中使用）：\n</code></pre>\n<ul>\n<li>\n<p>sockfd : 要操作的文件描述符</p>\n</li>\n<li>\n<p>level : 级别 - SOL_SOCKET (端口复用的级别)</p>\n</li>\n<li>\n<p>optname : 选项的名称，</p>\n<p>端口复用都可以使用</p>\n<ul>\n<li>SO_REUSEADDR</li>\n<li>SO_REUSEPORT</li>\n</ul>\n</li>\n<li>\n<p>optval : 端口复用的值（整型）</p>\n<ul>\n<li>1 : 可以复用</li>\n<li>0 : 不可以复用</li>\n</ul>\n</li>\n<li>\n<p>optlen : optval 参数的大小</p>\n</li>\n</ul>\n<p><strong>端口复用，设置的时机是</strong> ** 在服务器绑定端口之前 ****。 **setsockopt (); bind ();</p>\n<pre><code class=\"language-C++\">常看网络相关信息的命令\nnetstat\n参数：\n-a 所有的socket\n-p 显示正在使用socket的程序的名称\n-n 直接使用IP地址，而不通过域名服务器\n</code></pre>\n<p>.png)</p>\n<p>0.0.0.0ip 绑定了 9999 端口号，server 是应用程序的名称</p>\n<h2 id=\"io多路复用io多路转接面试必问\"><a class=\"anchor\" href=\"#io多路复用io多路转接面试必问\">#</a> I/O 多路复用（I/O 多路转接）面试必问</h2>\n<h3 id=\"select-poll-和-epoll要手动写出来知道原理\"><a class=\"anchor\" href=\"#select-poll-和-epoll要手动写出来知道原理\">#</a> <strong>select、poll 和 epoll</strong> 要手动写出来，知道原理</h3>\n<ol>\n<li><strong>I/O 多路复用使得程序能同时监听多个文件描述符，能够提高程序的性能</strong>，Linux 下实现 I/O 多路复用的系统调用主要有 <strong>select、poll 和 epoll</strong>。</li>\n<li>之前的做法是一个一个文件描述符去遍历，无法同时监听</li>\n</ol>\n<p>输入输出对应的是程序和内存： 输入：程序 / 文件→内存 输出：内存→文件</p>\n<p>.png)</p>\n<ol>\n<li>阻塞等待 (（阻塞 IO 模型即 BIO 模型）</li>\n</ol>\n<p>.png)</p>\n<p>.png)</p>\n<p>每有一个客户端连接进来，就创建一个线程去读取接收客户端数据，而主线程不受影响</p>\n<h3 id=\"非阻塞忙轮询非阻塞模型即nio\"><a class=\"anchor\" href=\"#非阻塞忙轮询非阻塞模型即nio\">#</a> 非阻塞，忙轮询（非阻塞模型即 NIO）</h3>\n<p>可以设置 read 不阻塞，此时有数据就读，没数据就返回一个值继续往下执行，但需要不断循环判断是否有数据进来 <img data-src=\"/2022/10/15/cpp/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9Asocket%E3%80%81IO%E5%A4%8D%E7%94%A8%E3%80%81epoll/ock.png\" class=\"\" title=\"ock\"></p>\n<p>.png)</p>\n<p>当有客户端连接进来，accept 就将该 cfd 添加到一个表里面；然后再逐个判断每个文件描述符 cfd 是否有数据通信，当有数据通信就调用 read/recv 读取，没有就继续往下循环。</p>\n<p>当客户端数量巨大时逐个遍历是否有数据写入</p>\n<p>IO 多路转接</p>\n<p>.png)</p>\n<p>.png)</p>\n<p>现在将所有客户端的文件描述符 cfd 统一交给内核，内核去检测再返回，因此只调用了一次就查出是哪个</p>\n<h2 id=\"select-api介绍\"><a class=\"anchor\" href=\"#select-api介绍\">#</a> select API 介绍</h2>\n<blockquote>\n<p>主旨思想： 1. 首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中。</p>\n</blockquote>\n<ol>\n<li>调用一个系统函数（即 select），监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行 I/O 操作时，该函数才返回。 a. 这个函数是阻塞 b. 函数对文件描述符的检测的操作是由内核完成的 3. 在返回时，它会告诉进程有多少（哪些）描述符要进行 I/O 操作</li>\n</ol>\n<pre><code class=\"language-C++\">// sizeof(fd_set) = 128个字节 =1024位，每个标志位保存一个文件描述符\n#include &lt;sys/time.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/select.h&gt;\nint select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);\n</code></pre>\n<ul>\n<li>\n<p>参数：</p>\n<ul>\n<li>\n<p>nfds : 委托内核检测的<strong>最大文件描述符的值 + 1</strong>→为了能够遍历到最大的文件描述符，类似： for (int i=0;i&lt;n+1;i++)</p>\n</li>\n<li>\n<p>readfds : 要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性。</p>\n<p>检测读缓冲区有没有数据</p>\n<p>。没有数据标志位置 0，有数据置为 1. 因此最后返回的是标志位为 1 的文件描述符。</p>\n<ul>\n<li>一般检测读操作</li>\n<li>对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲区\n<ul>\n<li>是一个传入传出参数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>writefds : 要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性</p>\n<ul>\n<li>委托内核检测写缓冲区是不是还可以写数据（不满的就可以写），满了标志位置 0，不满置 1</li>\n</ul>\n</li>\n<li>\n<p>exceptfds : 检测发生异常的文件描述符的集合</p>\n</li>\n<li>\n<p>timeout : 设置的超时时间</p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-C++\">struct timeval &#123;\n    long tv_sec; /* seconds */\n    long tv_usec; /* microseconds */\n&#125;;\n    - NULL : 永久阻塞，直到检测到了文件描述符有变化\n    - tv_sec = 0 tv_usec = 0， 不阻塞\n    - tv_sec &gt; 0 tv_usec &gt; 0， 阻塞对应的时间\n</code></pre>\n<ul>\n<li>\n<p>返回值 :</p>\n<ul>\n<li>\n<p>-1 : 失败</p>\n</li>\n<li>\n<blockquote>\n<p>0 (n) : 检测的集合中有 n 个文件描述符发生了变化</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-C++\">// 将参数文件描述符fd对应的标志位设置为0（clear）\nvoid FD_CLR(int fd, fd_set *set);\n// 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，如果是0返回0， 是1返回1\nint FD_ISSET(int fd, fd_set *set);\n// 将参数文件描述符fd 对应的标志位，设置为1\nvoid FD_SET(int fd, fd_set *set);\n// fd_set一共有1024 bit, 全部初始化为0\nvoid FD_ZERO(fd_set *set);\n</code></pre>\n<p>1. 要检测读缓冲区，首先建立一个 fd_set，存放每个文件描述符读缓冲区的标志位。每个比特位代表一个文件描述符 （注意前三个是被占用的！）</p>\n<p>2. 然后将要检测的文件描述符标志位置 1, 以上都是在用户态中进行</p>\n<p>3. 之后调用 select，将 fd_set 拷贝到内核态检测有哪些位是有数据→置 1，没有数据的→置 0，再将结构 fd_set 返回到用户态，用户只需要一次遍历用户态中的 fd_set 就能知道有多少文件描述符有数据</p>\n<p>.png)</p>\n<h2 id=\"poll-api介绍及代码编写\"><a class=\"anchor\" href=\"#poll-api介绍及代码编写\">#</a> poll API 介绍及代码编写</h2>\n<p><strong>核心：将主动询问内核转变为等待内核通知</strong>，从主动轮询→被动通知 <strong>一次系统调用 select/poll 就可以实现管理多个 client 事件（读写 accept 等）</strong>，降低非阻塞 IO 频繁无效系统调用问题</p>\n<p>select () 函数缺点：<strong>内核态中依然要遍历所有文件描述符</strong>，每次调用需要拷贝全量描述符到内核态</p>\n<p>.png)</p>\n<p>POLL</p>\n<pre><code class=\"language-C++\">#include &lt;poll.h&gt;\nstruct pollfd &#123;\n    int fd; /* 委托内核检测的文件描述符 */\n    short events; /* 委托内核检测文件描述符的什么事件 */\n    short revents; /* 文件描述符实际发生的事件 */\n&#125;;\nstruct pollfd myfd;\n   myfd.fd = 5;\n   myfd.events = POLLIN | POLLOUT;  同时检测两个事件：同时委托内核进行读写操作\nint poll(struct pollfd *fds, nfds_t nfds, int timeout);\n</code></pre>\n<ul>\n<li>\n<p>参数：</p>\n<ul>\n<li>\n<p>fds : 是一个 struct pollfd 结构体数组，这是一个需要检测的文件描述符的集合</p>\n</li>\n<li>\n<p>nfds : 这个是第一个参数数组中最后一个有效元素的下标 + 1</p>\n</li>\n<li>\n<p>timeout : 阻塞时长</p>\n<p>0 : 不阻塞</p>\n<p>-1 : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞</p>\n<blockquote>\n<p>0 : 阻塞的时长</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p>返回值：</p>\n<p>-1 : 失败</p>\n<blockquote>\n<p>0（n） : 成功，n 表示检测到集合中有 n 个文件描述符发生变化</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>poll 数组如果已满，没有可用的位置存放新连接 accept 进来的文件描述符 cfd，那么就等待下一次处理。注意新连接的 cfd 不会丢弃，在 TCP 缓冲区中，等到 poll 数组中有可用的就可以继续连接了</p>\n</blockquote>\n<p>如果有数据传入，则调用 read 返回 len，len=0 说明读取完毕，先 close 关闭该文件描述符，再将该结构体的文件描述符置为 - 1，fd [i].fd=-1</p>\n<p>.png)</p>\n<h2 id=\"epoll-api-介绍\"><a class=\"anchor\" href=\"#epoll-api-介绍\">#</a> epoll API 介绍</h2>\n<p>改进：</p>\n<p><strong>首先调用 epoll_create 在 *<em>** 内核区创建 epoll 实例 **</em>*—— 结构体数据</strong></p>\n<p>struct rb_root rbr;// 存放文件描述符，底层是红黑树 struct list_head rdlist;// 检测到发生改变的（有数据传入的）文件描述符，底层双链表</p>\n<p>.png)</p>\n<p>#include &lt;sys/epoll.h&gt;</p>\n<p>//epoll_create 创建一个新的 epoll 实例，返回指向该实例的描述符 epollfd 用来调用所有 epoll 相关接口。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检测的文件描述符的信息（红黑树），还有一个是<strong>就绪列表</strong>，存放检测到数据发生改变的文件描述符信息（双向链表）。</p>\n<p>当 epollfd 不再使用时，需要调用 close () 关闭，当指向 epoll 的文件描述符关闭后内核会摧毁 epoll 实例并释放相关资源。</p>\n<p>epoll_ctl: 将哪个客户端 fd 的哪些事件 event 交给哪个 epoll (epollfd) 来管理（增删改）</p>\n<p>int epoll_create(int size);</p>\n<ul>\n<li>\n<p>参数：</p>\n<p>size : 目前没有意义了。随便写一个数，必须大于 0</p>\n</li>\n<li>\n<p>返回值：</p>\n<p>-1 : 失败</p>\n<blockquote>\n<p>0 : 文件描述符，指向 epoll 实例的描述符</p>\n</blockquote>\n</li>\n</ul>\n<pre><code class=\"language-C++\">typedef union epoll_data &#123;\n    void *ptr;\n    int fd;\n    uint32_t u32;\n    uint64_t u64;\n&#125; epoll_data_t;\nstruct epoll_event &#123;\n    uint32_t events; /* Epoll events */\n    epoll_data_t data; /* User data variable */\n&#125;;\n</code></pre>\n<p>常见的 Epoll 检测事件：</p>\n<ul>\n<li>EPOLLIN</li>\n<li>EPOLLOUT</li>\n<li>EPOLLERR</li>\n</ul>\n<p>// 对 epoll 实例进行管理：添加文件描述符信息，删除信息，修改信息</p>\n<p><strong>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</strong></p>\n<ul>\n<li>\n<p>参数：</p>\n<ul>\n<li>\n<p>epfd : <strong>epoll 实例对应的文件描述符</strong></p>\n</li>\n<li>\n<p>op : 要进行什么操作</p>\n<p>EPOLL_CTL_ADD: 添加</p>\n<p>EPOLL_CTL_MOD: 修改</p>\n<p>EPOLL_CTL_DEL: 删除</p>\n</li>\n<li>\n<p>fd : <strong>要检测的文件描述符</strong></p>\n</li>\n<li>\n<p>event : 检测文件描述符什么事情</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>// 检测函数</p>\n<p><strong>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</strong></p>\n<ul>\n<li>参数：\n<ul>\n<li>epfd : epoll 实例对应的文件描述符</li>\n<li>events : <strong>传出参数，保存了发送了变化的文件描述符的信息</strong></li>\n<li>maxevents : 第二个参数结构体数组的大小</li>\n<li>timeout : 阻塞时间\n<ul>\n<li>0 : 不阻塞</li>\n<li>-1 : 阻塞，直到检测到 fd 数据发生变化，解除阻塞</li>\n<li>0 : 阻塞的时长（毫秒）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>返回值：只返回发生变化的文件描述符到用户区\n<ul>\n<li>成功，返回发送变化的文件描述符的个数 &gt; 0</li>\n<li>失败 -1</li>\n</ul>\n</li>\n</ul>\n<p>问题：在最开始调用 epoll_ctl 把监听的文件描述符放进红黑树的时候传入了 &amp; epev，也就是 epev 的指针，为什么后面传入新的文件描述符的时候可<strong>以重用这个 epev</strong> 呢，这样重用 epev 的话前面传入的监听描述符不就被改动了嘛？</p>\n<blockquote>\n<p>epoll_ctl 会在 epoll fd 红黑树中重新添加一个节点，而不是覆盖 lfd 的节点，然后新添加的节点会关联这个 event。<br />\n至于每次重用 event，而不会影响之前的已经在 rb tree 中传入的节点，应该是拷贝了 event 的数据。</p>\n</blockquote>\n<h3 id=\"epoll的工作模式\"><a class=\"anchor\" href=\"#epoll的工作模式\">#</a> Epoll 的工作模式</h3>\n<p>.png)</p>\n<ul>\n<li>\n<p>LT 模式：水平触发（缺省工作方式）</p>\n<p>a. 用户不读数据，数据一直在缓冲区，epoll 会一直通知</p>\n<p>b. 用户只读一部分数据，epoll 会通知</p>\n<p>c. 缓冲区数据读完了，不通知</p>\n</li>\n</ul>\n<blockquote>\n<p>只要监听的文件描述符缓冲区中有数据，就会触发 epoll_wait 有返回值，内核就会通知你这个文件描述符是就绪的，这是默认的 epoll_wait 的方式。 同时支持阻塞和非阻塞</p>\n</blockquote>\n<ul>\n<li>\n<p>ET 模式：边沿触发 —— 效率高：减少 epoll 事件被重复触发的次数</p>\n<p>a. 用户不读数据，数据一直在缓冲区，epoll 下次检测不通知</p>\n<p>b. 用户只读一部分数据，epoll 不通知</p>\n<p>c. 缓冲区数据读完了，不通知</p>\n</li>\n</ul>\n<blockquote>\n<p>1. 只有监听的文件描述符的读 / 写事件发生，才会触发 epoll_wait 有返回值；比如：当 fd 文件描述符缓冲区来了 8 字节数据，内核会通知一次，你只读两个字节，内核不会通知你缓冲区还有数据（文件描述符就绪），直到你读完所有缓冲区数据，下次数据来了内核才会通知您 <strong>2. 只支持非阻塞</strong> —— 因为该模式要求最好当内核通知触发时一次性读取完所有缓冲区数据，那么就需要在<strong> while 循环</strong>中不断 read 读取数据，而 read 就得设置成非阻塞，否则就会卡在那。<strong>必须使用非阻塞套接字</strong>，避免由于一个文件描述符的阻塞读 / 写把处理多个文件描述符任务饿死</p>\n</blockquote>\n<pre><code class=\"language-C++\">struct epoll_event &#123;\n    uint32_t events; /* Epoll events */\n    epoll_data_t data; /* User data variable */\n&#125;;\n常见的Epoll检测事件：\n    EPOLLET             边沿触发（在accept后设置event）\n    EPOLLIN\n    EPOLLOUT\n</code></pre>\n<blockquote>\n<p>EPOLLONESHOT：即使可以使用 ET 模式，<strong>一个 socket 上的某个事件还是可能被触发多次</strong>。这在并发程序中就会引起一个 问题。比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据的处理过程中该 socket 上又有新数据可读（EPOLLIN 再次被触发），此时另外一个线程被唤醒来读取这些新的数据。于 是就出现了两个线程同时操作一个 socket 的局面。<strong>一个 socket 连接在任一时刻都只被一个线程处理，可 以使用 epoll 的 EPOLLONESHOT 事件实现</strong>。 对于注册了 EPOLLONESHOT 事件的文件描述符，<strong>操作系统最多触发其上注册的一个可读、可写或者异 常事件，且只触发一次，除非我们使用 epoll_ctl 函数重置该文件描述符上注册的 EPOLLONESHOT 事 件</strong>。这样，当一个线程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的。但反过来思考，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， 该线程就应该立即重置这个 socket 上的 EPOLLONESHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能被触发，进 而让其他工作线程有机会继续处理这个 socket。</p>\n</blockquote>\n<p>epoll 更在细致的执行流程</p>\n<ul>\n<li>创建内核事件表（epoll_create）。这里主要是向内核申请创建一个 fd 的文件描述符作为内核事件表（<strong>B + 树结构的文件</strong>，没有数量限制），这个描述符用来保存应用进程需要监控哪些 fd 和对应类型的事件。 （简单理解<strong>内核申请一个 B + 树来监听事件</strong>）</li>\n<li>添加或移出监控的 fd 和事件类型（epoll_ctl）。调用此方法可以是向内核的内核事件表 动态的添加和移出 fd 和对应事件类型。</li>\n<li><strong>epoll_wait 绑定回调事件</strong>：<strong>内核向事件表的 fd 绑定一个回调函数</strong>。当监控的<strong> fd 活跃</strong>时，会调用 callback 函数<strong>把事件加到一个活跃事件队列</strong>里；最后在 epoll_wait 返回的时候内核会把<strong>活跃事件队列里的 fd 和事件类型返回给应用进程</strong>。</li>\n</ul>\n<p>总结：</p>\n<ul>\n<li>最后，从 epoll 整体思路上来看，采用<strong>事先就在内核创建一个事件监听表</strong>，后面只需要往里面添加移出对应事件，因为本身事件表就在内核空间，所以就避免了向 select、poll 一样每次都要把自己需要监听的事件列表传输过去，然后又传回来，这也就避免了事件信息需要在用户空间和内核空间相互拷贝的问题。</li>\n<li>然后 epoll 并不是像 select 一样去遍历事件列表，然后逐个轮询的监控 fd 的事件状态，而是<strong>事先就建立了 fd 与之对应的回调函数</strong>，当事件激活后主动回调 callback 函数，这也就避免了遍历事件列表的这个操作，所以 epoll 并不会像 select 和 poll 一样随着监控的 fd 变多而效率降低，这种事件机制也是 epoll 要比 select 和 poll 高效的主要原因。</li>\n</ul>\n",
            "tags": [
                "C++",
                "项目",
                "Linux高性能服务器编程",
                "Linux网络编程：socket、IO复用、epoll",
                "C++",
                "项目",
                "webserver",
                "Linux网络编程：socket、IO复用、epoll"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/15/bug/",
            "url": "https://aristotlednzk.github.io.com/2022/10/15/bug/",
            "title": "bug",
            "date_published": "2022-10-15T02:23:58.000Z",
            "content_html": "<h1 id=\"bug\"><a class=\"anchor\" href=\"#bug\">#</a> bug</h1>\n",
            "tags": [
                "bug",
                "bug"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/14/GAN%E8%AF%BE%E9%A2%98/%E7%9B%B8%E6%9C%BA%E6%89%8B%E7%9C%BC%E6%A0%87%E5%AE%9A/%E7%9B%B8%E6%9C%BA%E6%89%8B%E7%9C%BC%E6%A0%87%E5%AE%9A/",
            "url": "https://aristotlednzk.github.io.com/2022/10/14/GAN%E8%AF%BE%E9%A2%98/%E7%9B%B8%E6%9C%BA%E6%89%8B%E7%9C%BC%E6%A0%87%E5%AE%9A/%E7%9B%B8%E6%9C%BA%E6%89%8B%E7%9C%BC%E6%A0%87%E5%AE%9A/",
            "title": "相机手眼标定",
            "date_published": "2022-10-14T08:29:02.000Z",
            "content_html": "<h2 id=\"1-眼在手上的手眼标定\"><a class=\"anchor\" href=\"#1-眼在手上的手眼标定\">#</a> 1、眼在手上的手眼标定</h2>\n<p><img data-src=\"https://img-blog.csdnimg.cn/dc166d3e745d411b8deff1c07d6bca08.png\" alt=\"眼在手上的手眼标定\" /></p>\n<p>基础坐标系（用 base 表示） 是机器臂的基底坐标系，末端坐标系（用 end 表示） 是机器臂的末端坐标系， 相机坐标系（用 cam 表示） 是固定在机器臂上面的相机自身坐标系，标定物坐标系（用 cal 表示）是标定板所在的坐标系。任意移动两次机器臂，由于标定板和机器臂的基底是不动的，因此对于某个世界点，其在 base 坐标系和 cal 坐标系下的坐标值不变，在 end 坐标系和 cam 坐标系下的坐标值随着机器臂的运动而改变。根据这一关系，可以求解出 end 坐标系和 cam 坐标系之间的转换矩阵。</p>\n<hr />\n",
            "tags": [
                "GAN课题",
                "GAN课题"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/",
            "url": "https://aristotlednzk.github.io.com/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/",
            "title": "生成对抗网络",
            "date_published": "2022-10-12T13:34:29.000Z",
            "content_html": "<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL2k2WXVRZkcyTkUxaGJienRpUkJMWGU=\">GAN 开山之作论文</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8yNjczNTkzMy9hcnRpY2xlL2RldGFpbHMvMTA4OTI1MjMy\">https://blog.csdn.net/weixin_26735933/article/details/108925232</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNzg1MjEzODM=\">https://zhuanlan.zhihu.com/p/378521383</span></p>\n<p>GAN 架构包含两个子模式，分别称为<strong> Generator (G) 和</strong> Discriminator (D) ，它们相互竞争，目的是通过训练过程达到 Nash 平衡。 生成器学习将潜在空间 (例如，噪声〜N <em>(0,1)</em> ) 映射到在其上分发给定数据样本的数据空间，鉴别器评估生成器完成的映射。 生成器的主要作用是生成模仿训练数据集的合成数据，以使鉴别器无法将合成数据与真实数据区分开。</p>\n<p>生成器的输入是随机噪声矢量_x'_ (通常是均匀或正态分布)。 噪声向量通过 Generator 映射到新的数据空间，以获得伪样本_G (x')_ ，它是多维向量。 鉴别器是一个二进制分类器，它吸收了生成的数据集和训练的数据集，并学习将它们分类为假的和真实的。** 当判别器无法确定数据来自真实数据集还是生成器时，便会达到 GAN 模型的最佳状态 **</p>\n<p><img data-src=\"/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/GAN.png\" class=\"\" title=\"GAN\"></p>\n<hr />\n<h2 id=\"可解释的生成对抗网络infogan\"><a class=\"anchor\" href=\"#可解释的生成对抗网络infogan\">#</a> 可解释的生成对抗网络：InfoGAN</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NTk0NTE2NA==\">https://zhuanlan.zhihu.com/p/55945164</span></p>\n<p>在<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NDA5NjM4MQ==\">生成对抗网络 (GAN) 背后的数学理论</span> 提到，generator 和 discriminator 的对抗学习，它的目标其实是得到一个与 real data 分布一致的 fake data 分布。</p>\n<p>但是由于 generator 的输入是一个<strong>连续的噪声信号</strong>，并且<strong>没有任何约束</strong>，导致 GAN 将 z 的具体维度与 output 的语义特征对应起来，可解释性很差。</p>\n<p>它的原理很简单，在 info GAN 里面，把输入向量 z 分成两部分，c 和 z'。c 可以理解为可解释的隐变量，而 z 可以理解为不可压缩的噪声。希望通过约束 c 与 output 的关系，<strong>使得隐变量 c 的维度对应 output 的语义特征</strong>，以手写数字为例，比如笔画粗细，倾斜度等。</p>\n<p>为了引入 c，作者<strong>通过互信息的方式来对 c 进行约束</strong>，也可以理解成自编码的过程。具体的操作是，generator 的 output，经过一个分类器，看是否能够得到 c。其实可以看成一个 anto-encoder 的反过程。其余的 discriminator 与常规的 GAN 是一样的。</p>\n<p><img data-src=\"https://pic1.zhimg.com/80/v2-b85a31bbe8ed2b42a3ad11a707720674_720w.jpg\" alt=\"img\" /></p>\n<p>图片来自李宏毅老师生成对抗网络视频 https://www.youtube.com/watch?v=DMA4MrNieWo&amp;list=PLJV_el3uVTsMq6JEFPW35BCiOQTsoqwNw&amp;index=5</p>\n<p>在实际过程中，classifier 和 discriminator 会共享参数，只有最后一层是不一样的，classifier 输出的是一个 vector, discriminator 输出的是一个标量。</p>\n<hr />\n<h2 id=\"第一章\"><a class=\"anchor\" href=\"#第一章\">#</a> 第一章：</h2>\n<p>生成器的优点在于生成很容易，但只学习了真实样本的表象，只学到了 component 和 component 像素和像素之间的相似度，而没有学到图像和图像的关联。可以用生成器取代下面方程，产生负样本，产生 x~</p>\n<p>以往是通过高斯混合模型定义 PG 然后用最大似然估计算出最优分布 PG 下的参数 sita，但这个模型可能更复杂，不用高斯…… 又难以计算。而现在用生成器找到一个分布，也就是用生成器可以生成一个很复杂的分布 PG。<strong>生成器 G 意图让生成的样本 PG 和真实样本 Pdata 之间的散度越小越好</strong></p>\n<p><img data-src=\"/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/GAN1.png\" class=\"\" title=\"GAN1\">PG 可以通过生成器的向量中生成，一张张图片，Pdata 可以通过真实数据集采样得到 那么如何通过生成器计算 PG 和 Pdata 的散度呢</p>\n<p>判别器优点在于能够学到整个图像的关联，但很难生成图像，需要解 x~=arg max D (x）方程</p>\n<p>1. 如何训练判别器 D 呢，首先固定 G，寻找让 max V (G,D) 的 D,。对每一个 x，都可以找一个不同的 D 让式子最大</p>\n<p><img data-src=\"/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/GAN2.png\" class=\"\" title=\"GAN2\"></p>\n<p>&lt;img src=&quot;生成对抗网络 / GAN3.png&quot; alt=&quot;GAN3&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>&lt;img src=&quot;生成对抗网络 / GAN4.png&quot; alt=&quot;GAN4&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>第一步：固定 G，寻找 D，让 V 函数 max<br />\n 第二步：在寻找到的 D 基础上固定不动，寻找让 maxV 最小的 G</p>\n<p><img data-src=\"/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/GAN5.png\" class=\"\" title=\"GAN5\"></p>\n<h1 id=\"第四章基础理论\"><a class=\"anchor\" href=\"#第四章基础理论\">#</a> 第四章：基础理论</h1>\n<p><img data-src=\"/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/GAN6.png\" class=\"\" title=\"GAN6\"></p>\n<p>首先给定 G，找到 D<em> 并求出 V 对 sitaG 的梯度，用于更新 sitaG 找一个 D</em> 从而 maxV 的过程就是找到 Pdata 和 PG 之间的 JS 散度 V (G1,D1*) 的过程</p>\n<p><img data-src=\"/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/GAN7.png\" class=\"\" title=\"GAN7\"></p>\n<p>关键是：<strong>当更新 G0 后函数 V 可能会变化</strong>，而此时的 D*（使 V 最大的横坐标位置）可能就变了，再用之前的 D * 训练就不靠谱。因此只能每次更新 G 一点点，假设每次更新后函数变化很小和之前是类似的，因此不太可能出现右图情况。 <strong>因此生成器 G 不能训练太多，通常只更新一次</strong></p>\n<p><img data-src=\"/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/GAN8.png\" class=\"\" title=\"GAN8\"></p>\n<p>期望 E 计算：实际上只能通过离散叠加求均值的方法来计算 V，实际上是从 Pdata 和 PG 中采样出一堆 x 来代替期望 E，训练一个二分类分类器→最小化交叉熵 = maxV</p>\n<p>训练判别器的目的是：为了评估 JS 散度 从 Pdata 中采用出一堆 x 作为正样本，从 PG 中采样出一堆 x 作为负样本</p>\n<p><img data-src=\"/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/GAN9.png\" class=\"\" title=\"GAN9\"></p>\n<p>每轮训练迭代过程：</p>\n<p>1. 根据 Pdata（x）中采样 m 个 x，从先验分布中采样 m 个噪声向量 z→输入生成器→得到 m 个生成样本，更新判别器参数 sitad 从而→maxV</p>\n<p><strong>训练判别器目的</strong>：为了估计 JS 散度才训练判别器，而用于估计 JS 散度的最优判别器的目标函数 V 是最大的，为了使其最大必定需要多轮重复迭代训练→直到收敛→<strong>可以更新 k 次</strong></p>\n<p>** 训练生成器目的：** 为了最小化 JS 散度，而由于生成器每次训练会导致目标函数变化，<strong>因此每次只训练更新一次</strong></p>\n<p><img data-src=\"/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/GAN10.png\" class=\"\" title=\"GAN10\"></p>\n<hr />\n<h2 id=\"fgan框架\"><a class=\"anchor\" href=\"#fgan框架\">#</a> fGAN 框架</h2>\n<p>用不同 f - 散度量生成样本和真实样本的差距 p (x) 和 q（x）分别代表从 x 从 p 分布和从 q 分布采样出来的几率 p 和 q 之间的散度：</p>\n<hr />\n<h2 id=\"info-ganvae-gan-bigan\"><a class=\"anchor\" href=\"#info-ganvae-gan-bigan\">#</a> Info GAN,VAE GAN, BiGAN</h2>\n<p>编码器和解码器输入输出不相连，判别器输入 z 和图像，判断是来自编码器还是解码器</p>\n<p><img data-src=\"/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/GAN11.png\" class=\"\" title=\"GAN11\"></p>\n<p><img data-src=\"/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/GAN12.png\" class=\"\" title=\"GAN12\"></p>\n",
            "tags": [
                "GAN课题",
                "生成对抗网络",
                "GAN课题"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/12/philosophy/%E7%8E%B0%E8%B1%A1%E5%AD%A6-%E8%83%A1%E5%A1%9E%E5%B0%94/%E7%8E%B0%E8%B1%A1%E5%AD%A6-%E8%83%A1%E5%A1%9E%E5%B0%94/",
            "url": "https://aristotlednzk.github.io.com/2022/10/12/philosophy/%E7%8E%B0%E8%B1%A1%E5%AD%A6-%E8%83%A1%E5%A1%9E%E5%B0%94/%E7%8E%B0%E8%B1%A1%E5%AD%A6-%E8%83%A1%E5%A1%9E%E5%B0%94/",
            "title": "现象学/胡塞尔",
            "date_published": "2022-10-12T13:29:08.000Z",
            "content_html": "<h1 id=\"现象学胡塞尔\"><a class=\"anchor\" href=\"#现象学胡塞尔\">#</a> 现象学 —— 胡塞尔</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tLzdjWFlOenFDSHY2eGdHR3hHcTc0aVI=\">事物的本质及认识</span></p>\n<p>胡塞尔的现象学关注的是 “认识如何可能”<strong>（认识的过程）的问题，是对认识本身的批判，这是反对以往的科学仅仅关注 “认识的对象” 而并不关注</strong>认识本身 ** 提出的。</p>\n<p>胡塞尔的核心命题就在解释：<strong>认识如何可能，或我们认识是否能与内在事物一致的问题</strong>（我们能不能清除一切对实存的主观设定，而完全客观地看待事物本身）。</p>\n<p>在胡塞尔那里，<strong>被给予性</strong>意味着 ：一个东西 “没有表述其他什么”“没有超越自身去意指什么” 它所展示的东西完全都是自身被给予的东西，胡塞尔认为人的 “思维” 就是这样一种东西，而以往的所有科学研究中，研究者都是带有主观设定和滤镜去看的，因此所有的物在科学研究那里都无法具有 “绝对的被给予性”，都是不可靠的。</p>\n<p>在胡塞尔那里，“意向性” 作为现象学的 “不可或缺的起点概念和基本概念” 标志着所有意识的本己特性，即：所有意识都是 “关于某物的意识” 并且作为这样一种意识而可以得到直接的指明和描述。关于某物的意识是指在广义上的意指行为与被意指之物本身之间可贯通的相互关系。</p>\n<p>对 “意向性” 之把握的惟一途径在胡塞尔看来是本质直观的反思：“在意向性被反思揭示并因此而自身成为课题之前，它始终是隐蔽着的”</p>\n",
            "tags": [
                "哲学社科",
                "西哲",
                "哲学社科"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/12/%E8%BF%9C%E8%A1%8C%E8%80%85%E5%BC%80%E7%AF%87/%E8%BF%9C%E8%A1%8C%E8%80%85%E5%BC%80%E7%AF%87/",
            "url": "https://aristotlednzk.github.io.com/2022/10/12/%E8%BF%9C%E8%A1%8C%E8%80%85%E5%BC%80%E7%AF%87/%E8%BF%9C%E8%A1%8C%E8%80%85%E5%BC%80%E7%AF%87/",
            "title": "远行者开篇",
            "date_published": "2022-10-12T08:52:06.000Z",
            "content_html": "<h2 id=\"初衷\"><a class=\"anchor\" href=\"#初衷\">#</a> 初衷</h2>\n<p>抱着将博客作为云笔记软件来用的想法，历时两天才醒悟，还是继续当个牌面吧……</p>\n<h3 id=\"后续\"><a class=\"anchor\" href=\"#后续\">#</a> 后续</h3>\n<p>Maybe 日后还有别的用途？比如不定期更新个人读书笔记、随想录之类……</p>\n",
            "tags": [
                "言",
                "言"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/11/%E9%97%BB%E8%AF%B4/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/",
            "url": "https://aristotlednzk.github.io.com/2022/10/11/%E9%97%BB%E8%AF%B4/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/",
            "title": "亲密关系",
            "date_published": "2022-10-11T11:30:59.000Z",
            "content_html": "<h1 id=\"亲密关系\"><a class=\"anchor\" href=\"#亲密关系\">#</a> 亲密关系</h1>\n<p>练习：写下初遇时在伴侣身上发现的所有优点和相处至今的优点，另一张纸上写现在在对方身上看到的缺点，第一张表上列的每一项得十分，第二章表上列的扣十分</p>\n<p>1、最初被某人吸引通常是由于情绪上的需求，这些需求来源于孩提时代未被满足的需要。孩童时期的主要需求：寻求归属感 —— 证明自己具有特殊价值 ——“想要变得特别”<br />\n 期待一个能无视我们所有缺点并且对自己的需求极大的人。</p>\n<p>2、制造梦想的机器：从童年时期就开始绘制能满足自己一切期待的理想对象，随着年龄增长，期望越来越高<br />\n 3、如果在现实中寻觅不到就开始在相处中对她未满足自己需求的方面进行改造</p>\n<h2 id=\"月晕期\"><a class=\"anchor\" href=\"#月晕期\">#</a> 月晕期</h2>\n<h3 id=\"通往地狱之路是用期望铺成的\"><a class=\"anchor\" href=\"#通往地狱之路是用期望铺成的\">#</a> 通往地狱之路，是用期望铺成的</h3>\n<p>期待与要求分为明说和暗示，在需求得到满足前我们不愿意去爱。</p>\n<p>然而我的期望让我不能得到安抚，期望的目的是要让需求得到满足，但与此同时必然会出现两件事：<br />\n（1）我们内心缺乏爱，如果我们需要 sth，是因为我们没有<br />\n（2）如果没有 sb 满足我们的需求，我们会觉得世界上没有足够的爱 —— 希望从他人身上得到爱只会让 “无人爱我” 的想法更牢不可破</p>\n<p>因此期望是愤恨的前兆</p>\n<hr />\n<p>       在对亲密关系不满意时问问自己，此时希望从伴侣身上得到的是什么？本质上是情绪上的事物，表面上看来则是实质的需求。</p>\n<p>例：约好七点见面，但她八点才来，我不高兴但<strong>真正原因不是她迟到而是她让我觉得自己不够特别</strong> —— 我希望她让我觉得自己很重要，重要到她应该愿意为了我而守时</p>\n<p>了解自己期望背后的需求，我们通常只是希望伴侣做或说一些事，但却不会意识到我们希望他们这么做其实是满足自己某些情绪上的需求 —— 我们希望曲儿我们值得被爱</p>\n<p>想象力、意向和直觉</p>\n<p>灵魂思考的方式 —— 直觉</p>\n<p>当找到自己真正的情绪需求后再问自己：我愿不愿意放弃这项期望呢 —— 我愿不愿意寻求自己内在的力量来满足我的所有需求呢？</p>\n<p>如果答案是肯定的，那么<strong>直觉会告诉你该如何放手了</strong></p>\n<p><strong>如果你有精神上的信仰，那么不妨把需求交给内心中高层次的力量</strong></p>\n<hr />\n<h3 id=\"如果决定放手那么如何满足需求呢事实是我们并不需要自己认为需要的东西\"><a class=\"anchor\" href=\"#如果决定放手那么如何满足需求呢事实是我们并不需要自己认为需要的东西\">#</a> 如果决定放手，那么如何满足需求呢？\n—— 事实是，我们并不需要自己认为需要的东西</h3>\n<p>学会放手和接纳，明白自己原本就是一个完整的个体，所需的一切都存在于你的内心</p>\n<hr />\n<h2 id=\"幻灭期\"><a class=\"anchor\" href=\"#幻灭期\">#</a> 幻灭期</h2>\n<p>随着愤恨的到来，标志着进入第二阶段 —— 幻灭</p>\n<p>幻灭带来偏差行为：<br />\n引起注意、权力斗争：满足孩子的两大需求<br />\n报复心理、自我放逐：当孩子觉得需求永远不会被满足时被深刻的沮丧痛苦驱使做出毁灭性行为</p>\n<p>       远离造成痛苦的人并不会让痛苦消失，伴侣只是让我发觉到痛苦的存在。唤醒过去的伤痛，想要疗伤的企图往往导致亲密关系危机，和伴侣吵架只是为了不去感受旧痛，而伴侣所做的仅仅是让旧痛浮上意识表层。</p>\n<hr />\n<h2 id=\"信念想法的果实\"><a class=\"anchor\" href=\"#信念想法的果实\">#</a> 信念：想法的果实</h2>\n<p>种下想法，就得到行动。种下行动，就得到习惯。<br />\n种下习惯，就得到人格。种下人格，就得到命运。</p>\n<p>过去的创伤并不会随时间逝去，每个自我局限的信念都来自过去的创伤、痛苦的经验。所有未愈合伤口的信念都是自我局限的，</p>\n<p>——<strong> 如果离开家的时候，你并不感到平静，那么你其实并没有离开</strong></p>\n<p>亲密关系中蕴含着治好旧伤的机会。而大多数情况是双方都试图控制对方的行为，借以控制过去的创伤。</p>\n<p><img data-src=\"/2022/10/11/%E9%97%BB%E8%AF%B4/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB-16660629207261.png\" class=\"\" title=\"亲密关系\"></p>\n",
            "tags": [
                "阅读笔记",
                "阅读笔记"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/11/philosophy/%E7%8E%8B%E9%98%B3%E6%98%8E%E5%BF%83%E5%AD%A6/",
            "url": "https://aristotlednzk.github.io.com/2022/10/11/philosophy/%E7%8E%8B%E9%98%B3%E6%98%8E%E5%BF%83%E5%AD%A6/",
            "title": "王阳明心学",
            "date_published": "2022-10-11T11:29:15.000Z",
            "content_html": "<h1 id=\"王阳明心学\"><a class=\"anchor\" href=\"#王阳明心学\">#</a> 王阳明心学</h1>\n<p>一、人具有无限心</p>\n<blockquote>\n<p>人作为时间性存在，总是以筹划尚不存在的未来的形式活在当下 —— 证明了人心的无限性 —— 能超越现实；因而烦恼从中来。</p>\n<ul>\n<li>\n<p>关键在于安顿无限心。</p>\n<p>在官场上，中国政治的传统模式一天不变，中南海和秦城监狱之间就一步之遥。高官俸禄之有限，<strong>而无限心无法安顿在有限的事物上，因为现实世界的事物无一不是有限的。因此无限心只能安顿在超越现实的世界中（出世 —— 从现实世界的利害中超拔出来），而无法安顿在现实世界中</strong>。</p>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ol>\n<li>\n<p>儒家：无所为而为。如果从未出世，那么做事总是有所为而为，做事都有目标目的，始终把自己做的事情看作是达到另外一个目的手段。<br />\n无所为而为 —— 这件事本应当做，它就是自己的价值 </p>\n</li>\n<li>\n<p>道家：无为而无不为。不以人为的方式做事。人 + 为 = 伪 = 造作，生非贵之所能存，身非爱之所能厚，遇矛盾先将属于自己的<strong>人为因素去除</strong>，在最终还是不得不去处理时再去做，时机恰到好处，方法顺应天道。最好的人生就是没有目标的人生。</p>\n</li>\n<li>\n<p>佛家：无心而为。每个人做什么自有来历 —— 业力。<strong>做事就是消业，不求结果，最好没有结果，若有结果则旧业未消又增新业。但凡事都有结果，力求结果与己无关。</strong> 认真做事，但对结果漠不关心 ——<strong> 除心不除事</strong></p>\n<p>业力：每个人都生来带着业力</p>\n</li>\n</ol>\n</blockquote>\n<p>人并非拥有选择自己拥有某种愿望的能力，只是拥有选择实现愿望的道路的能力，什么愿望来到我们心里并不是我们的自由，愿望就这么来了……</p>\n<hr />\n<p>插入：</p>\n<ul>\n<li>西方哲学 —— 自身问题：关于世界的客观知识的前提基础是什么，获得客观可靠有效知识的方法是什么</li>\n<li>中国哲学 —— 人生问题；佛学中国化（两汉之际）禅宗，儒道佛合流 (两宋时期)—— 王阳明心学</li>\n</ul>\n<hr />\n<p>一体之仁，当我们对鸟兽虫鱼的哀鸣生出恻隐之心，当我们与鸟兽虫鱼连为一体，人心感通宇宙万物，中国宇宙观。心之理 —— 不是心外之理，真理不要到心外去寻求 —— 万物皆备于我，反身而成，乐莫大焉。上乘孟子 “学问之道无他，求其放心而已”，学问 —— 已经被亡失的心重新召回。</p>\n<p>《金刚经》核心思想 ——<strong> 因无所住而生其心</strong></p>\n<blockquote>\n<p>佛学中国化：禅宗 16 字法门：教外别传，不立文字，直指人心，见性成佛</p>\n</blockquote>\n<ul>\n<li>不求出离生死之苦海，自性若迷。</li>\n<li>不睹众相常观金体。</li>\n<li>六色 —— 眼耳鼻舌身意 —— 着相；观金体本身 —— 不住相。</li>\n<li>佛法在世间，不离世间觉。离世觅菩提，恰如求兔角。</li>\n</ul>\n<p>&lt;div align=&quot;center&quot;&gt; &lt;img src=https://tva3.sinaimg.cn/large/0071tL0Nly8h760vrtpq6j30u00u0myt.jpg width=60%/&gt; &lt;/div&gt;</p>\n",
            "tags": [
                "哲学社科",
                "中哲",
                "哲学社科"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/11/computer-science/%E8%BD%AC%E7%A0%81%E4%B9%8B%E8%B7%AF/",
            "url": "https://aristotlednzk.github.io.com/2022/10/11/computer-science/%E8%BD%AC%E7%A0%81%E4%B9%8B%E8%B7%AF/",
            "title": "转码之路",
            "date_published": "2022-10-11T11:26:24.000Z",
            "content_html": "<h1 id=\"转码之路\"><a class=\"anchor\" href=\"#转码之路\">#</a> 转码之路</h1>\n<p>鱼皮学习路线<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vbGl5dXBpL2NvZGUtcm9hZG1hcC9ibG9iL21haW4vZG9jcy9yb2FkbWFwL0phdmElRTUlQUQlQTYlRTQlQjklQTAlRTglQjclQUYlRTclQkElQkYubWQjaHR0cHM6Ly9naXRlZS5jb20vbGluaz90YXJnZXQ9aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2ludGVsbGlnZW50VGVzdA==\"> https://gitee.com/liyupi/code-roadmap/blob/main/docs/roadmap/Java 学习路线.md#https://gitee.com/link?target=https%3A%2F%2Fwww.nowcoder.com%2FintelligentTest</span></p>\n<p>API 在线文档<span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29sLm9zY2hpbmEubmV0L2FwaWRvY3MvYXBpZG9jP2FwaT1qZGtfN3U0\"> https://tool.oschina.net/apidocs/apidoc?api=jdk_7u4</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tLzN4QjlGQkZMVmhkMWk2dWNmZ3NIR0I=\">面经资料</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tLzJMTGpnZGdjM25pZ1l4WnFSakhRRUU=\">岗位分析</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL3dkakU3WEdRNzhmTURUZnFTTXpTU0M=\">简历</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL2NhelNUZm1iTkgxTjE0OThUM1dmUUc=\">后端指导大纲</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tLzJQOUVTVFRxdUhpOUhtdTFVQVpVVlI=\">GIT</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL2dvSzl5Rnlud29lOWlQdU43aWVETlU=\">Linux</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL3I0NGFVUWlkUkVtUEFxTU14QWhHdUY=\">C++</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tLzRHRlhoMW95N2pyblhMMW1vclhyN28=\">力扣刷题笔记</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL2plYmJYOG9uZG1VRUtqaWlRd01rOTY=\">JAVA 基础笔记</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tLzRzYkt1TmtRc0NyVkY5Z0tESkMyaFg=\">MySQL（DB）</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL2VXZ0F6OTdEaTdjZHZpcThtU1o3cXM=\">JVM</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL2oyeVF6QVlHSjk2SHlWa3JHZ25GTFY=\">JUC 并发编程</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL2UyUzNHZjZ4VkJtS3p3VVk3N2tqUnc=\">三件套</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL3FMRHRaMXlBOUZhV3g4dkQxcVlBN1c=\">排序算法</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tLzlFaFl6RnF5V1hZY0Ryc2VtdjhidTE=\">Spring 框架</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tLzYyWlI1bTJBVER6OFoyUXdTN21rTTE=\">Redis</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tLzlDWUFFell4RXY3bzdoUnoxWHN3Q0E=\">Docker</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL2p5VkdDdGZSYzRDeTFmaVlVWW1CdUI=\">Acwing 算法基础课</span></p>\n<p><img data-src=\"D:%5CWolai%5C%E7%AC%94%E8%AE%B0%5C%E8%BD%AC%E7%A0%81%E4%B9%8B%E8%B7%AF%5Cimage%5Cimage_v6vkTMI4J5.png\" alt=\"\" /></p>\n<h2 id=\"java学习路线一\"><a class=\"anchor\" href=\"#java学习路线一\">#</a> Java 学习路线一</h2>\n<p>牛客链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2Rpc2N1c3MvNDY0NzUwP3R5cGU9cG9zdCZhbXA7b3JkZXI9cmVjYWxsJmFtcDtwb3M9JmFtcDtwYWdlPTEmYW1wO25jVHJhY2VJZD0mYW1wO2NoYW5uZWw9LTEmYW1wO3NvdXJjZV9pZD1zZWFyY2hfcG9zdF9uY3RyYWNrJmFtcDtnaW9faWQ9QjcyMkIxMkMyODNEN0MwRDAxQzFCRDUxNTY5QTU2OTYtMTY1Nzg3Mzk3MDUwNA==\">https://www.nowcoder.com/discuss/464750?type=post&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack&amp;gio_id=B722B12C283D7C0D01C1BD51569A5696-1657873970504</span>  </p>\n<p>1 JVM</p>\n<p>内存模型、垃圾收集<a href=\"/jump/super-jump/word?word=%E7%AE%97%E6%B3%95\" title=\"算法\">算法</a>与垃圾收集器、内存溢出与内存泄漏是重点，JVM 调优也学一下；</p>\n<p>2 spring</p>\n<p>3 springmvc</p>\n<p>4 mybatis</p>\n<p>5 springboot</p>\n<p>框架不但要会用，也要能清晰原理比如自动配置的原理；</p>\n<p>6 多线程 同步 并发等（这很重要）</p>\n<p>生产者消费者模式代码、synchronized、lock、各种锁机制和锁升级；</p>\n<p>7 一些常见的数据结构与<a href=\"/jump/super-jump/word?word=%E7%AE%97%E6%B3%95\" title=\"算法\">算法</a>的底层 比如 Hash 、ConcurrentHashMap、LinkedHashMap、LRU (LRU 要会自己敲底层实现，其实跟 LinkedHashMap 差不多)；</p>\n<p>8 设计模式</p>\n<p>关于设计模式我并没有单独拎出来学习，而是在学框架的时候用到了什么就补充了一下。</p>\n<p>比如学到 bean 的作用范围的时候补充学习了一下单例模式；</p>\n<p>学 IOC 的时候补充学习了一下工厂模式；</p>\n<p>学 AOP 的时候补充学习了代理模式；</p>\n<p>学习 Redistemplate 的时候补充学习了模板模式；</p>\n<p><strong>强化阶段：（强化阶段学的还不太好，会在毕业前进行再强化）</strong></p>\n<p>1 <a href=\"/jump/super-jump/word?word=redis\" title=\"redis\">redis</a>（很重要，务必要熟练掌握，好像每次面试都被问到了）</p>\n<p>热 key 和大 key 问题、击穿、穿透、雪崩、数据类型底层、RDB&amp;AOF、实现消息中间件（发布者订阅者模式）、过期与淘汰策略。</p>\n<p>2 分布式（主要学的分布式锁 分布式事务）</p>\n<p>3 微服务</p>\n<p>4 消息中间件（我努力加强）</p>\n<h2 id=\"学习路线3\"><a class=\"anchor\" href=\"#学习路线3\">#</a> 学习路线 3</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY2FvbGVpQ29kaW5nL3AvNjE3MDU1NS5odG1s\">https://www.cnblogs.com/caoleiCoding/p/6170555.html</span></p>\n<h2 id=\"经验\"><a class=\"anchor\" href=\"#经验\">#</a> 经验</h2>\n<p><a href=\"https://blog.csdn.net/v123411739/article/details/115498947?ops_request_misc=%7B%22request%5Fid%22%3A%22165910547516782388038827%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=165910547516782388038827&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-4-115498947-null-null.142%5Ev35%5Eexperiment_2_v1&amp;utm_term=%E5%B0%9A%E7%A1%85%E8%B0%B7MySQL&amp;spm=1018.2226.3001.4187\" title=\"https://blog.csdn.net/v123411739/article/details/115498947?ops_request_misc=%7B%22request%5Fid%22%3A%22165910547516782388038827%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=165910547516782388038827&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-4-115498947-null-null.142^v35^experiment_2_v1&amp;utm_term=尚硅谷MySQL&amp;spm=1018.2226.3001.4187\">https://blog.csdn.net/v123411739/article/details/115498947?ops_request_misc=%7B%22request%5Fid%22%3A%22165910547516782388038827%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=165910547516782388038827&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-4-115498947-null-null.142<sup>v35</sup>experiment_2_v1&amp;utm_term = 尚硅谷 MySQL&amp;spm=1018.2226.3001.4187</a></p>\n<p><img data-src=\"D:%5CWolai%5C%E7%AC%94%E8%AE%B0%5C%E8%BD%AC%E7%A0%81%E4%B9%8B%E8%B7%AF%5Cimage%5Cimage_A80nTpU_Sw.png\" alt=\"\" /></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL2NIeEJMSENtS253ZFJSM0J0MTFWNFU=\">IDEA 架构</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL3FNeFRSVDdIYmQ3NndzNUxXQlhYYzU=\">配置环境</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL3hnRjVVclpTNzdFRHJMcGhrQWFMMlE=\">设计模式</span></p>\n<hr />\n<h2 id=\"神的博客笔记\"><a class=\"anchor\" href=\"#神的博客笔记\">#</a> 神的博客笔记：</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sdnh1ZXlhbmcudmlwL3RhZ3MvSnVjLw==\">https://lvxueyang.vip/tags/Juc/</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueXVxdWUuY29tL2Z1eXVzYWthaW9yaS95YmMyZzg/dGhlbWU9bGlnaHQ=\">https://www.yuque.com/fuyusakaiori/ybc2g8?theme=light</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tLzU0N2JKYzNwallzWmlDR21pcG5GOGE=\">英文储备</span></p>\n",
            "tags": [
                "转码之路",
                "转码之路"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/09/hello-world/",
            "url": "https://aristotlednzk.github.io.com/2022/10/09/hello-world/",
            "title": "Hello World",
            "date_published": "2022-10-09T12:55:06.990Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo new <span class=\"token string\">\"My New Post\"</span></pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo server</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo generate</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo deploy</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": []
        }
    ]
}