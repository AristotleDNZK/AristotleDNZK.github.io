{
    "version": "https://jsonfeed.org/version/1",
    "title": null,
    "subtitle": "远行者回忆录——人类往事",
    "icon": "https://aristotlednzk.github.io.com/images/favicon.ico",
    "description": "思及我域",
    "home_page_url": "https://aristotlednzk.github.io.com",
    "items": [
        {
            "id": "https://aristotlednzk.github.io.com/2022/11/15/cpp/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/",
            "url": "https://aristotlednzk.github.io.com/2022/11/15/cpp/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/",
            "title": "Linux多线程开发",
            "date_published": "2022-11-15T03:28:58.000Z",
            "content_html": "<h2 id=\"线程概念\"><a class=\"anchor\" href=\"#线程概念\">#</a> 线程概念</h2>\n<p>与进程 (process）类似，线程 (thread) 是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。(传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程)</p>\n<p><strong>进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。</strong></p>\n<p>线程是轻量级的进程（LWP: Light weight Process)，在 Linux 环境下线程的本质仍是进程。</p>\n<p>查看指定进程的 LWP 号：ps -Lf pid</p>\n<ul>\n<li>进程之间的信息难以共享</li>\n<li>fork（）创建进程的代价相对较高 —— 写时复制</li>\n<li>创建线程是共用原来的虚拟地址空间，只是<strong>栈空间和代码段.text</strong> 细分给不同线程，而堆空间都是共享的</li>\n</ul>\n<p><img data-src=\"/2022/11/15/cpp/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png\" class=\"\" title=\"多线程\"></p>\n<h2 id=\"线程创建\"><a class=\"anchor\" href=\"#线程创建\">#</a> 线程创建</h2>\n<p>main 函数所在线程称为主线程。 程序默认只有一个进程和线程</p>\n<pre><code class=\"language-C++\">pthread_t tid;\nint ret=pthread_create(&amp;tid,NULL,callback,NULL);\n\nint pthread_create(pthread_t *thread,const pthread_attr_t *attr,void *(start_routine) (void *),void *arg);\n</code></pre>\n<p>thread: 传出参数，线程创建成功后，子线程的线程 ID 被写到该变量中 attr：设置线程的属性，默认值 NULL start_routine：函数指针，<strong>这个函数是子线程需要处理的逻辑代码</strong> arg：第三个参数使用，传参</p>\n<p>返回值：成功返回 0，失败返回错误号</p>\n<h2 id=\"线程同步\"><a class=\"anchor\" href=\"#线程同步\">#</a> 线程同步</h2>\n<p>线程优势：能够通过全局变量来共享信息。但必须确保线程安全</p>\n<p>临界区：访问共享资源的代码片段，并且这段代码的执行应该为原子操作 —— 同时访问同一个共享资源的线程不能执行该区域代码到一半中断。</p>\n<p>线程同步：当有一个线程在对内存进行操作的时候，其他线程都不能对这个内存地址进行操作，知道该线程完成操作，其他线程都处于等待状态</p>\n<p><strong>终止线程</strong>：在哪个线程中调用就终止哪个线程</p>\n<pre><code class=\"language-C++\">pthread_exit(void* retval);\n</code></pre>\n<p>retval：需要传递一个指针作为返回值，可以在 pthread_join () 中获取到</p>\n<pre><code class=\"language-C++\">pthread_t pthread_self(void);\npthread_self();\n</code></pre>\n<p>获取当前的线程的线程 ID</p>\n<pre><code class=\"language-C++\">pthread_exit(NULL);\n</code></pre>\n<p>由于 return 0 会让进程退出，那所有线程资源都会被释放，因此可以在主线程中调用，让其他线程继续执行，单独<strong>让主线程退出，当主线程退出时，不会影响其他正常运行的线程</strong></p>\n<h2 id=\"互斥量\"><a class=\"anchor\" href=\"#互斥量\">#</a> 互斥量</h2>\n<p>确保同时仅有一个线程可以访问某共享资源，保证对共享资源的原子访问。</p>\n<p>互斥量有两种状态：已锁定和未锁定。至多只有一个线程可以锁定该互斥量。只有所有者才能给互斥量解锁</p>\n<p><strong>创建互斥量类型 pthread_mutex_t</strong>：一般在全局创建，在主函数 main 中初始化</p>\n<p><strong>初始化互斥量</strong></p>\n<pre><code class=\"language-C++\">int pthread_mutex_init(pthread_mutex_init *restrict mutex, const pthread_mutexattr_t attr);\n</code></pre>\n<p>mutex：需要初始化的互斥量变量 attr：互斥量相关的属性，默认 NULL</p>\n<p>restrict：C 语言修饰符，被修饰的指针不能由另外的一个指针进行操作</p>\n<p><strong>释放互斥量的资源</strong></p>\n<pre><code class=\"language-C++\">int pthread_mutex_destroy(pthread_mutex_init * mutex);\n</code></pre>\n<p><strong>加锁：阻塞的</strong>：如果已经有一个线程加锁了，那么其他线程只能阻塞等待</p>\n<pre><code class=\"language-C++\">int pthread_mutex_lock(pthread_mutex_init * mutex);\n</code></pre>\n<p><strong>解锁</strong></p>\n<pre><code class=\"language-C++\">int pthread_mutex_unlock(pthread_mutex_init * mutex);\n</code></pre>\n<h2 id=\"条件变量互斥锁\"><a class=\"anchor\" href=\"#条件变量互斥锁\">#</a> 条件变量 + 互斥锁</h2>\n<p>条件变量其实就是一种通知机制：当线程发现资源被锁定时条件变量就会将其阻塞，让出 CPU 的控制权给其他线程，当资源被释放时，那些阻塞线程被唤醒，线程重新检查资源可用性，从而获得资源并上锁或是重新阻塞。因此条件变量是一种通知模型的同步方式。</p>\n<p>条件变量一般是用于<strong>让生产者线程和消费者线程之间以及消费者线程之间互斥的访问临界资源</strong>（临界资源指的是<strong>同时只允许一个线程访问的共享资源</strong>）。条件变量的使用一般是需要结合互斥锁来进行（条件变量相关函数的输入参数就是互斥锁），从而使得各个线程能够互斥的访问该临界资源。</p>\n<p>想办法：当资源上的锁被释放时就通知等待该资源的线程，当有线程正在使用资源时就将其他想访问该资源的线程阻塞呢</p>\n<h3 id=\"二-条件变量的使用\"><a class=\"anchor\" href=\"#二-条件变量的使用\">#</a> 二 条件变量的使用</h3>\n<p>条件变量在 pthread.h 头文件中。</p>\n<h4 id=\"21-条件变量的初始化\"><a class=\"anchor\" href=\"#21-条件变量的初始化\">#</a> 2.1 条件变量的初始化</h4>\n<pre><code class=\"language-C++\">int pthread_cond_init(pthread_cond_t* *cond,const pthread_condattr_t* *cond_attr);\n</code></pre>\n<p>函数功能：用于初始化一个条件变量。</p>\n<p>函数参数：</p>\n<p>1.cond：用于指向目标条件变量。</p>\n<p>2.cond_attr：用于设置条件变量属性，置 NULL 表示条件变量属性为默认值。</p>\n<h4 id=\"22-条件变量的销毁\"><a class=\"anchor\" href=\"#22-条件变量的销毁\">#</a> 2.2 条件变量的销毁</h4>\n<pre><code class=\"language-C++\">int pthread_cond_destroy(pthread_cond_t*cond);\n</code></pre>\n<p>函数功能：用于销毁条件变量。</p>\n<h4 id=\"23-条件变量的通知机制\"><a class=\"anchor\" href=\"#23-条件变量的通知机制\">#</a> 2.3 条件变量的通知机制</h4>\n<pre><code class=\"language-C++\">int pthread_cond_signal(pthread_cond_t**cond);\nint pthread_cond_broadcast(pthread_cond_t**cond);\n</code></pre>\n<p><strong>函数功能：</strong></p>\n<p>条件变量的通知方法有两种：</p>\n<p>1. 根据线程的优先级和调度策略唤醒一个等待条件变量的线程的 pthread_cond_signal () 函数</p>\n<p>2. 唤醒所有等待条件变量的线程的 pthread_cond_broadcast () 函数。</p>\n<h4 id=\"24-条件变量的等待\"><a class=\"anchor\" href=\"#24-条件变量的等待\">#</a> 2.4 条件变量的等待</h4>\n<pre><code class=\"language-C++\">int pthread_cond_wait(pthread_cond_t**cond，pthread_mutex_t* *mutex);\nint pthread_cond_timedwait(pthread_cond_t*cond，pthread_mutex_t *mutex,const struct timespec *abstime);\n</code></pre>\n<p><strong>pthread_cond_wait</strong> 函数功能：调用该函数的线程会阻塞等待</p>\n<p>当没有容器内数据了，用于<strong>阻塞等待生产者生产数据，直到符合某个条件变量</strong>即被其他线程调用 pthread_cond_signal 唤醒才继续执行。函数的内部实现机制是：</p>\n<ul>\n<li>1. 当调用该函数前，一般会判断某个临界资源是否满足要求，如果不满足，则调用该函数，函数内部实现：<strong>将该线程挂起放在条件变量的请求队列，然后解除互斥锁</strong>（以便生产者拿到锁去生产数据）；</li>\n<li>2. 当该<strong>线程被唤醒不阻塞时，会再次对互斥锁加锁</strong>，然后返回，从而继续判断临界资源是否满足条件。</li>\n</ul>\n<p>pthread_cond_timedwait 函数功能：等待多长时间，调用了这个函数，线程会阻塞，直到指定时间结束</p>\n<h4 id=\"25-条件变量为什么要和互斥锁结合使用\"><a class=\"anchor\" href=\"#25-条件变量为什么要和互斥锁结合使用\">#</a> 2.5 条件变量为什么要和互斥锁结合使用</h4>\n<p>我个人的理解是，<strong>条件变量主要是使用一种通知机制来让各个线程来处理临界资源，但是为了保证线程安全，需要使得各个线程来互斥的访问临界资源</strong>：</p>\n<p>如果没有互斥锁，则：</p>\n<p>1. 调用条件变量通知函数唤醒所有的等待线程的话，很有可能导致临界资源被多个线程重复处理，甚至导致错误的发生，因此为了方便，每个线程被唤醒返回 pthread_cond_wait () 函数时，一般会对互斥锁加锁，这样其他被唤醒的线程只能阻塞等待此线程释放该互斥锁，从而实现互斥的对于临界资源的访问。</p>\n<p>2. 当此<strong>线程处理完临界资源后</strong>会在此调用 pthread_cond_wait () 函数，<strong>将该线程挂起至等待条件变量队列</strong>，然后释放互斥锁，让其他线程被唤醒继续处理该临界资源。</p>\n<h3 id=\"问题集\"><a class=\"anchor\" href=\"#问题集\">#</a> 问题集：</h3>\n<p><strong> <code>pthread_cond_wait内部为什么要解锁？</code> </strong></p>\n<p>如果 while 或者 if 判断的时候，满足执行条件，线程便会调用 pthread_cond_wait 阻塞自己，此时它还在持有锁，如果他不解锁，那么其他线程将会无法访问公有资源。</p>\n<p>具体到 pthread_cond_wait 的内部实现，当 pthread_cond_wait 被调用线程阻塞的时候，pthread_cond_wait 会自动释放互斥锁。</p>\n<p><strong> <code>为什么要把调用线程放入条件变量的请求队列后再解锁？</code> </strong></p>\n<p>线程是并发执行的，如果在把调用线程 A 放在等待队列之前，就释放了互斥锁，这就意味着其他线程比如线程 B 可以获得互斥锁去访问公有资源，这时候线程 A 所等待的条件改变了，但是它<strong>没有被放在等待队列上，导致 A 忽略了等待条件被满足的信号。</strong></p>\n<p>倘若在线程 A 调用 pthread_cond_wait 开始，到把 A 放在等待队列的过程中，都持有互斥锁，其他线程无法得到互斥锁，就不能改变公有资源。</p>\n<p><strong> <code>为什么最后还要加锁？</code> </strong></p>\n<p>将线程放在条件变量的请求队列后，将其解锁，此时等待被唤醒，若成功竞争到互斥锁，再次加锁。</p>\n<p><strong> <code>为什么判断线程执行的条件用while而不是if？</code> </strong></p>\n<p>一般来说，在多线程资源竞争的时候，在一个使用资源的线程里面（消费者）判断资源是否可用，不可用，便调用 pthread_cond_wait，在另一个线程里面（生产者）如果判断资源可用的话，则调用 pthread_cond_signal 发送一个资源可用信号。</p>\n<p>在 wait 成功之后，资源就一定可以被使用么？答案是否定的，如果同时有两个或者两个以上的线程正在等待此资源，wait 返回后，资源可能已经被使用了。</p>\n<p>再具体点，<strong>有可能多个线程都在等待这个资源可用的信号，信号发出后只有一个资源可用</strong>，但是有 A，B 两个线程都在等待，B 比较速度快，获得互斥锁，然后加锁，消耗资源，然后解锁，<strong>之后 A 获得互斥锁，但 A 回去发现资源已经被使用了</strong>，它便有两个选择，一个是去访问不存在的资源，另一个就是继续等待，那么<strong>继续等待下去的条件就是使用 while</strong>，要不然使用 if 的话 pthread_cond_wait 返回后，就会顺序执行下去。</p>\n<p>所以，在这种情况下，应该使用 while 而不是 if:</p>\n<pre><code class=\"language-C++\">while(resource == FALSE)  \npthread_cond_wait(&amp;cond, &amp;mutex);\n</code></pre>\n<p>如果只有一个消费者，那么使用 if 是可以的。</p>\n<h2 id=\"信号量\"><a class=\"anchor\" href=\"#信号量\">#</a> 信号量</h2>\n<p>本身不能保证线程安全，需要和互斥锁一起使用</p>\n<p><strong>信号量初始化</strong></p>\n<pre><code class=\"language-C++\">int sem_init(sem_t *sem,int pshared,unsigned int value);\n</code></pre>\n<p>value：设置信号量中的值，表示可用的资源个数。类比灯泡用一个灭一个 sem：信号量变量的地址 pshared：代表这个变量是用在线程之间（0）还是进程之间（非 0）</p>\n<p>** 加锁一个信号量：**<strong> 阻塞函数 - 对信号量值减一</strong>：当调用的信号量 sem 中的值 value 为 0 时才阻塞，<strong> 调用一次 wait，value 值 - 1</strong></p>\n<pre><code class=\"language-C++\">int sem_wait(sem_t *sem);\n</code></pre>\n<p><strong>解锁一个信号量</strong>：<strong>增加信号量的值</strong>：<strong>调用一次 value+1</strong></p>\n<pre><code class=\"language-C++\">int sem_post(sem_t *sem);\n</code></pre>\n<p><strong>释放资源</strong></p>\n<pre><code class=\"language-C++\">int sem_destroy(sem_t *sem);\n</code></pre>\n",
            "tags": [
                "cpp",
                "项目",
                "Linux高性能服务器编程",
                "Linux高性能服务器编程",
                "C++",
                "项目"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/11/15/cpp/%E5%8D%8A%E5%90%8C%E6%AD%A5-%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E7%BA%BF%E7%A8%8B%E6%B1%A0/",
            "url": "https://aristotlednzk.github.io.com/2022/11/15/cpp/%E5%8D%8A%E5%90%8C%E6%AD%A5-%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E7%BA%BF%E7%A8%8B%E6%B1%A0/",
            "title": "半同步/半反应堆线程池",
            "date_published": "2022-11-15T03:17:40.000Z",
            "content_html": "<h2 id=\"两种高效的事件处理事件分发模式\"><a class=\"anchor\" href=\"#两种高效的事件处理事件分发模式\">#</a> 两种高效的事件处理（事件分发）模式</h2>\n<ul>\n<li>Reactor 模式（反应堆）—— 依赖同步 IO，主线程中处理 IO，监听就绪事件的发生，然后通知工作线程进行读写数据（IO 操作）+ 读写完成后的处理逻辑</li>\n<li>Proactor 模式（前摄器）—— 依赖异步 IO，主线程和内核处理全部的 IO（包括读写数据），监听完成事件（异步 IO 产生的是完成信号，即信号产生时读写已经完成）的发生，然后通知工作线程进行读写完成后的处理逻辑</li>\n<li>模拟 Proactor 模式 —— Linux 中没有真正的异步 IO，AIO（aio_read 等）内部是用 pthread 模拟的（多线程 + 请求队列 + 信号等）。故使用同步 IO 来模拟 Proactor 的模式，即称为模拟 Proactor。\n<ul>\n<li>模拟 Proactor 与 Proactor 的区别是：前者的数据读写由用户完成，后者的数据读写由内核完成；</li>\n<li>模拟 Proactor 与 Proactor 的共同点是：通知给工作线程的都是完成事件，以此避免了工作线程中的读写操作（IO 操作</li>\n</ul>\n</li>\n</ul>\n<hr />\n<h2 id=\"两种高效的并发模式\"><a class=\"anchor\" href=\"#两种高效的并发模式\">#</a> 两种高效的并发模式：</h2>\n<ol>\n<li>半同步 / 半异步模式</li>\n<li>领导者 / 追随者模式</li>\n</ol>\n<p>并发模式：多个逻辑单元和 IO 处理单元之间协调完成任务的方法</p>\n<ol>\n<li>IO 模型中：同步 / 异步\n<ul>\n<li>同步 / 异步区分的是内核向应用程序通知的是何种 IO 事件（就绪 / 完成事件），以及该由谁来完成 IO 读写（应用程序还是内核）</li>\n</ul>\n</li>\n<li>并发模式中：同步 / 异步\n<ul>\n<li>同步是指程序完全按照<strong>代码序列的顺序</strong>执行</li>\n<li>异步是指程序的执行需要由<strong>系统事件来驱动</strong>（中断、信号）</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>服务器适合半同步 / 半异步模式！ 同步线程：按照同步方式运行的线程 异步线程效率更高</p>\n</blockquote>\n<h2 id=\"半同步半异步模式\"><a class=\"anchor\" href=\"#半同步半异步模式\">#</a> 半同步 / 半异步模式</h2>\n<p>同步线程用于处理客户逻辑</p>\n<p>异步线程用于处理 IO 事件：</p>\n<ul>\n<li>异步线程监听到客户请求就将其封装成请求对象插入到请求队列</li>\n<li>请求队列通知某个工作在同步模式的工作进程来读取并处理该请求对象</li>\n</ul>\n<blockquote>\n<p>具体选择哪个工作线程取决于请求队列的设计：轮流选取 Round Robin、条件变量 + 信号量随机选取</p>\n</blockquote>\n<hr />\n<ul>\n<li>半同步 / 半异步模式 —— 同步线程与异步线程结合的模式</li>\n<li>Reactor 和 Proactor 都属于半同步 / 半异步模式</li>\n</ul>\n<p>半同步 / 半异步模式中异步线程怎么分发任务给同步线程呢？（即怎么协同处理事件呢）：</p>\n<ul>\n<li>用 Reactor 模式分发 —— 半同步 / 半反应器模式</li>\n<li>用模拟 Proactor 模式分发 —— 半同步 / 半模拟前摄器模式（这个模式是我自己造的，为了分清楚概念而已）</li>\n</ul>\n<p>我的理解：</p>\n<ol>\n<li>从游双老师书上的描述来看，Reactor 和 Proactor 模式应该都是属于半同步 / 半异步模式的（Reactor 和 Proactor 都是一个异步线程分发任务给其他同步线程，与不分发任务的领导者 / 追随者模式有着本质上的不同，它们显然都是半同步 / 半异步的模式）。</li>\n<li>因此，Reactor 和 Proactor 模式又像是 “半同步 / 半异步模式” 的子分类。书上是这样描述的：“结合考虑两种事件处理模式… 半同步 / 半异步模式就存在多种变体，其中一种就是半同步 / 半反应堆模式”，意思就是 “半同步 / 半异步模式 + Reactor 模式 = 半同步 / 半反应堆模式（half-sync/half-reactive）”</li>\n</ol>\n<h3 id=\"半同步半反应堆模式\"><a class=\"anchor\" href=\"#半同步半反应堆模式\">#</a> 半同步 / 半反应堆模式</h3>\n<p><img data-src=\"/2022/11/15/cpp/%E5%8D%8A%E5%90%8C%E6%AD%A5-%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E7%BA%BF%E7%A8%8B%E6%B1%A0/image.png\" class=\"\" title=\"img\"></p>\n<p>异步线程只有一个由主线程充当，负责监听所有 socket 上的事件：</p>\n<ol>\n<li>如果监听 socket 上有<strong>可读事件发生</strong>，即有新的连接请求到来，接收连接并向 epoll 内核事件表注册该 socket 上的读写事件。</li>\n<li>如果<strong>连接</strong> socket 上有<strong>读写事件发生</strong>，即有新的客户请求到来或有数据要发送至客户端。 模拟 Proactor 中：主线程首先循环读取数据完毕，随后将读取的数据封装成请求对象<strong>插入请求队列</strong>中。</li>\n<li>所有工作线程睡眠在请求队列上，当有任务到来时它们将通过竞争获取任务的接管权，从请求队列中取出任务对象直接处理无需读写操作。</li>\n</ol>\n<blockquote>\n<p>半同步 / 半反应堆模式缺点：</p>\n</blockquote>\n<ol>\n<li>主线程和工作线程共享请求队列，因此主线程往请求队列中添加任务或工作线程从请求队列中取出任务都需要对请求队列加锁保护。浪费 CPU 时间</li>\n<li>每个工作线程在同一时间只能处理一个客户请求，如果客户数量 &gt; 工作线程数→导致请求队列中任务堆积，客户端响应速度会越来越慢</li>\n</ol>\n<p><strong>改进方案：</strong></p>\n<p>主线程只负责监听 socket，连接 socket 由工作线程管理</p>\n<p>当有新连接到来时，主线程接收，并通过<strong>向管道写数据的方式</strong>将新返回的连接发给某个工作线程，该连接 socket 上的任何 IO 操作都由工作线程处理。工作线程检测到有数据可读就将连接 socket 上的读写事件注册到<strong>自己的 epoll 内核事件表</strong>。</p>\n<p><img data-src=\"/2022/11/15/cpp/%E5%8D%8A%E5%90%8C%E6%AD%A5-%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-16684823541241.png\" class=\"\" title=\"img\"></p>\n<h3 id=\"领导者追随者模式\"><a class=\"anchor\" href=\"#领导者追随者模式\">#</a> 领导者 / 追随者模式</h3>\n<p>含义：多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。 包含组件：句柄集、线程集、事件处理器、具体事件处理器</p>\n<p>任意时间点都只有一个领导者线程：负责监听 IO 事件，其他线程都是追随者，它们休眠在线程池等待成为新的领导者。</p>\n<ul>\n<li>当前领导者如果检测到 IO 事件，首先从线程池推选出新的领导者线程，然后处理 IO 事件</li>\n<li>此时新领导者等待新的 IO 事件，旧领导者处理 IO 事件，二者形成并发</li>\n</ul>\n<hr />\n<h2 id=\"有限状态机用于http请求的读取和分析\"><a class=\"anchor\" href=\"#有限状态机用于http请求的读取和分析\">#</a> 有限状态机：用于 HTTP 请求的读取和分析</h2>\n<p>之前探讨了关于服务器的 IO 处理单元、请求队列和逻辑单元之间协调完成任务的各种模式。</p>\n<p>现在介绍逻辑单元内部高效编程方法：有限状态机：</p>\n<p>主状态机有三种可能状态：当前正在分析<strong>请求行</strong>、当前正在分析<strong>头部字段</strong>、当前正在分析<strong>消息体</strong> 从状态机有三种可能状态（行的读取状态）：<strong>读到一个完整的行</strong>、行出错、行数据尚不完整</p>\n<p>从状态机用于解析出一行内容，</p>\n<ul>\n<li>判断 HTTP 头部结束的一句是遇到一个空行，该空行仅包含一对回车换行符 (\\r  和  \\n)。</li>\n<li>如果一次读操作没有读入 HTTP 请求的整个头部，即没有遇到空行那么必须等待客户继续写数据再次读入，返回 LINE_OPEN。因此每完成一次读操作就需要分析读入的数据是否有空行。</li>\n<li>在寻找空行的过程中，我们可以同时完成对整个 HTTP 请求头部的分析</li>\n</ul>\n<p>主状态机在内部调用从状态机:</p>\n<ol>\n<li>分析从状态机，parse_line 函数：它从 buffer 中解析出一个行。从状态机初始状态是 LINE_OK，原始驱动力来自于 buffer 中新到达的客户数据。</li>\n<li>在 main 函数中循环调用 recv 函数往 buffer 中读入客户数据，每次成功读取数据后就调用 process_read 函数来分析新读入的数据。\n<ul>\n<li>process_read 作为分析 http 请求的入口函数</li>\n<li>process_read 函数首先调用 parse_line 函数来获取一个行，当读取到一个完整的行后 parse_line 函数就可以将这行内容交给 process_read 函数中的主状态机来处理了。</li>\n</ul>\n</li>\n</ol>\n<p><img data-src=\"/2022/11/15/cpp/%E5%8D%8A%E5%90%8C%E6%AD%A5-%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-16684823541242.png\" class=\"\" title=\"img\"></p>\n<p>parse_line<strong> 只是提取出一行</strong>，并不解析其中内容</p>\n<p>parse_request_line<strong> 解析 http 请求行，获得请求方法，目标 url 及 http 版本号</strong> parse_headers<strong> 解析 http 请求的一个头部信息</strong> parse_content<strong> 解析 http 请求的消息体</strong></p>\n<ol>\n<li>主状态机初始状态为 CHECK_STATE_REQUESTLINE</li>\n<li>如果主状态机当前状态为 CHECK_STATE_REQUESTLINE，说明 parse_line 解析出的行是请求行，调用 parse_request_line 函数处理，分析完请求后将主状态机设置为 CHECK_STATE_HEADER 实现状态转移</li>\n<li>如果主状态机当前状态为 CHECK_STATE_HEADER，说明 parse_line 解析出的行是请求头部，调用 parse_headers 函数处理，并将主状态机设置为 CHECK_STATE_CONTENT</li>\n</ol>\n<h3 id=\"流程\"><a class=\"anchor\" href=\"#流程\">#</a> 流程：</h3>\n<p>浏览器端发出 HTTP 请求报文，服务器端接收该报文并<strong>调用 process_read 对其进行解析</strong>，根据解析结果 HTTP_CODE 做出响应，process_write () 填写相应的回复到缓冲区。</p>\n<h2 id=\"池\"><a class=\"anchor\" href=\"#池\">#</a> 池</h2>\n<p>并发编程：进程池、线程池</p>\n<blockquote>\n<p>当需要一个工作线程、进程来处理新到来的客户请求时可以直接从进程池、线程池中取得一个执行实体，无序动态调用 fork 或 pthread_create 函数创建</p>\n</blockquote>\n<p>连接池</p>\n<blockquote>\n<p>连接池是服务器预先和数据库程序建立的一组连接的集合。 当某个逻辑单元需要访问数据库时，它可以直接从连接池中取得一个连接的实体并使用，完成访问后逻辑单元再将该连接还给连接池</p>\n</blockquote>\n<hr />\n",
            "tags": [
                "cpp",
                "项目",
                "项目",
                "c++"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/11/15/cpp/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/",
            "url": "https://aristotlednzk.github.io.com/2022/11/15/cpp/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/",
            "title": "IO多路复用",
            "date_published": "2022-11-15T03:16:14.000Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/11/15/computer-science/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/",
            "url": "https://aristotlednzk.github.io.com/2022/11/15/computer-science/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/",
            "title": "单例模式",
            "date_published": "2022-11-15T03:07:24.000Z",
            "content_html": "<p>考察：要求实现各种变形，懒汉式、饿汉式</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXprek56SXpOakk0Tnc9PSZhbXA7bWlkPTIyNDc0ODU3MjImYW1wO2lkeD0xJmFtcDtzbj1lMzE1YTlmM2U4OTNkYjk4Mjc2YTE4MTE3YTI0NjEyZSZhbXA7c291cmNlPTQxI3dlY2hhdF9yZWRpcmVjdA==\">https://mp.weixin.qq.com/s?__biz=MzkzNzIzNjI4Nw==&amp;mid=2247485722&amp;idx=1&amp;sn=e315a9f3e893db98276a18117a24612e&amp;source=41#wechat_redirect</span></p>\n<p>有时候我们想让一个类能够保证自己仅仅能生成一个实例化对象  (对应上面的窗口类去保证自己创建对象时候的唯一性)  ，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p>\n<h2 id=\"单例模式的设计思路\"><a class=\"anchor\" href=\"#单例模式的设计思路\">#</a> <strong>单例模式的设计思路</strong></h2>\n<p>应该怎么保证上面窗口类在按钮类的回调函数里面调用的时候<br />\n能够 不用 if else 判断 而由窗口类对象自己去保证唯一性呢？</p>\n<p>第一步</p>\n<pre><code>首先应该不能让外界调用new的方式去创建他的对象 因为如果这样的话   外部还是可以产生多个对象了。\n我们还是得引入if else来判断 ,\n所以我们就应该阻止其他程序建立对象,   阻止的方式就是把构造函数声明为私有\n</code></pre>\n<p>第二步</p>\n<p>其次应该让这个窗口类对象应在作为静态成员对象声明在自己类的内部声明 因为这样的话 我们就可以在类里面实现对这个对象的唯一性判断 (由于它是静态的 各个类对象之间会共有这一个成员对象)</p>\n<p>第三步</p>\n<p>最后 应该在判断完这个静态成员类对象唯一以后应该有一个全局唯一接口 (静态成员函数) 让外面访问这个对象</p>\n<p>总结一下实现步骤： 1.<strong> 私有化构造函数，不让其他程序创建的对象初始化。</strong> 2.<strong> 在本类中 new 一个静态本类对象。</strong> 3. 定义一个静态成员函数，它的功能是让其他程序可以通过这个函数获取到本类的对象。</p>\n<h3 id=\"饿汉式\"><a class=\"anchor\" href=\"#饿汉式\">#</a> 饿汉式：</h3>\n<p><strong>1. 资源的占用:</strong></p>\n<p>饿汉模式 在类创建的就得 new 好它的静态成员对象 故占用空间</p>\n<p><strong>2. 类中静态成员 初始化顺序不确定所导致的异常.</strong></p>\n<p>也就是说类中的两个静态成员</p>\n<p>getInstance 和 Instance 不同编译单元中的初始化顺序是未定义的，</p>\n<p>如果在 Instance 初始化完成之前调用</p>\n<p>getInstance () 方法会返回一个未定义的实例</p>\n<p>由于要进行线程同步，所以在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能。这是以空间换时间</p>\n<pre><code class=\"language-C++\">class Singleton\n&#123;\n    //1.声明构造函数为私有\n    private:\n    Singleton()&#123;&#125;;\n    //2.声明一个本类的对象\n    private:\n    static Singleton* instance;\n    //3.对外提供本类对象的公共接口\n    public:\n    static Singleton* getInstance() \n    &#123;\n        return instance;\n    &#125;\n&#125;;\nSingleton* Singleton::instance=new Singleton;\n</code></pre>\n<ul>\n<li>静态成员函数</li>\n</ul>\n<ol>\n<li><strong>静态成员函数可以在类内直接定义也可以在类外定义（初始化 / 实现），在类外实现时不需要加 static。</strong></li>\n<li>静态成员函数只能访问静态数据成员和静态成员函数，普通成员函数可以访问静态成员函数和静态数据成员</li>\n<li>静态成员函数属于类，不属于任意一个类对象</li>\n<li>静态成员函数没有 this 指针</li>\n<li>可以使用 &lt;类名&gt;::&lt; 函数名 &gt; 访问，也可由类对象使用 (./-&gt;) 访问</li>\n</ol>\n<blockquote>\n<p>第一条解释：不能在类声明中初始化静态成员变量，因为声明描述了如何分配内存，但不分配内存。静态类成员位于 ** 静态存储区，*<em> 并 *<em> 不是类对象的组成部分</em></em>，所以需要在类声明之外使用单独的语句进行初始化。在类声明中不可初始化静态数据成员的一种例外情况是，静态数据成员为整型或枚举型 const。</p>\n</blockquote>\n<ul>\n<li>静态数据成员</li>\n</ul>\n<ol>\n<li>对于类静态数据成员，无论有多少个该类的对象，该静态数据成员在内存中只有一份拷贝 (其他普通数据成员，每个类对象都有自己的内存拷贝)，该静态数据成员由所有该类对象共享</li>\n<li>静态数据成员存储在全局数据区，在定义时分配存储空间，程序运行结束时销毁</li>\n<li><strong>静态数据成员不能再类中定义和初始化，只能在类中声明，在类外进行定义和初始化，默认初始化为 0</strong></li>\n<li>静态数据成员的初始化为 &lt;类型名&gt; &lt; 类名 &gt;::&lt; 变量名 &gt; = &lt; 值 &gt;</li>\n<li>静态数据成员遵从 public private protected 访问规则</li>\n<li>静态数据成员可以直接使用类名加作用域运算符 (::) 直接访问 &lt; 类名 &gt;::&lt; 变量名 &gt;(访问规则允许的情况下)</li>\n</ol>\n<h3 id=\"懒汉式\"><a class=\"anchor\" href=\"#懒汉式\">#</a> 懒汉式：</h3>\n<pre><code class=\"language-C++\">class Singleton\n&#123;\n    //1.声明构造函数为私有\n    private:\n    Singleton()&#123;&#125;;\n    //2.声明一个本类的对象\n    private:\n    static Singleton* instance;\n    //3.对外提供本类对象的公共接口\n    public:\n    static Singleton* getInstance() \n    &#123;\n        if(instance==NULL)\n        &#123;\n            instance=new Singleton;\n        &#125;\n    return instance;\n    &#125;\n&#125;;\nSingleton* Singleton::instance=NULL;\n</code></pre>\n<p><strong>1. 内存泄露</strong></p>\n<p>①析构函数没有被执行：</p>\n<p>程序退出时，析构函数没被执行.</p>\n<p>这在某些设计不可靠的系统上会导致资源泄漏，</p>\n<p>想一想上面的 Instance 指向的空间什么时候释放呢？</p>\n<p>更严重的问题是，该实例的析构函数什么时候执行？</p>\n<p>如果在类的析构行为中有必须的操作，</p>\n<p>比如关闭文件，释放外部资源，那么上面的代码无法实现这个要求。</p>\n<p>我们需要一种方法，正常的删除该实例。</p>\n<p>**2. 线程安全  **</p>\n<p>②线程不安全：我们注意到在 static Singleton* getInstance () 方法中，<br />\n是通过 if 语句判断 静态实例变量 是否被初始化来觉得是否进行初始化，<br />\n那么在多线程中就有可能出现多次初始化的问题。<br />\n比方说，有两个多线程同时进入到这个方法中，<br />\n同时执行 if 语句的判断，<br />\n那么就会出现两次两次初始化静态实例变量的情况。</p>\n<h3 id=\"懒汉式线程安全\"><a class=\"anchor\" href=\"#懒汉式线程安全\">#</a> 懒汉式（线程安全）：</h3>\n<p>1.<strong> 用双重检测锁 DLC 解决线程安全</strong></p>\n<pre><code class=\"language-C++\">class Singleton \n&#123; \n  public: \n  static pthread_mutex_t mutex; \n  static Singleton* getInstance(); \n  protected: //定义线程互斥锁\n  Singleton() \n  &#123; \n      pthread_mutex_init(&amp;mutex); \n  &#125; \n  private: \n  static Singleton* p; \n&#125;; \n  pthread_mutex_t Singleton::mutex; //初始化互斥锁\n  Singleton* Singleton::p = NULL; //类外初始化静态指针：通过作用域调用\n  Singleton* Singleton::getInstance() //获取实例\n  &#123; \n      if (NULL == p) \n      &#123; \n          pthread_mutex_lock(&amp;mutex); \n          if (NULL == p) \n              p = new Singleton(); \n          pthread_mutex_unlock(&amp;mutex); \n      &#125; \n      return p; \n  &#125;\n</code></pre>\n<p><strong>2. 内部静态变量实现懒汉模式</strong></p>\n<pre><code class=\"language-C++\">class Singleton \n&#123; \n    public: \n    static pthread_mutex_t mutex; //静态成员：互斥锁变量\n    static Singleton* getInstance(); //静态成员函数\n    protected: \n    Singleton() \n    &#123; \n        pthread_mutex_init(&amp;mutex); \n    &#125; \n&#125;; \npthread_mutex_t Singleton::mutex; //类外初始化\nSingleton* Singleton::getInstance() //类外定义/实现\n**&#123; **\n    pthread_mutex_lock(&amp;mutex); \n**    static singleton ss; **\n    pthread_mutex_unlock(&amp;mutex); \n**    return &amp;ss; **\n&#125;\n</code></pre>\n<p>简单工厂模式：</p>\n<p>1. 实现了客户端和创建对象的工厂类打交道（传入参数让工厂直到应该创建什么类型的对象），与具体实现类的解耦。<br />\n2. 增加新的功能是通过修改源代码实现，不符合开闭原则</p>\n",
            "tags": [
                "转码之路",
                "设计模式",
                "转码之路",
                "设计模式"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/11/10/cpp/Tinywebserver%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/",
            "url": "https://aristotlednzk.github.io.com/2022/11/10/cpp/Tinywebserver%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/",
            "title": "Tinywebserver项目记录",
            "date_published": "2022-11-10T10:49:44.000Z",
            "content_html": "<h1 id=\"partimywebserver\"><a class=\"anchor\" href=\"#partimywebserver\">#</a> PartⅠ：mywebserver</h1>\n<h2 id=\"一-lockerhlockercpp-与tiny相同\"><a class=\"anchor\" href=\"#一-lockerhlockercpp-与tiny相同\">#</a> 一、locker.h，locker.cpp （与 Tiny 相同）</h2>\n<p><strong>互斥锁类 locker</strong><br />\n&lt;u&gt; 用于内存池 &lt;/u&gt;：请求队列（工作队列）的互斥访问</p>\n<p>向工作队列中添加任务 append () 时，会访问 / 修改请求队列</p>\n<p>线程中运行的主要逻辑：从请求队列中取出请求并执行其 process () 函数，故会访问 / 修改请求队列</p>\n<p><strong>条件变量类 cond</strong><br />\n 项目中没有用到</p>\n<p><strong>信号量类 sem</strong><br />\n&lt;u&gt; 用于内存池 &lt;/u&gt;：<strong>请求队列 —— 生产者消费者模型</strong></p>\n<p>append () 向请求队列中添加请求，则信号量 ++（post ()）</p>\n<p>run () 从请求队列中取出请求，则信号量–（wait ()）</p>\n<h2 id=\"二-threadpoolh-线程池\"><a class=\"anchor\" href=\"#二-threadpoolh-线程池\">#</a> 二、threadpool.h 线程池</h2>\n<p>创建多个线程<br />\n创建一定数量（m_thread_number）的线程（pthread_create ()），线程的入口函数 worker () 需要是静态函数，原因：</p>\n<ul>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mjc0NTAxL2FydGljbGUvZGV0YWlscy8xMTcwODMxNzU/dXRtX21lZGl1bT1kaXN0cmlidXRlLnBjX3JlbGV2YW50Lm5vbmUtdGFzay1ibG9nLWJhaWR1anNfYmFpZHVsYW5kaW5nd29yZC0wJmFtcDtzcG09MTAwMS4yMTAxLjMwMDEuNDI0Mg==\">https://blog.csdn.net/qq_39274501/article/details/117083175?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&amp;spm=1001.2101.3001.4242</span></p>\n</li>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvUEI4dk13aThzQjRKdzNXekFLcFdPUQ==\">https://mp.weixin.qq.com/s/PB8vMwi8sB4Jw3WzAKpWOQ</span></p>\n</li>\n<li>\n<p>类中调用 pthread_create () 时，类的成员函数作为 pthread_create () 的参数时，必须是静态函数</p>\n</li>\n<li>\n<p>因为类的成员函数有一个隐藏的参数 ——this 指针，而线程的入口函数必须是接受一个 void 指针作为参数，故入口函数的参数中有一个隐藏的 this 指针是不允许的。为了解决矛盾，我们使用 static 成员函数，其独立于实例，参数中不会有 this 指针，故其可以用作线程的入口函数</p>\n</li>\n</ul>\n<p><strong>将线程设为脱离</strong><br />\n创建线程后，将线程设为脱离（pthread_detach ()），这是为了自动回收线程资源</p>\n<p><code>pthread_detach()的作用——当线程终止时，线程的资源将会立即被回收，而不用等待另一个线程调用pthread_join</code> <br />\n <code>/* Indicate that the thread TH is never to be joined with PTHREAD\\_JOIN.   The resources of TH will therefore be freed immediately when it   terminates, instead of waiting for another thread to perform PTHREAD\\_JOIN   on it.  */</code> <br />\n <code>extern int pthread\\_detach (pthread\\_t \\_\\_th) \\_\\_THROW;</code></p>\n<p><strong>请求队列（工作队列）</strong><br />\n请求队列 —— 以队列形式组织，其实现了：<strong>将主线程和工作线程解耦</strong>（主线程向请求队列中添加任务，工作线程通过竞争来取得任务并执行任务）</p>\n<p>请求队列的访问：由于会有多个线程对其进行访问 / 修改，故通过<strong>互斥锁实现互斥访问</strong></p>\n<p>工作线程竞争请求队列中的任务：<strong>通过信号量实现生产者 / 消费者模型</strong>，任务交给哪个线程执行是随机的。（也可以用 Round Robin 算法让线程轮流获取任务）</p>\n<p><strong>工作线程们运行的函数</strong><br />\n worker ()-&gt;run ()</p>\n<ol>\n<li>worker ()：只是一个桥梁，静态成员函数，用作 pthread_create () 的参数；其中只是调用线程的主要逻辑 run ()</li>\n<li>run ()：类的成员函数，需要静态成员函数 worker () 作为媒介来成为线程的工作函数。其主要逻辑：&lt;u &gt; 竟态获取请求队列中的任务 &lt;/u&gt;，通过调用请求类的 process 函数处理请求，process 函数调用 process_read 函数和 process_write 函数分别完成报文解析与报文响应两个任务</li>\n</ol>\n<p><strong>只实现了 Proactor 模式</strong></p>\n<ol>\n<li>run () 中只执行 process () 过程，数据的读写是在主线程 main () 中完成的</li>\n<li>reactor 模式的实现 —— 把数据读写放到工作线程中完成就行了（参考 Tinywebserver）</li>\n</ol>\n<h2 id=\"三-maincpp\"><a class=\"anchor\" href=\"#三-maincpp\">#</a> 三、main.cpp</h2>\n<p><strong>网络编程常规步骤</strong><br />\n略</p>\n<p><strong>循环获取就绪事件并处理</strong><br />\n这便是主线程的主要工作逻辑。</p>\n<p>由于是 Proactor 模式，故可读可写事件发生时，main 中将数据读入 / 写出完毕，然后再通知工作线程进行后续逻辑处理</p>\n<p>由于该项目中，写完成后，没有后续的处理逻辑，故只有读完成后才会通知工作线程（将任务 append 到线程池的请求队列）</p>\n<p>项目中只实现了 LT+ONESHOT 模式。虽然是 LT 模式，但是由于是 ONESHOT，故也要用非阻塞 IO 循环读取以保证将 TCP 缓存中的数据全部读出。（在 ET 模式下，事件触发后需要将缓冲区中的数据完全读完，否则会陷入死锁，故必须要用非阻塞 IO 循环读取）。<br />\n为什么必须要用 ONESHOT 呢？（ONESHOT 的作用）——《Linux 高性能服务器编程》P157：</p>\n<ul>\n<li>即使是用 ET 模式，一个 socket 上的事件还是可能被触发多次（LT 模式则更是如此），这在并发编程中就会引起一个问题：socket 上的数据被获取后，一个线程开始处理数据（此时 HTTP 请求报文可能并不完整）；而在处理数据的过程中，又有新的数据可读（EPOLLIN 再次被触发），此时另一个线程被唤醒去处理新到来的数据。这就会出现同时有两个线程操作同一个 socket 的情况，这显然是不被期望的。</li>\n<li>正常情况应该是：数据到来–&gt; 数据被读入 socket 对应的 http_conn 类对象 H 中–&gt; 唤醒一个线程去操作这个类对象 H (处理数据)，数据处理过程中不应再次触发事件，避免又有另一个线程开始对该类对象 H 进行操作。</li>\n</ul>\n<h2 id=\"四-http_connhhttp_conncpp\"><a class=\"anchor\" href=\"#四-http_connhhttp_conncpp\">#</a> 四、http_conn.h，http_conn.cpp</h2>\n<h3 id=\"主要逻辑\"><a class=\"anchor\" href=\"#主要逻辑\">#</a> 主要逻辑</h3>\n<p>** 处理 HTTP 请求：** 通过主从状态机</p>\n<ol>\n<li>\n<p>process_read ()—— 正常流程下，process_read () 返回的是 do_request () 的结果</p>\n</li>\n<li>\n<p>parse_line()</p>\n</li>\n<li>\n<p>get_line()</p>\n</li>\n<li>\n<p>parse_request_line()</p>\n</li>\n<li>\n<p>parse_hearders()</p>\n</li>\n<li>\n<p>parse_content()</p>\n</li>\n</ol>\n<p><strong>do_request ()：根据 HTTP 请求的解析结果，进行处理得到后续生成响应所需的前提状态</strong></p>\n<ol>\n<li>\n<p>首先对 GET 请求和不同 POST 请求（登录，注册，请求图片，视频等等）做不同的预处理</p>\n</li>\n<li>\n<p>获取请求资源的信息，并判断请求的合法性：分析目标文件的属性，若目标文件存在、对所有用户可读且不是目录</p>\n</li>\n<li>\n<p>若合法：则将文件只读地打开，使用 mmap 将其映射到内存地址 m_file_address 处，并告诉调用者获取文件成功。</p>\n</li>\n</ol>\n<p><strong>处理 CGI</strong></p>\n<p>根据标志判断是登录检测还是注册检测</p>\n<p>将用户名和密码提取出来</p>\n<p><strong>生成 HTTP 响应数据并放入发送缓存</strong></p>\n<ul>\n<li>process_write ()—— 根据 process_read ()（do_request ()）获得的文件合法性，生成响应报文放入发送缓冲区，并设置发送缓冲区的标志信息</li>\n<li>process_write () 处理完成之后，注册 EPOLLOUT 事件，等待主线程调用 write () 发送缓冲区中的数据</li>\n</ul>\n<p><strong>其他函数</strong></p>\n<ul>\n<li>write ()—— 采用分散写 writev ()，客户请求的资源（响应体）和 process_write () 生成的报文数据（状态行和响应头），分别放在两块内存中，前者在文件映射到的内存中，后者在发送缓存中</li>\n<li>setnonblocking ()、addfd ()、removefd ()、modfd () 等 socket 编程常用函数也定义在 http_conn.cpp 中（因为类中也会用到这些函数）</li>\n</ul>\n<p><strong>有限状态机 - 处理 HTTP 请求中使用</strong></p>\n<ul>\n<li>\n<p>主状态机：当前解析到哪部分（请求首行、请求头部、请求体）</p>\n</li>\n<li>\n<p>第一行是首行，解析完直接跳到解析头部状态</p>\n</li>\n<li>\n<p>头部解析时若遇到空行，则说明头部解析完毕，若有请求体则跳到解析请求体状态（头部中会有 Content-Length 来告诉你有没有请求体）</p>\n</li>\n<li>\n<p>请求体解析</p>\n</li>\n<li>\n<p>从状态机：请求数据的每一行的处理状态（完整的一行、不完整的一行、错误的一行）</p>\n</li>\n<li>\n<p>请求分析结果状态机：用于标记请求报文解析的结果，并用于决定后续的报文解析和响应生成</p>\n</li>\n<li>\n<p>请求方法状态机：用于标记请求报文中的请求方法，该项目中只支持 GET</p>\n</li>\n</ul>\n<h2 id=\"partii整个项目的模型\"><a class=\"anchor\" href=\"#partii整个项目的模型\">#</a> PartⅡ：整个项目的模型</h2>\n<h3 id=\"一-mywebserver\"><a class=\"anchor\" href=\"#一-mywebserver\">#</a> 一、mywebserver：</h3>\n<ol>\n<li>并发模式：半同步 / 半反应堆模式 —— 我认为应该叫 “半同步 / 半模拟前摄器模式”</li>\n<li>事件处理（事件分发）模型：同步 IO 模拟的 Proactor 模型</li>\n</ol>\n<h3 id=\"二-tinywebserver\"><a class=\"anchor\" href=\"#二-tinywebserver\">#</a> 二、Tinywebserver：</h3>\n<ol>\n<li>并发模式：半同步 / 半反应堆模式、半同步 / 半模拟前摄器模式 都实现了（其实就是实现了下面的 Reactor 和模拟 Proactor）</li>\n<li>事件处理（事件分发）模型：同步 IO 模拟的 Proactor 模型、Reactor 模型 都实现了（通过 threadpool.h 中的 m_actor_model 变量实现选择用哪种模型，就是选择 read () 和 write () 在主线程完成还是工作线程完成而已）</li>\n</ol>\n",
            "tags": [
                "C++",
                "项目",
                "C++",
                "项目"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/11/02/%E9%97%BB%E8%AF%B4/%E7%88%B1%E6%AC%B2%E4%B9%8B%E6%AD%BB/",
            "url": "https://aristotlednzk.github.io.com/2022/11/02/%E9%97%BB%E8%AF%B4/%E7%88%B1%E6%AC%B2%E4%B9%8B%E6%AD%BB/",
            "title": "爱欲之死",
            "date_published": "2022-11-02T14:07:23.000Z",
            "content_html": "<h3 id=\"reading中\"><a class=\"anchor\" href=\"#reading中\">#</a> Reading 中...</h3>\n<p>作者：韩炳哲    韩裔德国哲学家</p>\n<p>绩效社会、他者消失、否定性消失 balabala...</p>\n<p>还未看完，持续更新～</p>\n",
            "tags": [
                "阅读笔记",
                "西哲",
                "阅读笔记"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/23/%E8%A8%80/%E4%BA%BA%E7%B1%BB%E5%BE%80%E4%BA%8B/",
            "url": "https://aristotlednzk.github.io.com/2022/10/23/%E8%A8%80/%E4%BA%BA%E7%B1%BB%E5%BE%80%E4%BA%8B/",
            "title": "人类往事",
            "date_published": "2022-10-23T06:28:16.000Z",
            "content_html": "<h2 id=\"初章\"><a class=\"anchor\" href=\"#初章\">#</a> 初章</h2>\n<ul>\n<li>\n<p>本篇为我个人原创小说的导言，小说标题也尚未确定，内容纯属个人胡思乱想，对现实生活略有参考但并无影射，写小说的初衷不能说是完全一时兴起，只能说是用于闲暇时光消遣。本人将不定期更新篇章，有生之年是否完结也是未知数，想看小说后续请前往本博客分类：言 - 我的狂想曲 - 我的小说。</p>\n<p><code>可预见的逻辑bug技术细节凌乱叙事请海涵。随时欢迎关于小说内容的任何方面探讨。</code></p>\n</li>\n</ul>\n<h3 id=\"人类往事\"><a class=\"anchor\" href=\"#人类往事\">#</a> 人类往事</h3>\n<p>嗯哼～还没想好……</p>\n",
            "tags": [
                "言",
                "我的狂想曲",
                "我的小说",
                "言",
                "我的狂想曲",
                "我的小说"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/21/%E8%A8%80/%E4%B8%96%E7%95%8C%E3%82%A2%E3%83%B3%E3%83%89%E5%B4%87%E9%AB%98/",
            "url": "https://aristotlednzk.github.io.com/2022/10/21/%E8%A8%80/%E4%B8%96%E7%95%8C%E3%82%A2%E3%83%B3%E3%83%89%E5%B4%87%E9%AB%98/",
            "title": "世界アンド崇高",
            "date_published": "2022-10-21T12:02:05.000Z",
            "content_html": "<h2 id=\"那些错过的篇章\"><a class=\"anchor\" href=\"#那些错过的篇章\">#</a> 那些错过的篇章</h2>\n<p>这两天补完了剑风传奇和孤高之人，优秀作品的闪光点是纯粹的</p>\n<p>ああ 蒙昧の 蒙昧の</p>\n<p>枷に「保護」さえ写し見せ</p>\n<p>灰舞え 灰舞え 灰舞えよ ああ</p>\n<p>ああ 在るは難き唯一の出自を</p>\n<p><img data-src=\"/2022/10/21/%E8%A8%80/%E4%B8%96%E7%95%8C%E3%82%A2%E3%83%B3%E3%83%89%E5%B4%87%E9%AB%98/%E5%89%91%E9%A3%8E1.jpg\" class=\"\" title=\"剑风1\"></p>\n<p><img data-src=\"/2022/10/21/%E8%A8%80/%E4%B8%96%E7%95%8C%E3%82%A2%E3%83%B3%E3%83%89%E5%B4%87%E9%AB%98/%E5%89%91%E9%A3%8E.jpg\" class=\"\" title=\"剑风1\"></p>\n<hr />\n<p>见山即见崇高</p>\n<p>K2 东壁独攀者</p>\n<p><img data-src=\"/2022/10/21/%E8%A8%80/%E4%B8%96%E7%95%8C%E3%82%A2%E3%83%B3%E3%83%89%E5%B4%87%E9%AB%98/%E5%AD%A4%E9%AB%98%E4%B9%8B%E4%BA%BA.jpg\" class=\"\" title=\"孤高之人\"></p>\n",
            "tags": [
                "言",
                "言",
                "随笔集"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/19/philosophy/%E4%BA%BA%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%9A%84%E9%BB%98%E4%BC%9A%E7%BB%B4%E5%BA%A6/",
            "url": "https://aristotlednzk.github.io.com/2022/10/19/philosophy/%E4%BA%BA%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%9A%84%E9%BB%98%E4%BC%9A%E7%BB%B4%E5%BA%A6/",
            "title": "人类知识的默会维度",
            "date_published": "2022-10-19T02:28:56.000Z",
            "content_html": "<h3 id=\"大学阅读笔记收官第一篇\"><a class=\"anchor\" href=\"#大学阅读笔记收官第一篇\">#</a> 大学阅读笔记收官 —— 第一篇</h3>\n<ul>\n<li>\n<p>默会知识论启程读本</p>\n<p>欢迎书友评论</p>\n</li>\n</ul>\n<p><img data-src=\"/2022/10/19/philosophy/%E4%BA%BA%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%9A%84%E9%BB%98%E4%BC%9A%E7%BB%B4%E5%BA%A6/5.png\" class=\"\" width=\"5\"></p>\n<p><img data-src=\"/2022/10/19/philosophy/%E4%BA%BA%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%9A%84%E9%BB%98%E4%BC%9A%E7%BB%B4%E5%BA%A6/25.png\" class=\"\" width=\"25\"></p>\n",
            "tags": [
                "哲学社科",
                "西哲",
                "哲学社科",
                "西哲",
                "阅读笔记"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/18/%E8%A8%80/%E5%8F%B0%E9%A3%8E%E4%B8%8E%E7%A7%8B/",
            "url": "https://aristotlednzk.github.io.com/2022/10/18/%E8%A8%80/%E5%8F%B0%E9%A3%8E%E4%B8%8E%E7%A7%8B/",
            "title": "台风与秋",
            "date_published": "2022-10-18T11:00:56.000Z",
            "content_html": "<h3 id=\"深圳の秋\"><a class=\"anchor\" href=\"#深圳の秋\">#</a> 深圳の秋</h3>\n<p>三点一线的路上：<br />\n浮现出蚀之刻、真理与斗争的画面……</p>\n<p>食堂：<br />\n每次咬合齿肉镶嵌的冲击<br />\n思考，进食动作带来的快感……</p>\n<p>寒雨台风林海声：<br />\n来自它的呼唤<br />\n与世俱灭的斗志不允许你回顾从前……</p>\n<hr />\n<p>远行即远征</p>\n",
            "tags": [
                "言",
                "言",
                "随笔集"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/15/cpp/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-socket%E7%AF%87/",
            "url": "https://aristotlednzk.github.io.com/2022/10/15/cpp/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-socket%E7%AF%87/",
            "title": "Linux高性能服务器编程/socket篇",
            "date_published": "2022-10-15T09:10:54.000Z",
            "content_html": "<h2 id=\"socket地址api\"><a class=\"anchor\" href=\"#socket地址api\">#</a> socket 地址 API</h2>\n<p>字节序问题：CPU 累加器一次装载 4 个字节，那么 4 个字节在内存中排列的顺序将影响它被累加器装载成的整数的值</p>\n<blockquote>\n<p>主机字节序 &amp; 网络字节序：</p>\n</blockquote>\n<ul>\n<li>大端字节序：一个整数的高位字节存储在内存的低位地址，低位字节（0-7bit）存储在内存高位地址， 称为<strong>网络字节序</strong></li>\n<li>小端字节序相反→现代多采用：称为<strong>主机字节序</strong></li>\n</ul>\n<h3 id=\"通用socket地址\"><a class=\"anchor\" href=\"#通用socket地址\">#</a> 通用 socket 地址：</h3>\n<p>AF_前缀表示地址族， PF_前缀表示协议族。</p>\n<p>unsigned short int→两个字节</p>\n<p>旧版：</p>\n<p>sa_family_t sa_family;//sa_family_t 地址族类型 char sa_data [14];// 只有 14 个字节</p>\n<p><img data-src=\"/2022/10/15/cpp/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-socket%E7%AF%87/image.png\" class=\"\" title=\"image\"></p>\n<h3 id=\"专用socket地址\"><a class=\"anchor\" href=\"#专用socket地址\">#</a> 专用 socket 地址</h3>\n<p>在设置和获取 IP 地址和端口号的上海更方便</p>\n<blockquote>\n<p>TCP 协议族 sockaddr_in 和 sockaddr_in6 两个专用 socket 地址结构体，分别用 IP v4 和 IP v6 所有 socket 编程接口使用的地址参数类型都是<strong> sockaddr</strong>→专用 socket 地址类型的遍历实际使用需要转换为通用 socket 地址类型 sockaddr</p>\n</blockquote>\n<p><img data-src=\"/2022/10/15/cpp/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-socket%E7%AF%87/2.png\" class=\"\" width=\"2\"></p>\n<p>sockaddr_in 每段都划分好了相应成员，最终转换为 sockaddr 指针即可</p>\n<p>.png)</p>\n<pre><code class=\"language-C++\">// TCP/IP 协议族有 sockaddr_in 和 sockaddr_in6 两个专用的 socket 地址结构体，它们分别用于 IPv4 和 IPv6：\n#include &lt;netinet/in.h&gt;\nstruct sockaddr_in&#123;\nsa_family_t sin_family; /* _*SOCKADDR_COMMON(sin*) */\nin_port_t sin_port; /* Port number. */\nstruct in_addr sin_addr; /* Internet address. */\n/* Pad to size of `struct sockaddr'. */\nunsigned char sin_zero[sizeof (struct sockaddr) - __SOCKADDR_COMMON_SIZE - sizeof (in_port_t) - sizeof (struct in_addr)];\n&#125;;\nstruct in_addr&#123;\nin_addr_t s_addr;\n&#125;;\nstruct sockaddr_in6&#123;\nsa_family_t sin6_family;\nin_port_t sin6_port; /* Transport layer port # */\nuint32_t sin6_flowinfo; /* IPv6 flow information */\nstruct in6_addr sin6_addr; /* IPv6 address */\nuint32_t sin6_scope_id; /* IPv6 scope-id */\n&#125;;\ntypedef unsigned short uint16_t;\ntypedef unsigned int uint32_t;\ntypedef uint16_t in_port_t;\ntypedef uint32_t in_addr_t;\n#define __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))\n</code></pre>\n<h2 id=\"ip地址转换\"><a class=\"anchor\" href=\"#ip地址转换\">#</a> IP 地址转换</h2>\n<blockquote>\n<p>字符串 ip - 整数和主机 - 网络字节序的转换</p>\n</blockquote>\n<p>通常，人们习惯用可读性好的<strong>字符串来表示 IP 地址</strong>，比如用点分十进制字符串表示 IPv4 地址，以及用十六进制字符串表示 IPv6 地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用<strong>点分十进制字符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址</strong>之间的转换：</p>\n<p>只适用于 IP v4：</p>\n<pre><code class=\"language-C++\">#include &lt;arpa/inet.h&gt;\nin_addr_t inet_addr(const char *cp);//该函数返回值类型为in_addr_t=uint32_t=unsigned int类型，参数为字符常量 \nint inet_aton(const char *cp, struct in_addr *inp);//将点分十进制地址转换为网络字节序地址\nchar *inet_ntoa(struct in_addr in);\n</code></pre>\n<p>inet_aton () 函数将将点分十进制地址转换为二进制的网络字节序地址，结 ** 果地址保存在结构体类型为 in_addr 的 inp 中，** 该结构体第一个成员为 uint32_t 类型（unsigned int 类型）的 in_addr_t。</p>\n<ul>\n<li>返回值：1 表示转换成功，0 表示失败有错误号 errno</li>\n</ul>\n<p><strong>同时适用于 IP v4 和 IP v6：</strong></p>\n<pre><code class=\"language-C++\">#include &lt;arpa/inet.h&gt;\n// **p:点分十进制的IP字符串**，n:表示network，网络字节序的整数\nint inet_pton(int af, const char *src, void *dst);\naf:地址族： AF_INET AF_INET6\nsrc:需要转换的点分十进制的IP字符串\ndst:转换后的结果保存在这个里面  \n// 将网络字节序的整数，转换成点分十进制的IP地址字符串\nconst char *inet_ntop(int af, const void *src, char *dst, socklen_t size);\naf:地址族： AF_INET AF_INET6\nsrc: 要转换的ip的整数的地址\ndst: 转换成IP地址字符串保存的地方\nsize：第三个参数的大小（数组的大小）\n**返回值：返回转换后的数据的地址（字符串），和 dst 是一样的**\n/*\n#include &lt;arpa/inet.h&gt;\n// p:点分十进制的IP字符串，n:表示network，网络字节序的整数\nint inet_pton(int af, const char *src, void *dst);\naf:地址族： AF_INET  AF_INET6\nsrc:需要转换的点分十进制的IP字符串\ndst:转换后的结果保存在这个里面\n// 将网络字节序的整数，转换成点分十进制的IP地址字符串\nconst char *inet_ntop(int af, const void *src, char *dst, socklen_t size);\naf:地址族： AF_INET  AF_INET6\nsrc: 要转换的ip的整数的地址\ndst: 转换成IP地址字符串保存的地方\nsize：第三个参数的大小（数组的大小）\n返回值：返回转换后的数据的地址（字符串），和 dst 是一样的\n*/\n#include &lt;stdio.h&gt;\n#include &lt;arpa/inet.h&gt;\nint main() &#123;\n// 创建一个ip字符串,点分十进制的IP地址字符串\nchar buf[] = &quot;192.168.1.4&quot;;**//第二个参数类型为字符数组**\nunsigned int num = 0;**//第三个参数的类型为无符号整型的地址---注意传入地址加&amp;**\n// 将点分十进制的IP字符串转换成网络字节序的整数\ninet_pton(AF_INET, buf, &amp;num);\nunsigned char * p = (unsigned char *)&amp;num;\n//把四个字节分别打印出来：每次+1=字节+1\nprintf(&quot;%d %d %d %d\\n&quot;, *p, *(p+1), *(p+2), *(p+3));\n// 将网络字节序的IP整数转换成点分十进制的IP字符串\nchar ip[16] = &quot;&quot;;\nconst char * str =  inet_ntop(AF_INET, &amp;num, ip, 16);\nprintf(&quot;str : %s\\n&quot;, str);\nprintf(&quot;ip : %s\\n&quot;, ip);\nprintf(&quot;%d\\n&quot;, ip == str);\nreturn 0;\n&#125;\n</code></pre>\n<blockquote>\n<p>解析 unsigned char * p = (unsigned char *)#</p>\n</blockquote>\n<blockquote>\n<p>二.(unsigned char *)&amp;a 运算顺序 1. 先取 a 的地址 2. 将 &amp; a 强制类型转化为 unsigned char * 类型，也就是指向 a 的地址 3. 取出 unsigned char * 指针的值</p>\n</blockquote>\n<hr />\n<h2 id=\"客户端\"><a class=\"anchor\" href=\"#客户端\">#</a> 客户端</h2>\n<h3 id=\"创建socket\"><a class=\"anchor\" href=\"#创建socket\">#</a> 创建 socket</h3>\n<h3 id=\"连接函数connect\"><a class=\"anchor\" href=\"#连接函数connect\">#</a> 连接函数 connect</h3>\n<p>TCP 客户通过 connect 函数来建立与 TCP 服务器的连接：</p>\n<p>int connect (int sockfd, const struct sockaddr *servaddr,socklen_t addrlen); 返回：成功则为 0，若出错则为 - 1</p>\n<blockquote>\n<p>解释： sockfd 是由 socket 数返回的套接字描述符 第 2 个、第 3 个参数分别是一个指向套接字地址结构的指针和该结构的大小</p>\n</blockquote>\n<p>客户在调用函数 onnect 前不必非得调用 bind 函数， 因为如果需要的话，内核会确定源 IP 地址，并选择 个临时端口作为源端口。TCP 套接字调用 connect 函数会激发 TCP 三次握手，仅在连接成功或出错时返回。</p>\n<ul>\n<li>connect 函数建立导致客户端套接字从 CLOSED 状态转为→SYN_SENT 状态</li>\n<li>若 connect 失败则该套接字不再可用，必须关闭，不能对该套接字再次调用 connect 函数</li>\n</ul>\n<h2 id=\"服务端\"><a class=\"anchor\" href=\"#服务端\">#</a> 服务端</h2>\n<h3 id=\"创建socket可读写控制关闭的文件描述符\"><a class=\"anchor\" href=\"#创建socket可读写控制关闭的文件描述符\">#</a> 创建 socket：可读写控制关闭的文件描述符</h3>\n<blockquote>\n<p>int socket( int domain,int type,int protocol)</p>\n</blockquote>\n<ul>\n<li>domain 参数告诉系统使用哪个底层协议簇，TCP/IP 使用 PF_INET（IPV4）</li>\n<li>type 指定服务类型：主要包括 SOCK_STREAM（流服务）和 SOCK_UGRAM（数据报服务）。对 TCP/IP 协议族而言，<strong>SOCK_STREAM*<em>*<em> 表示传输层使用 TCP 协议，*</em>**SOCK_DGRAM**</em>* 表示传输层使用 UDP 协议</strong></li>\n<li>protocol 参数是在前两个参数构成的协议集合下，再选择一个具体的协议，不过这个值通常是唯一的（由前两个参数完全决定），<strong>几乎在所有情况下都设置为 0，表示使用默认协议</strong></li>\n</ul>\n<p>调用成功返回一个<strong> socket 文件描述符（小的非负整数值）=sockfd</strong>，失败返回 - 1 并设置 errno</p>\n<h3 id=\"命名socket\"><a class=\"anchor\" href=\"#命名socket\">#</a> 命名 socket</h3>\n<blockquote>\n<p>创建 socket 时，我们给它指定了地址族，但并未指定具体用哪个地址 给 socket 命名：将一个 socket 与 socket 地址绑定</p>\n</blockquote>\n<p>客户端采用匿名方式 —— 使用操作系统自动分配的 socket 地址：把 一个本地协议地址赋给 一个套接字 系统调用函数：</p>\n<blockquote>\n<p>int bind(int sockfd,const struct sockaddr* my_addr,socklen_t addrlen);</p>\n</blockquote>\n<ul>\n<li>bind 将 my_addr 所指向的 socket 地址分配给未命名的 sockfd 文件描述符，addrlen 参数指出该 socket 地址的长度。</li>\n<li>bind 成功则返回 0，失败返回 - 1 并设置 errno 包括以下两种</li>\n</ul>\n<blockquote>\n<p>EACCES: 被绑定的地址是受保护的地址 EADDRINUSE: 被绑定的地址正在使用中</p>\n</blockquote>\n<hr />\n<p>上述两个函数都需要: include &lt;sys/types.h&gt; include&lt;sys/socket.h&gt;</p>\n<h3 id=\"监听socket\"><a class=\"anchor\" href=\"#监听socket\">#</a> 监听 socket</h3>\n<p>socket 被命名后需要使用系统调用创建一个监听队列来存放待处理的客户连接：</p>\n<blockquote>\n<p>int listen( int sockfd,int backlog);</p>\n</blockquote>\n<blockquote>\n<p>listen 函数仅由 TCP 服务器调用，并做如下两件事：</p>\n</blockquote>\n<ol>\n<li>\n<p>listen 函数创建一个套接字时，他被假设为一个主动套接字。listen 函数把 1 个未连接的套接字转换成 1 个被动套接字，指示内核接受指向套接字的连接请求。</p>\n</li>\n<li>\n<p>第二个参数规定了内核应该为相应套接字排队的最大连接个数。 内核为每个给定的监听套接字维护两个队列：</p>\n<p>（1）未完成连接队列：每个 SYN 分节对应队列中的一项，套接字正处于 SYN_RCVD 状态</p>\n<p>（2）已完成连接队列：每个已完成三次握手的客户对应队列中的一项，套接字处于 ESTABLISHED 状态</p>\n</li>\n</ol>\n<blockquote>\n<p>1. 每当来自客户的 SYN 到达，<strong>TCP 在未完成连接队列中创建一个新项</strong>，然后服务器响应 SYN 第二个分节，并捎带对客户的 SYN 的 ACK。该项一直保留在未完成连接队列中，直到三次握手第三个分节到达或该项超时为止。如果三次握手正常，该项则<strong>从未完成连接队列转移到已完成连接队列的队尾</strong>。 2. 当进程调用 accept 函数时，已完成连接队列中的队头项将返回给进程，如果该队列为空那么进程将被投入睡眠，直到 TCP 在该队列中放入一项才唤醒它</p>\n</blockquote>\n<ul>\n<li>sockfd 参数指定被监听的 socket。</li>\n<li>backlog 参数提示内核<strong>监听队列的最大长度</strong>→监听队列长度如果超过 backlog，服务器将不手里新的客户连接，客户端将收到 ECONNREFUSED 错误信息，以前表示已连接队列 + 半连接队列之和</li>\n<li>listen 成功返回 0，失败返回 - 1 并设置 errno</li>\n</ul>\n<h3 id=\"接受连接\"><a class=\"anchor\" href=\"#接受连接\">#</a> 接受连接</h3>\n<p>accept 函数由 TCP 服务器调用，用于<strong>从已完成连接队列队头返回下一个已完成连接</strong>。<strong>从 listen 监听队列中接受一个连接</strong></p>\n<blockquote>\n<p>int accept(int sockfd,struct sockaddr *addr,socklen_t *addrlen);</p>\n</blockquote>\n<ul>\n<li>sockfd 参数是执行过 listen 系统调用的监听 socket 套接字描述符</li>\n<li>addr 参数获取被接受连接的远端 socket 地址</li>\n<li>远端 socket 地址结构长度由 * addrlen 参数所引用的整数值设置，返回时，该整数值为该套接字地址结构内的确切字节数</li>\n<li>accept 成功时，<strong>那么其返回值是由 内核自动 生成的 1 个套接字全新描述符</strong> = 称为<strong>已连接套接字描述符</strong>，该 socket 唯一地表示了被接受的这个连接。失败则返回 - 1 并设置 errno。如果<strong>已完成连接队列为空，那么进程被投入睡眠</strong></li>\n</ul>\n<p>服务器可以通过该 socket 来与被接受连接对应的客户端通信</p>\n<p>已连接套接字每次在循环中关闭，但监听套接字在服务器的整个有效期内都保持开放</p>\n<p>而现在由于考虑到 syn 攻击，backlog 参数的含义改为了已连接队列之和，去除了半连接队列之和了。</p>\n<p>举一个例子，在 socket 编程当中，如果我们在服务端不用 accept 函数，listen 函数的第二个参数设置为 5，那么这个时候，可以成功连接的客户端就是最多可以成功连入 5 个，每连入一个，队列的项数就会加一 (减一的话就是用 accept 函数去取出来)，所以当项数达到 5 时，客户端自然就会连不上了。</p>\n<blockquote>\n<p>注意本函数最多返回三个值：分别对应函数三个参数</p>\n</blockquote>\n<ul>\n<li>新套接字描述符 / 出错指示整数</li>\n<li>客户进程的协议地址→addr</li>\n<li>客户进程的协议地址大小→addrlen</li>\n</ul>\n<hr />\n<h4 id=\"socket状态\"><a class=\"anchor\" href=\"#socket状态\">#</a> socket 状态</h4>\n<ol>\n<li>调用 socket 函数创建了一个套接字以后，改套接字就对应的和相应的输出缓冲区和输入缓冲区建立了联系，此时改套接字的状态正处于 CLOSED (观察 TCP 状态转换图即可)</li>\n<li>当我们调用 listen 函数以后，改套接字的状态就变成了 LISTEN 监听状态，此时，处于等待客户端连入的状态。</li>\n<li>对于一个调用 listen 进行监听的套接字’操作系统会为其维护 2 个队列：未完成连接队列和已完成连接队列。 （1）未完成连接队列中的连接 当客户端发送 TCP 连接三次握手的第 1 次（即 SYN 包）时，服务器端会在未完成连接队列中创建一个与该 SYN 包对应的项，可以把该项看成一个半连接（因为连接尚未建立）该半连接的状态会从 LISTEN 变成 SYNRCVD 同时向客户端返回第 2 次握手的包。 （SYN’ACK）而此时服务器正在等待完成第 3 次握手 （2）已完成连接队列中的连接 3 次握手完成后该连接就变成 ESTABLISHED 状态，每个已经完成 3 次握手的客户端连接（完整说法应该是 “服务器端的与客户端对应的 socket 连接”）都放在这个队列中作为一项。</li>\n</ol>\n<p>.png)</p>\n<p>从上图可以看到客户端发送的三次握手从第 1 个 SYN 包到 ** <code>在三次握手完成之前</code> <strong>连接都会在未完成连接队列中；直到</strong> <code>在三次握手完成后</code>  ** 该连接就从未完成连接队列转移到已完成连接队列</p>\n<p>而 listen 函数” 曾经 “的含义为这两个队列的和不超过 backlog，实际上由于操作系统的原因可能会比这个值稍微多一些。</p>\n<p>.png)</p>\n<hr />\n<h3 id=\"web服务器端通过socket监听来自用户的请求\"><a class=\"anchor\" href=\"#web服务器端通过socket监听来自用户的请求\">#</a> Web 服务器端通过 <code>socket</code>  监听来自用户的请求。</h3>\n<p>源代码如下：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>#include &lt;sys/socket.h>  </pre></td></tr><tr><td data-num=\"2\"></td><td><pre>#include &lt;netinet/in.h>  </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>/* 创建监听socket文件描述符 */  </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>int listenfd = socket(PF_INET, SOCK_STREAM, 0);  /* 创建监听socket的TCP/IP的IPV4 socket地址 struct sockaddr_in address;  </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>bzero(&amp;address, sizeof(address));  </pre></td></tr><tr><td data-num=\"6\"></td><td><pre>address.sin_family = AF_INET;  </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>address.sin_addr.s_addr = htonl(INADDR_ANY);  /* INADDR_ANY：将套接字绑定到所有可用的接口   </pre></td></tr><tr><td data-num=\"8\"></td><td><pre>address.sin_port = htons(port);  </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>int flag = 1;  </pre></td></tr><tr><td data-num=\"10\"></td><td><pre>/* SO_REUSEADDR 允许端口被重复使用 */  </pre></td></tr><tr><td data-num=\"11\"></td><td><pre>setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, sizeof(flag));  </pre></td></tr><tr><td data-num=\"12\"></td><td><pre>/* 绑定socket和它的地址 */  </pre></td></tr><tr><td data-num=\"13\"></td><td><pre>ret = bind(listenfd, (struct sockaddr*)&amp;address, sizeof(address));   </pre></td></tr><tr><td data-num=\"14\"></td><td><pre>/* 创建监听队列以存放待处理的客户连接，在这些客户连接被accept()之前 */  </pre></td></tr><tr><td data-num=\"15\"></td><td><pre>ret = listen(listenfd, 5);</pre></td></tr></table></figure>",
            "tags": [
                "C++",
                "项目",
                "webserver",
                "socket篇",
                "C++",
                "项目",
                "webserver",
                "socket篇"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/15/bug/",
            "url": "https://aristotlednzk.github.io.com/2022/10/15/bug/",
            "title": "bug",
            "date_published": "2022-10-15T02:23:58.000Z",
            "content_html": "<h1 id=\"bug\"><a class=\"anchor\" href=\"#bug\">#</a> bug</h1>\n",
            "tags": [
                "bug",
                "bug"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/14/GAN%E8%AF%BE%E9%A2%98/%E7%9B%B8%E6%9C%BA%E6%89%8B%E7%9C%BC%E6%A0%87%E5%AE%9A/%E7%9B%B8%E6%9C%BA%E6%89%8B%E7%9C%BC%E6%A0%87%E5%AE%9A/",
            "url": "https://aristotlednzk.github.io.com/2022/10/14/GAN%E8%AF%BE%E9%A2%98/%E7%9B%B8%E6%9C%BA%E6%89%8B%E7%9C%BC%E6%A0%87%E5%AE%9A/%E7%9B%B8%E6%9C%BA%E6%89%8B%E7%9C%BC%E6%A0%87%E5%AE%9A/",
            "title": "相机手眼标定",
            "date_published": "2022-10-14T08:29:02.000Z",
            "content_html": "<h2 id=\"1-眼在手上的手眼标定\"><a class=\"anchor\" href=\"#1-眼在手上的手眼标定\">#</a> 1、眼在手上的手眼标定</h2>\n<p><img data-src=\"https://img-blog.csdnimg.cn/dc166d3e745d411b8deff1c07d6bca08.png\" alt=\"眼在手上的手眼标定\" /></p>\n<p>基础坐标系（用 base 表示） 是机器臂的基底坐标系，末端坐标系（用 end 表示） 是机器臂的末端坐标系， 相机坐标系（用 cam 表示） 是固定在机器臂上面的相机自身坐标系，标定物坐标系（用 cal 表示）是标定板所在的坐标系。任意移动两次机器臂，由于标定板和机器臂的基底是不动的，因此对于某个世界点，其在 base 坐标系和 cal 坐标系下的坐标值不变，在 end 坐标系和 cam 坐标系下的坐标值随着机器臂的运动而改变。根据这一关系，可以求解出 end 坐标系和 cam 坐标系之间的转换矩阵。</p>\n<hr />\n",
            "tags": [
                "GAN课题",
                "GAN课题"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/",
            "url": "https://aristotlednzk.github.io.com/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/",
            "title": "生成对抗网络",
            "date_published": "2022-10-12T13:34:29.000Z",
            "content_html": "<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL2k2WXVRZkcyTkUxaGJienRpUkJMWGU=\">GAN 开山之作论文</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8yNjczNTkzMy9hcnRpY2xlL2RldGFpbHMvMTA4OTI1MjMy\">https://blog.csdn.net/weixin_26735933/article/details/108925232</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNzg1MjEzODM=\">https://zhuanlan.zhihu.com/p/378521383</span></p>\n<p>GAN 架构包含两个子模式，分别称为<strong> Generator (G) 和</strong> Discriminator (D) ，它们相互竞争，目的是通过训练过程达到 Nash 平衡。 生成器学习将潜在空间 (例如，噪声〜N <em>(0,1)</em> ) 映射到在其上分发给定数据样本的数据空间，鉴别器评估生成器完成的映射。 生成器的主要作用是生成模仿训练数据集的合成数据，以使鉴别器无法将合成数据与真实数据区分开。</p>\n<p>生成器的输入是随机噪声矢量_x'_ (通常是均匀或正态分布)。 噪声向量通过 Generator 映射到新的数据空间，以获得伪样本_G (x')_ ，它是多维向量。 鉴别器是一个二进制分类器，它吸收了生成的数据集和训练的数据集，并学习将它们分类为假的和真实的。** 当判别器无法确定数据来自真实数据集还是生成器时，便会达到 GAN 模型的最佳状态 **</p>\n<p><img data-src=\"/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/GAN.png\" class=\"\" title=\"GAN\"></p>\n<hr />\n<h2 id=\"可解释的生成对抗网络infogan\"><a class=\"anchor\" href=\"#可解释的生成对抗网络infogan\">#</a> 可解释的生成对抗网络：InfoGAN</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NTk0NTE2NA==\">https://zhuanlan.zhihu.com/p/55945164</span></p>\n<p>在<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NDA5NjM4MQ==\">生成对抗网络 (GAN) 背后的数学理论</span> 提到，generator 和 discriminator 的对抗学习，它的目标其实是得到一个与 real data 分布一致的 fake data 分布。</p>\n<p>但是由于 generator 的输入是一个<strong>连续的噪声信号</strong>，并且<strong>没有任何约束</strong>，导致 GAN 将 z 的具体维度与 output 的语义特征对应起来，可解释性很差。</p>\n<p>它的原理很简单，在 info GAN 里面，把输入向量 z 分成两部分，c 和 z'。c 可以理解为可解释的隐变量，而 z 可以理解为不可压缩的噪声。希望通过约束 c 与 output 的关系，<strong>使得隐变量 c 的维度对应 output 的语义特征</strong>，以手写数字为例，比如笔画粗细，倾斜度等。</p>\n<p>为了引入 c，作者<strong>通过互信息的方式来对 c 进行约束</strong>，也可以理解成自编码的过程。具体的操作是，generator 的 output，经过一个分类器，看是否能够得到 c。其实可以看成一个 anto-encoder 的反过程。其余的 discriminator 与常规的 GAN 是一样的。</p>\n<p><img data-src=\"https://pic1.zhimg.com/80/v2-b85a31bbe8ed2b42a3ad11a707720674_720w.jpg\" alt=\"img\" /></p>\n<p>图片来自李宏毅老师生成对抗网络视频 https://www.youtube.com/watch?v=DMA4MrNieWo&amp;list=PLJV_el3uVTsMq6JEFPW35BCiOQTsoqwNw&amp;index=5</p>\n<p>在实际过程中，classifier 和 discriminator 会共享参数，只有最后一层是不一样的，classifier 输出的是一个 vector, discriminator 输出的是一个标量。</p>\n<hr />\n<h2 id=\"第一章\"><a class=\"anchor\" href=\"#第一章\">#</a> 第一章：</h2>\n<p>生成器的优点在于生成很容易，但只学习了真实样本的表象，只学到了 component 和 component 像素和像素之间的相似度，而没有学到图像和图像的关联。可以用生成器取代下面方程，产生负样本，产生 x~</p>\n<p>以往是通过高斯混合模型定义 PG 然后用最大似然估计算出最优分布 PG 下的参数 sita，但这个模型可能更复杂，不用高斯…… 又难以计算。而现在用生成器找到一个分布，也就是用生成器可以生成一个很复杂的分布 PG。<strong>生成器 G 意图让生成的样本 PG 和真实样本 Pdata 之间的散度越小越好</strong></p>\n<p><img data-src=\"/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/GAN1.png\" class=\"\" title=\"GAN1\">PG 可以通过生成器的向量中生成，一张张图片，Pdata 可以通过真实数据集采样得到 那么如何通过生成器计算 PG 和 Pdata 的散度呢</p>\n<p>判别器优点在于能够学到整个图像的关联，但很难生成图像，需要解 x~=arg max D (x）方程</p>\n<p>1. 如何训练判别器 D 呢，首先固定 G，寻找让 max V (G,D) 的 D,。对每一个 x，都可以找一个不同的 D 让式子最大</p>\n<p><img data-src=\"/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/GAN2.png\" class=\"\" title=\"GAN2\"></p>\n<p>&lt;img src=&quot;生成对抗网络 / GAN3.png&quot; alt=&quot;GAN3&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>&lt;img src=&quot;生成对抗网络 / GAN4.png&quot; alt=&quot;GAN4&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>第一步：固定 G，寻找 D，让 V 函数 max<br />\n 第二步：在寻找到的 D 基础上固定不动，寻找让 maxV 最小的 G</p>\n<p><img data-src=\"/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/GAN5.png\" class=\"\" title=\"GAN5\"></p>\n<h1 id=\"第四章基础理论\"><a class=\"anchor\" href=\"#第四章基础理论\">#</a> 第四章：基础理论</h1>\n<p><img data-src=\"/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/GAN6.png\" class=\"\" title=\"GAN6\"></p>\n<p>首先给定 G，找到 D<em> 并求出 V 对 sitaG 的梯度，用于更新 sitaG 找一个 D</em> 从而 maxV 的过程就是找到 Pdata 和 PG 之间的 JS 散度 V (G1,D1*) 的过程</p>\n<p><img data-src=\"/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/GAN7.png\" class=\"\" title=\"GAN7\"></p>\n<p>关键是：<strong>当更新 G0 后函数 V 可能会变化</strong>，而此时的 D*（使 V 最大的横坐标位置）可能就变了，再用之前的 D * 训练就不靠谱。因此只能每次更新 G 一点点，假设每次更新后函数变化很小和之前是类似的，因此不太可能出现右图情况。 <strong>因此生成器 G 不能训练太多，通常只更新一次</strong></p>\n<p><img data-src=\"/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/GAN8.png\" class=\"\" title=\"GAN8\"></p>\n<p>期望 E 计算：实际上只能通过离散叠加求均值的方法来计算 V，实际上是从 Pdata 和 PG 中采样出一堆 x 来代替期望 E，训练一个二分类分类器→最小化交叉熵 = maxV</p>\n<p>训练判别器的目的是：为了评估 JS 散度 从 Pdata 中采用出一堆 x 作为正样本，从 PG 中采样出一堆 x 作为负样本</p>\n<p><img data-src=\"/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/GAN9.png\" class=\"\" title=\"GAN9\"></p>\n<p>每轮训练迭代过程：</p>\n<p>1. 根据 Pdata（x）中采样 m 个 x，从先验分布中采样 m 个噪声向量 z→输入生成器→得到 m 个生成样本，更新判别器参数 sitad 从而→maxV</p>\n<p><strong>训练判别器目的</strong>：为了估计 JS 散度才训练判别器，而用于估计 JS 散度的最优判别器的目标函数 V 是最大的，为了使其最大必定需要多轮重复迭代训练→直到收敛→<strong>可以更新 k 次</strong></p>\n<p>** 训练生成器目的：** 为了最小化 JS 散度，而由于生成器每次训练会导致目标函数变化，<strong>因此每次只训练更新一次</strong></p>\n<p><img data-src=\"/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/GAN10.png\" class=\"\" title=\"GAN10\"></p>\n<hr />\n<h2 id=\"fgan框架\"><a class=\"anchor\" href=\"#fgan框架\">#</a> fGAN 框架</h2>\n<p>用不同 f - 散度量生成样本和真实样本的差距 p (x) 和 q（x）分别代表从 x 从 p 分布和从 q 分布采样出来的几率 p 和 q 之间的散度：</p>\n<hr />\n<h2 id=\"info-ganvae-gan-bigan\"><a class=\"anchor\" href=\"#info-ganvae-gan-bigan\">#</a> Info GAN,VAE GAN, BiGAN</h2>\n<p>编码器和解码器输入输出不相连，判别器输入 z 和图像，判断是来自编码器还是解码器</p>\n<p><img data-src=\"/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/GAN11.png\" class=\"\" title=\"GAN11\"></p>\n<p><img data-src=\"/2022/10/12/GAN%E8%AF%BE%E9%A2%98/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/GAN12.png\" class=\"\" title=\"GAN12\"></p>\n",
            "tags": [
                "GAN课题",
                "生成对抗网络",
                "GAN课题"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/12/philosophy/%E7%8E%B0%E8%B1%A1%E5%AD%A6-%E8%83%A1%E5%A1%9E%E5%B0%94/%E7%8E%B0%E8%B1%A1%E5%AD%A6-%E8%83%A1%E5%A1%9E%E5%B0%94/",
            "url": "https://aristotlednzk.github.io.com/2022/10/12/philosophy/%E7%8E%B0%E8%B1%A1%E5%AD%A6-%E8%83%A1%E5%A1%9E%E5%B0%94/%E7%8E%B0%E8%B1%A1%E5%AD%A6-%E8%83%A1%E5%A1%9E%E5%B0%94/",
            "title": "现象学/胡塞尔",
            "date_published": "2022-10-12T13:29:08.000Z",
            "content_html": "<h1 id=\"现象学胡塞尔\"><a class=\"anchor\" href=\"#现象学胡塞尔\">#</a> 现象学 —— 胡塞尔</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tLzdjWFlOenFDSHY2eGdHR3hHcTc0aVI=\">事物的本质及认识</span></p>\n<p>胡塞尔的现象学关注的是 “认识如何可能”<strong>（认识的过程）的问题，是对认识本身的批判，这是反对以往的科学仅仅关注 “认识的对象” 而并不关注</strong>认识本身 ** 提出的。</p>\n<p>胡塞尔的核心命题就在解释：<strong>认识如何可能，或我们认识是否能与内在事物一致的问题</strong>（我们能不能清除一切对实存的主观设定，而完全客观地看待事物本身）。</p>\n<p>在胡塞尔那里，<strong>被给予性</strong>意味着 ：一个东西 “没有表述其他什么”“没有超越自身去意指什么” 它所展示的东西完全都是自身被给予的东西，胡塞尔认为人的 “思维” 就是这样一种东西，而以往的所有科学研究中，研究者都是带有主观设定和滤镜去看的，因此所有的物在科学研究那里都无法具有 “绝对的被给予性”，都是不可靠的。</p>\n<p>在胡塞尔那里，“意向性” 作为现象学的 “不可或缺的起点概念和基本概念” 标志着所有意识的本己特性，即：所有意识都是 “关于某物的意识” 并且作为这样一种意识而可以得到直接的指明和描述。关于某物的意识是指在广义上的意指行为与被意指之物本身之间可贯通的相互关系。</p>\n<p>对 “意向性” 之把握的惟一途径在胡塞尔看来是本质直观的反思：“在意向性被反思揭示并因此而自身成为课题之前，它始终是隐蔽着的”</p>\n",
            "tags": [
                "哲学社科",
                "西哲",
                "哲学社科"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/12/%E8%BF%9C%E8%A1%8C%E8%80%85%E5%BC%80%E7%AF%87/%E8%BF%9C%E8%A1%8C%E8%80%85%E5%BC%80%E7%AF%87/",
            "url": "https://aristotlednzk.github.io.com/2022/10/12/%E8%BF%9C%E8%A1%8C%E8%80%85%E5%BC%80%E7%AF%87/%E8%BF%9C%E8%A1%8C%E8%80%85%E5%BC%80%E7%AF%87/",
            "title": "远行者开篇",
            "date_published": "2022-10-12T08:52:06.000Z",
            "content_html": "<h2 id=\"初衷\"><a class=\"anchor\" href=\"#初衷\">#</a> 初衷</h2>\n<p>抱着将博客作为云笔记软件来用的想法，历时两天才醒悟，还是继续当个牌面吧……</p>\n<h3 id=\"后续\"><a class=\"anchor\" href=\"#后续\">#</a> 后续</h3>\n<p>Maybe 日后还有别的用途？比如不定期更新个人读书笔记、随想录之类……</p>\n",
            "tags": [
                "言",
                "言"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/11/%E9%97%BB%E8%AF%B4/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/",
            "url": "https://aristotlednzk.github.io.com/2022/10/11/%E9%97%BB%E8%AF%B4/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/",
            "title": "亲密关系",
            "date_published": "2022-10-11T11:30:59.000Z",
            "content_html": "<h1 id=\"亲密关系\"><a class=\"anchor\" href=\"#亲密关系\">#</a> 亲密关系</h1>\n<p>练习：写下初遇时在伴侣身上发现的所有优点和相处至今的优点，另一张纸上写现在在对方身上看到的缺点，第一张表上列的每一项得十分，第二章表上列的扣十分</p>\n<p>1、最初被某人吸引通常是由于情绪上的需求，这些需求来源于孩提时代未被满足的需要。孩童时期的主要需求：寻求归属感 —— 证明自己具有特殊价值 ——“想要变得特别”<br />\n 期待一个能无视我们所有缺点并且对自己的需求极大的人。</p>\n<p>2、制造梦想的机器：从童年时期就开始绘制能满足自己一切期待的理想对象，随着年龄增长，期望越来越高<br />\n 3、如果在现实中寻觅不到就开始在相处中对她未满足自己需求的方面进行改造</p>\n<h2 id=\"月晕期\"><a class=\"anchor\" href=\"#月晕期\">#</a> 月晕期</h2>\n<h3 id=\"通往地狱之路是用期望铺成的\"><a class=\"anchor\" href=\"#通往地狱之路是用期望铺成的\">#</a> 通往地狱之路，是用期望铺成的</h3>\n<p>期待与要求分为明说和暗示，在需求得到满足前我们不愿意去爱。</p>\n<p>然而我的期望让我不能得到安抚，期望的目的是要让需求得到满足，但与此同时必然会出现两件事：<br />\n（1）我们内心缺乏爱，如果我们需要 sth，是因为我们没有<br />\n（2）如果没有 sb 满足我们的需求，我们会觉得世界上没有足够的爱 —— 希望从他人身上得到爱只会让 “无人爱我” 的想法更牢不可破</p>\n<p>因此期望是愤恨的前兆</p>\n<hr />\n<p>       在对亲密关系不满意时问问自己，此时希望从伴侣身上得到的是什么？本质上是情绪上的事物，表面上看来则是实质的需求。</p>\n<p>例：约好七点见面，但她八点才来，我不高兴但<strong>真正原因不是她迟到而是她让我觉得自己不够特别</strong> —— 我希望她让我觉得自己很重要，重要到她应该愿意为了我而守时</p>\n<p>了解自己期望背后的需求，我们通常只是希望伴侣做或说一些事，但却不会意识到我们希望他们这么做其实是满足自己某些情绪上的需求 —— 我们希望曲儿我们值得被爱</p>\n<p>想象力、意向和直觉</p>\n<p>灵魂思考的方式 —— 直觉</p>\n<p>当找到自己真正的情绪需求后再问自己：我愿不愿意放弃这项期望呢 —— 我愿不愿意寻求自己内在的力量来满足我的所有需求呢？</p>\n<p>如果答案是肯定的，那么<strong>直觉会告诉你该如何放手了</strong></p>\n<p><strong>如果你有精神上的信仰，那么不妨把需求交给内心中高层次的力量</strong></p>\n<hr />\n<h3 id=\"如果决定放手那么如何满足需求呢事实是我们并不需要自己认为需要的东西\"><a class=\"anchor\" href=\"#如果决定放手那么如何满足需求呢事实是我们并不需要自己认为需要的东西\">#</a> 如果决定放手，那么如何满足需求呢？\n—— 事实是，我们并不需要自己认为需要的东西</h3>\n<p>学会放手和接纳，明白自己原本就是一个完整的个体，所需的一切都存在于你的内心</p>\n<hr />\n<h2 id=\"幻灭期\"><a class=\"anchor\" href=\"#幻灭期\">#</a> 幻灭期</h2>\n<p>随着愤恨的到来，标志着进入第二阶段 —— 幻灭</p>\n<p>幻灭带来偏差行为：<br />\n引起注意、权力斗争：满足孩子的两大需求<br />\n报复心理、自我放逐：当孩子觉得需求永远不会被满足时被深刻的沮丧痛苦驱使做出毁灭性行为</p>\n<p>       远离造成痛苦的人并不会让痛苦消失，伴侣只是让我发觉到痛苦的存在。唤醒过去的伤痛，想要疗伤的企图往往导致亲密关系危机，和伴侣吵架只是为了不去感受旧痛，而伴侣所做的仅仅是让旧痛浮上意识表层。</p>\n<hr />\n<h2 id=\"信念想法的果实\"><a class=\"anchor\" href=\"#信念想法的果实\">#</a> 信念：想法的果实</h2>\n<p>种下想法，就得到行动。种下行动，就得到习惯。<br />\n种下习惯，就得到人格。种下人格，就得到命运。</p>\n<p>过去的创伤并不会随时间逝去，每个自我局限的信念都来自过去的创伤、痛苦的经验。所有未愈合伤口的信念都是自我局限的，</p>\n<p>——<strong> 如果离开家的时候，你并不感到平静，那么你其实并没有离开</strong></p>\n<p>亲密关系中蕴含着治好旧伤的机会。而大多数情况是双方都试图控制对方的行为，借以控制过去的创伤。</p>\n<p><img data-src=\"/2022/10/11/%E9%97%BB%E8%AF%B4/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB-16660629207261.png\" class=\"\" title=\"亲密关系\"></p>\n",
            "tags": [
                "阅读笔记",
                "阅读笔记"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/11/philosophy/%E7%8E%8B%E9%98%B3%E6%98%8E%E5%BF%83%E5%AD%A6/",
            "url": "https://aristotlednzk.github.io.com/2022/10/11/philosophy/%E7%8E%8B%E9%98%B3%E6%98%8E%E5%BF%83%E5%AD%A6/",
            "title": "王阳明心学",
            "date_published": "2022-10-11T11:29:15.000Z",
            "content_html": "<h1 id=\"王阳明心学\"><a class=\"anchor\" href=\"#王阳明心学\">#</a> 王阳明心学</h1>\n<p>一、人具有无限心</p>\n<blockquote>\n<p>人作为时间性存在，总是以筹划尚不存在的未来的形式活在当下 —— 证明了人心的无限性 —— 能超越现实；因而烦恼从中来。</p>\n<ul>\n<li>\n<p>关键在于安顿无限心。</p>\n<p>在官场上，中国政治的传统模式一天不变，中南海和秦城监狱之间就一步之遥。高官俸禄之有限，<strong>而无限心无法安顿在有限的事物上，因为现实世界的事物无一不是有限的。因此无限心只能安顿在超越现实的世界中（出世 —— 从现实世界的利害中超拔出来），而无法安顿在现实世界中</strong>。</p>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ol>\n<li>\n<p>儒家：无所为而为。如果从未出世，那么做事总是有所为而为，做事都有目标目的，始终把自己做的事情看作是达到另外一个目的手段。<br />\n无所为而为 —— 这件事本应当做，它就是自己的价值 </p>\n</li>\n<li>\n<p>道家：无为而无不为。不以人为的方式做事。人 + 为 = 伪 = 造作，生非贵之所能存，身非爱之所能厚，遇矛盾先将属于自己的<strong>人为因素去除</strong>，在最终还是不得不去处理时再去做，时机恰到好处，方法顺应天道。最好的人生就是没有目标的人生。</p>\n</li>\n<li>\n<p>佛家：无心而为。每个人做什么自有来历 —— 业力。<strong>做事就是消业，不求结果，最好没有结果，若有结果则旧业未消又增新业。但凡事都有结果，力求结果与己无关。</strong> 认真做事，但对结果漠不关心 ——<strong> 除心不除事</strong></p>\n<p>业力：每个人都生来带着业力</p>\n</li>\n</ol>\n</blockquote>\n<p>人并非拥有选择自己拥有某种愿望的能力，只是拥有选择实现愿望的道路的能力，什么愿望来到我们心里并不是我们的自由，愿望就这么来了……</p>\n<hr />\n<p>插入：</p>\n<ul>\n<li>西方哲学 —— 自身问题：关于世界的客观知识的前提基础是什么，获得客观可靠有效知识的方法是什么</li>\n<li>中国哲学 —— 人生问题；佛学中国化（两汉之际）禅宗，儒道佛合流 (两宋时期)—— 王阳明心学</li>\n</ul>\n<hr />\n<p>一体之仁，当我们对鸟兽虫鱼的哀鸣生出恻隐之心，当我们与鸟兽虫鱼连为一体，人心感通宇宙万物，中国宇宙观。心之理 —— 不是心外之理，真理不要到心外去寻求 —— 万物皆备于我，反身而成，乐莫大焉。上乘孟子 “学问之道无他，求其放心而已”，学问 —— 已经被亡失的心重新召回。</p>\n<p>《金刚经》核心思想 ——<strong> 因无所住而生其心</strong></p>\n<blockquote>\n<p>佛学中国化：禅宗 16 字法门：教外别传，不立文字，直指人心，见性成佛</p>\n</blockquote>\n<ul>\n<li>不求出离生死之苦海，自性若迷。</li>\n<li>不睹众相常观金体。</li>\n<li>六色 —— 眼耳鼻舌身意 —— 着相；观金体本身 —— 不住相。</li>\n<li>佛法在世间，不离世间觉。离世觅菩提，恰如求兔角。</li>\n</ul>\n<p>&lt;div align=&quot;center&quot;&gt; &lt;img src=https://tva3.sinaimg.cn/large/0071tL0Nly8h760vrtpq6j30u00u0myt.jpg width=60%/&gt; &lt;/div&gt;</p>\n",
            "tags": [
                "哲学社科",
                "中哲",
                "哲学社科"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/11/computer-science/%E8%BD%AC%E7%A0%81%E4%B9%8B%E8%B7%AF/",
            "url": "https://aristotlednzk.github.io.com/2022/10/11/computer-science/%E8%BD%AC%E7%A0%81%E4%B9%8B%E8%B7%AF/",
            "title": "转码之路",
            "date_published": "2022-10-11T11:26:24.000Z",
            "content_html": "<h1 id=\"转码之路\"><a class=\"anchor\" href=\"#转码之路\">#</a> 转码之路</h1>\n<p>鱼皮学习路线<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vbGl5dXBpL2NvZGUtcm9hZG1hcC9ibG9iL21haW4vZG9jcy9yb2FkbWFwL0phdmElRTUlQUQlQTYlRTQlQjklQTAlRTglQjclQUYlRTclQkElQkYubWQjaHR0cHM6Ly9naXRlZS5jb20vbGluaz90YXJnZXQ9aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2ludGVsbGlnZW50VGVzdA==\"> https://gitee.com/liyupi/code-roadmap/blob/main/docs/roadmap/Java 学习路线.md#https://gitee.com/link?target=https%3A%2F%2Fwww.nowcoder.com%2FintelligentTest</span></p>\n<p>API 在线文档<span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29sLm9zY2hpbmEubmV0L2FwaWRvY3MvYXBpZG9jP2FwaT1qZGtfN3U0\"> https://tool.oschina.net/apidocs/apidoc?api=jdk_7u4</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tLzN4QjlGQkZMVmhkMWk2dWNmZ3NIR0I=\">面经资料</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tLzJMTGpnZGdjM25pZ1l4WnFSakhRRUU=\">岗位分析</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL3dkakU3WEdRNzhmTURUZnFTTXpTU0M=\">简历</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL2NhelNUZm1iTkgxTjE0OThUM1dmUUc=\">后端指导大纲</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tLzJQOUVTVFRxdUhpOUhtdTFVQVpVVlI=\">GIT</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL2dvSzl5Rnlud29lOWlQdU43aWVETlU=\">Linux</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL3I0NGFVUWlkUkVtUEFxTU14QWhHdUY=\">C++</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tLzRHRlhoMW95N2pyblhMMW1vclhyN28=\">力扣刷题笔记</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL2plYmJYOG9uZG1VRUtqaWlRd01rOTY=\">JAVA 基础笔记</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tLzRzYkt1TmtRc0NyVkY5Z0tESkMyaFg=\">MySQL（DB）</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL2VXZ0F6OTdEaTdjZHZpcThtU1o3cXM=\">JVM</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL2oyeVF6QVlHSjk2SHlWa3JHZ25GTFY=\">JUC 并发编程</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL2UyUzNHZjZ4VkJtS3p3VVk3N2tqUnc=\">三件套</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL3FMRHRaMXlBOUZhV3g4dkQxcVlBN1c=\">排序算法</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tLzlFaFl6RnF5V1hZY0Ryc2VtdjhidTE=\">Spring 框架</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tLzYyWlI1bTJBVER6OFoyUXdTN21rTTE=\">Redis</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tLzlDWUFFell4RXY3bzdoUnoxWHN3Q0E=\">Docker</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL2p5VkdDdGZSYzRDeTFmaVlVWW1CdUI=\">Acwing 算法基础课</span></p>\n<p><img data-src=\"D:%5CWolai%5C%E7%AC%94%E8%AE%B0%5C%E8%BD%AC%E7%A0%81%E4%B9%8B%E8%B7%AF%5Cimage%5Cimage_v6vkTMI4J5.png\" alt=\"\" /></p>\n<h2 id=\"java学习路线一\"><a class=\"anchor\" href=\"#java学习路线一\">#</a> Java 学习路线一</h2>\n<p>牛客链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2Rpc2N1c3MvNDY0NzUwP3R5cGU9cG9zdCZhbXA7b3JkZXI9cmVjYWxsJmFtcDtwb3M9JmFtcDtwYWdlPTEmYW1wO25jVHJhY2VJZD0mYW1wO2NoYW5uZWw9LTEmYW1wO3NvdXJjZV9pZD1zZWFyY2hfcG9zdF9uY3RyYWNrJmFtcDtnaW9faWQ9QjcyMkIxMkMyODNEN0MwRDAxQzFCRDUxNTY5QTU2OTYtMTY1Nzg3Mzk3MDUwNA==\">https://www.nowcoder.com/discuss/464750?type=post&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack&amp;gio_id=B722B12C283D7C0D01C1BD51569A5696-1657873970504</span>  </p>\n<p>1 JVM</p>\n<p>内存模型、垃圾收集<a href=\"/jump/super-jump/word?word=%E7%AE%97%E6%B3%95\" title=\"算法\">算法</a>与垃圾收集器、内存溢出与内存泄漏是重点，JVM 调优也学一下；</p>\n<p>2 spring</p>\n<p>3 springmvc</p>\n<p>4 mybatis</p>\n<p>5 springboot</p>\n<p>框架不但要会用，也要能清晰原理比如自动配置的原理；</p>\n<p>6 多线程 同步 并发等（这很重要）</p>\n<p>生产者消费者模式代码、synchronized、lock、各种锁机制和锁升级；</p>\n<p>7 一些常见的数据结构与<a href=\"/jump/super-jump/word?word=%E7%AE%97%E6%B3%95\" title=\"算法\">算法</a>的底层 比如 Hash 、ConcurrentHashMap、LinkedHashMap、LRU (LRU 要会自己敲底层实现，其实跟 LinkedHashMap 差不多)；</p>\n<p>8 设计模式</p>\n<p>关于设计模式我并没有单独拎出来学习，而是在学框架的时候用到了什么就补充了一下。</p>\n<p>比如学到 bean 的作用范围的时候补充学习了一下单例模式；</p>\n<p>学 IOC 的时候补充学习了一下工厂模式；</p>\n<p>学 AOP 的时候补充学习了代理模式；</p>\n<p>学习 Redistemplate 的时候补充学习了模板模式；</p>\n<p><strong>强化阶段：（强化阶段学的还不太好，会在毕业前进行再强化）</strong></p>\n<p>1 <a href=\"/jump/super-jump/word?word=redis\" title=\"redis\">redis</a>（很重要，务必要熟练掌握，好像每次面试都被问到了）</p>\n<p>热 key 和大 key 问题、击穿、穿透、雪崩、数据类型底层、RDB&amp;AOF、实现消息中间件（发布者订阅者模式）、过期与淘汰策略。</p>\n<p>2 分布式（主要学的分布式锁 分布式事务）</p>\n<p>3 微服务</p>\n<p>4 消息中间件（我努力加强）</p>\n<h2 id=\"学习路线3\"><a class=\"anchor\" href=\"#学习路线3\">#</a> 学习路线 3</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY2FvbGVpQ29kaW5nL3AvNjE3MDU1NS5odG1s\">https://www.cnblogs.com/caoleiCoding/p/6170555.html</span></p>\n<h2 id=\"经验\"><a class=\"anchor\" href=\"#经验\">#</a> 经验</h2>\n<p><a href=\"https://blog.csdn.net/v123411739/article/details/115498947?ops_request_misc=%7B%22request%5Fid%22%3A%22165910547516782388038827%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=165910547516782388038827&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-4-115498947-null-null.142%5Ev35%5Eexperiment_2_v1&amp;utm_term=%E5%B0%9A%E7%A1%85%E8%B0%B7MySQL&amp;spm=1018.2226.3001.4187\" title=\"https://blog.csdn.net/v123411739/article/details/115498947?ops_request_misc=%7B%22request%5Fid%22%3A%22165910547516782388038827%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=165910547516782388038827&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-4-115498947-null-null.142^v35^experiment_2_v1&amp;utm_term=尚硅谷MySQL&amp;spm=1018.2226.3001.4187\">https://blog.csdn.net/v123411739/article/details/115498947?ops_request_misc=%7B%22request%5Fid%22%3A%22165910547516782388038827%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=165910547516782388038827&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-4-115498947-null-null.142<sup>v35</sup>experiment_2_v1&amp;utm_term = 尚硅谷 MySQL&amp;spm=1018.2226.3001.4187</a></p>\n<p><img data-src=\"D:%5CWolai%5C%E7%AC%94%E8%AE%B0%5C%E8%BD%AC%E7%A0%81%E4%B9%8B%E8%B7%AF%5Cimage%5Cimage_A80nTpU_Sw.png\" alt=\"\" /></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL2NIeEJMSENtS253ZFJSM0J0MTFWNFU=\">IDEA 架构</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL3FNeFRSVDdIYmQ3NndzNUxXQlhYYzU=\">配置环境</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tL3hnRjVVclpTNzdFRHJMcGhrQWFMMlE=\">设计模式</span></p>\n<hr />\n<h2 id=\"神的博客笔记\"><a class=\"anchor\" href=\"#神的博客笔记\">#</a> 神的博客笔记：</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sdnh1ZXlhbmcudmlwL3RhZ3MvSnVjLw==\">https://lvxueyang.vip/tags/Juc/</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueXVxdWUuY29tL2Z1eXVzYWthaW9yaS95YmMyZzg/dGhlbWU9bGlnaHQ=\">https://www.yuque.com/fuyusakaiori/ybc2g8?theme=light</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud29sYWkuY29tLzU0N2JKYzNwallzWmlDR21pcG5GOGE=\">英文储备</span></p>\n",
            "tags": [
                "转码之路",
                "转码之路"
            ]
        },
        {
            "id": "https://aristotlednzk.github.io.com/2022/10/09/hello-world/",
            "url": "https://aristotlednzk.github.io.com/2022/10/09/hello-world/",
            "title": "Hello World",
            "date_published": "2022-10-09T12:55:06.990Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo new <span class=\"token string\">\"My New Post\"</span></pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo server</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo generate</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo deploy</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": []
        }
    ]
}